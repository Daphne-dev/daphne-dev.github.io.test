{"pages":[],"posts":[{"title":"[프로그래머스] Level 1 완주하지 못한 선수","text":"풀이 123456from collections import Counterdef solution(participant, completion): answer = Counter(participant) - Counter(completion) return list(answer.keys())[0] collections 모듈의 Counter 클래스를 사용하면 쉽게 풀 수 있는 문제이다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/42576","link":"/2020/08/13/algo-001/"},{"title":"[프로그래머스] Level 3 섬 연결하기","text":"풀이 1234567891011121314151617181920212223242526272829def solution(n, costs): answer = 0 # 1이면 이미 연결된 노드, 0이면 연결 되지 않은 노드 tmp = [0] * n # 처음 조건문을 통과하기 위해 미리 1을 줌 tmp[0] = 1 # 비용이 작은 순으로 정렬 costs = sorted(costs, key=lambda x:x[2]) # 모든 노드가 연결될 때까지 반복 while sum(tmp) != n: for cost in costs: s, e, c = cost # 시작노드와 끝노드 둘 중 하나는 tmp에 있어야 한다. if tmp[s] or tmp[e]: # 시작노드와 끝노드 둘 다 저장되어 있다면 이미 최소의 비용으로 연결된 상태이므로 다음으로 넘어간다. if tmp[s] and tmp[e]: continue # 만약 아니라면 비용을 추가하고 시작노드와 끝노드가 방문했음을 저장한다. else: tmp[s] = 1 tmp[e] = 1 answer += c break return answer 크루스칼 알고리즘(Kruskal Algorithm)을 이용하면 풀 수 있는 문제이다.크루스칼 알고리즘은 가장 적은 비용으로 모든 노드를 연결하기 위해 사용하는 알고리즘이다.즉, 최소 비용 신장 트리를 만들기 위한 알고리즘이다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/42861","link":"/2020/08/16/algo-002/"},{"title":"[프로그래머스] Level 3 단속카메라","text":"풀이 12345678910111213141516def solution(routes): # 고속도로에서 나간 지점을 기준으로 해서 오름차순 정렬 routes = sorted(routes, key=lambda x: x[1]) # 차량이 있을 수 있는 최소한의 지점 -30000 last_camera = -30000 answer = 0 for route in routes: # 만약 마지막 카메라 위치가 진입지점보다 뒤에 있을 경우 if last_camera &lt; route[0]: answer += 1 last_camera = route[1] return answer 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/42884","link":"/2020/08/17/algo-003/"},{"title":"[프로그래머스] Level 3 네트워크","text":"입출력 예 설명 풀이 12345678910111213141516171819202122232425262728from collections import dequedef bfs(computers, check, i, n): queue = deque() queue.append(i) while queue: node = queue.pop() check[node] = True for j in range(n): # 아직 해당 컴퓨터에 방문하지 않았고, # 현재 컴퓨터와 연결되어 있다면 큐에 추가 if check[j] == False and computers[node][j] == 1: queue.append(j)def solution(n, computers): answer = 0 # True면 해당 컴퓨터를 방문함 # False면 아직 해당 컴퓨터를 방문하지 않음 check = [False] * n for i in range(n): if check[i] == False: # bfs 함수를 나오면 하나의 네트워크가 모두 탐색되었다는 의미 # 따라서 bfs 함수에 들어간 횟수 = 네트워크의 개수 bfs(computers, check, i, n) answer += 1 return answer 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/43162","link":"/2020/08/18/algo-005/"},{"title":"[프로그래머스] Level 3 기지국 설치","text":"풀이 1234567891011121314151617def solution(n, stations, w): answer = 0 idx = 0 location = 1 # 마지막 아파트 위치에 도달할 때까지 반복 while(location &lt;= n): # 기존에 기지국이 설치되어 전파가 전달되는 위치인지 확인 if(idx &lt; len(stations) and location &gt;= stations[idx] - w): location = stations[idx] + w + 1 idx += 1 # 범위내에 없을시 기지국 하나를 설치 # 전파가 닿는 최대범위의 바로 다음 아파트까지 이동 else: location += 2*w+1 answer += 1 return answer 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/12979","link":"/2020/08/18/algo-004/"},{"title":"[프로그래머스] Level 3 단어 변환","text":"풀이 12345678910111213141516171819202122232425262728293031from collections import deque# 단어 비교 함수# 단어를 서로 비교했을 시 하나의 알파벳만 다를 경우 True를 리턴def transistable(a, b): return sum((1 if x != y else 0)for x, y in zip(a, b)) == 1def solution(begin, target, words): # target이 words 안에 없을 시 변환할 수 없으므로 0을 리턴 if target not in words: return 0 q, d = deque(), dict() # queue에 begin값과 0을 넣음 # 아직 변환하기 전이므로 0이다. q.append((begin, 0)) # 변환 가능한 단어의 쌍으로 딕셔너리 생성 d[begin] = set(filter(lambda x: transistable(x, begin), words)) for w in words: d[w] = set(filter(lambda x: transistable(x, w), words)) # bfs while q: word, answer = q.popleft() for w in d[word]: if w == target: return answer + 1 else: q.append((w, answer+1)) 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/43163","link":"/2020/08/20/algo-007/"},{"title":"[프로그래머스] Level 3 여행경로","text":"풀이 1234567891011121314151617181920212223242526272829def solution(tickets): # 빈 딕셔너리 자료형 생성 ticket_dic = dict() # 주어진 티켓 정보를 딕셔너리로 변환 for ticket in tickets: if ticket[0] in ticket_dic: ticket_dic[ticket[0]].append(ticket[1]) else: ticket_dic[ticket[0]] = [ticket[1]] # 알파벳 순서가 앞서는 경로에 먼저 가기 위해 # stack을 활용하므로 내림차순으로 정렬 for i in ticket_dic.keys(): ticket_dic[i].sort(reverse=True) # 조건에 따라 &quot;ICN&quot; 부터 시작 stack = [&quot;ICN&quot;] answer = [] while stack: node = stack[-1] if node not in ticket_dic or len(ticket_dic[node]) == 0: answer.append(stack.pop()) else: stack.append(ticket_dic[node][-1]) ticket_dic[node].pop() answer.reverse() return answer 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/43164","link":"/2020/08/19/algo-006/"},{"title":"[프로그래머스] Level 3 2 x n 타일링","text":"풀이 1234567891011def solution(n): answer = 0 mod = 1000000007 fibo = [1, 2] + [0] * n # 타일을 배치하는 경우의 수를 점화식으로 나타낼 수 있다. for i in range(2, n + 1): fibo[i] = fibo[i-1] + fibo[i-2] fibo[i] %= mod return fibo[n-1] 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/12900","link":"/2020/08/26/algo-009/"},{"title":"[프로그래머스] Level 3 가장 먼 노드","text":"풀이 123456789101112131415161718192021222324252627282930from collections import dequedef solution(n, edge): # 거리 answer = [0] * n # 방문한 노드 확인 visited = [False] * n # 그래프 생성 d = [[] for _ in range(n+1)] for (e1, e2) in edge: d[e1-1].append(e2 -1) d[e2-1].append(e1 -1) q = deque() q.append(0) # BFS while q: node = q.popleft() for i in d[node]: # 방문 안했으면 방문 처리하고 # 해당 노드와 이어진 노드를 모두 큐에 추가한 후 # 거리 +1 추가 if visited[i] == False: visited[i] = True q.append(i) answer[i] = answer[node] + 1 # 맨 처음 시작 노드인 1을 제외한 노드 1과 가장 멀리 떨어진 노드를 카운트 return answer[1:].count(max(answer)) 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/49189","link":"/2020/08/20/algo-008/"},{"title":"[프로그래머스] Level 3 N으로 표현","text":"풀이 123456789101112131415161718192021222324252627282930def solution(N, number): # N 사용횟수가 8이 넘으면 -1 리턴 answer = -1 # N을 사용해 표현할 수 있는 이전 값을 저장 DP = [] # N 사용횟수 1~8 for i in range(1, 9): # N을 이어붙일 경우 # 중복이 안되게 하기위해 딕셔너리에 저장 num_set = {int(str(N) * i)} # 이전 값과 N을 사용해 만들 수 있는 모든 자연수 생성 for j in range(0, i-1): for x in DP[j]: for y in DP[-j -1]: num_set.add(x + y) num_set.add(x - y) num_set.add(x * y) if y != 0: num_set.add(x // y) # 목표인 number 값이 만들어졌다면 N이 사용된 횟수를 리턴 if number in num_set: return i # 이전 값과 N을 사용해 만들 수 있는 모든 자연수 저장 DP.append(num_set) return answer 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/42895","link":"/2020/08/27/algo-010/"},{"title":"[프로그래머스] Level 2 다리를 지나는 트럭","text":"풀이 1234567891011121314151617181920def solution(bridge_length, weight, truck_weights): answer = 0 bridge = [0] * bridge_length timer = 0 while len(truck_weights) &gt; 0: if sum(bridge[1:]) + truck_weights[0] &lt;= weight: bridge.append(truck_weights.pop(0)) else: while bridge[1] == 0: bridge.pop(1) bridge.append(0) timer += 1 bridge.append(0) timer += 1 bridge.pop(0) timer += len(bridge) return timer 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/42583","link":"/2020/08/31/algo-012/"},{"title":"[프로그래머스] Level 3 입국심사","text":"풀이 1234567891011121314151617181920212223def check(times, mid, n): res = 0 for time in times: res += (mid // time) if res &gt;= n: return res return resdef solution(n, times): # times는 이미 오름차순 정렬이 되어있다. # 최소 시간을 0 # 최대 시간을 모든 사람이 심사를 받는데 걸리는 시간으로 저장한다. s = 0 e = times[-1] * n ans = e while s &lt;= e: mid = (s+e) // 2 if check(times, mid, n) &gt;= n: ans = min(ans, mid) e = mid - 1 else: s = mid + 1 return ans 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/43238","link":"/2020/09/03/algo-013/"},{"title":"[프로그래머스] Level 3 정수 삼각형","text":"풀이 123456789101112131415def solution(triangle): # 정수 삼각형의 두 번째 줄 부터 계산 # 위에서 부터 더해진 값들이 triangle에 저장된다. for i in range(1, len(triangle)): # 삼각형으로 이루어져 있기 때문에 항상 바로 위 보다 숫자가 1개 더 많다 for j in range(i+1): if j == 0: triangle[i][j] += triangle[i-1][j] elif j == i: triangle[i][j] += triangle[i-1][j-1] # 거쳐간 숫자의 합 중에 더 큰 경우를 저장 else: triangle[i][j] += max(triangle[i-1][j-1], triangle[i-1][j]) return max(triangle[-1]) 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/43105","link":"/2020/08/28/algo-011/"},{"title":"[프로그래머스] Level 4 징검다리","text":"풀이 1234567891011121314151617181920212223242526272829303132333435def solution(distance, rocks, n): # 각 바위의 위치 정렬 rocks.sort() # 도착 지점을 바위의 위치에 추가 rocks.append(distance) # 돌과 돌 사이의 거리는 0부터 도착 지점까지 이다. s, e = 0, distance ans = 0 # 시작 값이 끝 값을 넘어설 때 까지 반복 while s &lt;= e: # 이전 돌과 현재 돌 사이의 최소 거리의 기준 mid = (s+e) // 2 tmp = 0 remove_rocks = 0 for rock in rocks: # 이전 돌과 현재 돌 사이의 거리가 기준 값 보다 작을 경우 # 돌을 삭제한다. if rock - tmp &lt; mid: remove_rocks += 1 # 아닐 경우 현재 돌의 위치를 저장 # 다음 돌과 비교한다. else: tmp = rock # 삭제한 돌의 개수가 n보다 크면 # 끝 값을 낮춰 기준 값을 감소 if remove_rocks &gt; n: e = mid - 1 # 아니라면 시작 값을 높여 기준 값을 증가시키고 # 기준 값을 답으로 저장 else: s = mid + 1 ans = mid return ans 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/43236","link":"/2020/09/03/algo-014/"},{"title":"[프로그래머스] Level 3 베스트 앨범","text":"풀이 123456789101112131415161718192021222324252627282930def solution(genres, plays): answer = [] play_d = dict() # {장르 : 총 재생횟수} 형태의 딕셔너리 d = dict() # {장르 : [(고유번호, 플레이 횟수)]} 형태의 딕셔너리 # play_d와 d를 생성 for idx, gp_tuple in enumerate(zip(genres, plays)): g, p = gp_tuple play_d[g] = play_d.get(g, 0) + p if g in d: d[g].append((idx, p)) else: d[g] = [(idx, p)] # 총 재생 횟수를 기준으로 내림차순 정렬 play_d = sorted(play_d.items(), key=lambda x:x[1], reverse=True) # 총 재생 횟수가 많은 노래부터 고유번호를 최대 2개까지 추가 for genre, play in play_d: # 하나의 장르에서 재생된 횟수가 높은 기준으로 정렬 d[genre] = sorted(d[genre], key=lambda x:x[1], reverse=True) cnt = 0 for i in d[genre]: num, play_count = i if cnt == 2: break else: answer.append(num) cnt += 1 return answer 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/42579","link":"/2020/09/03/algo-015/"},{"title":"[프로그래머스] Level 2 문자열 압축","text":"풀이 12345678910111213141516def solution(s): answer = len(s) for i in range(1, len(s)//2+1): word = '' prev = s[0:i] cnt = 1 for j in range(i, len(s), i): if prev == s[j:j+i]: cnt += 1 else: word += str(cnt) + prev if cnt &gt;= 2 else prev prev = s[j:j+i] cnt = 1 word += str(cnt) + prev if cnt &gt;= 2 else prev answer = min(answer, len(word)) return answer 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/60057","link":"/2020/09/09/algo-016/"},{"title":"[프로그래머스] Level 3 추석 트래픽","text":"풀이 12345678910111213141516171819202122def solution(lines): ans = 0 # 각 트래픽의 시작시간과 끝시간을 각각 저장할 배열 생성 start, end = [], [] for line in lines: # 단위를 초(s) 단위로 변경시켜 준다. tmp = float(line[11:13]) * 3600 + float(line[14:16]) * 60 + float(line[17:23]) end.append(tmp) # 시작 시간 = 끝시간 - 처리시간 + 0.001 을 소수 3자리까지 저장 start.append(round(tmp - float(line[24:-1]) + 0.001,3)) for i in range(len(lines)): cnt = 1 for j in range(i+1, len(lines)): # 초당 처리량 = 끝시간 + 1초 &gt; 다른 트래픽의 시작 시간 # 위의 조건에 해당되는 것이 1초 동안의 트래픽의 처리량이다. if end[i] + 1 &gt; start[j]: cnt += 1 # 그 중 최대 처리량을 저장 ans = max(cnt, ans) return ans 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/17676","link":"/2020/09/11/algo-017/"},{"title":"[프로그래머스] Level 2 큰 수 만들기","text":"풀이 123456789101112131415161718192021def solution(number, k): tmp = [] for i, num in enumerate(number): # number의 이전 숫자와 다음 숫자를 서로 비교해서 이전 숫자가 다음 숫자보다 작을 경우 while len(tmp) &gt; 0 and tmp[-1] &lt; num and k &gt; 0 : # 이전 숫자를 제거 tmp.pop() # k를 1감소 k -= 1 # k개의 수를 모두 제거 했을 시 if k == 0: # 남은 숫자들을 tmp에 추가 tmp += list(number[i:]) break tmp.append(num) # 만약 k개의 수를 모두 제거하지 못했다면 if k != 0: # k개 만큼 뒤에서 부터 제거 tmp = tmp[:-k] answer = ''.join(tmp) return answer 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/42883","link":"/2020/09/13/algo-019/"},{"title":"[프로그래머스] Level 2 스킬트리","text":"풀이 1234567891011121314def solution(skill, skill_trees): answer = 0 for i in skill_trees: tmp = '' for j in i: # 스킬에 있는 알파벳만 모으기 if j in skill: tmp += j # tmp = BCD, CBD, CB, BD # 모은 알파벳이 선행 스킬 순서 skill에 맞는다면 +1 if skill.startswith(tmp): answer += 1 return answer 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/49993","link":"/2020/09/12/algo-018/"},{"title":"[프로그래머스] Level 2 전화번호 목록","text":"풀이 12345678910111213def solution(phone_book): for i in range(len(phone_book)): # 전화번호부에 적힌 전화번호 선택 pivot = phone_book[i] # 해당 번호 뒤부터 끝 번호까지 비교 for j in range(i+1, len(phone_book)): # 미리 선택한 전화번호와 전화번호부 안에 남은 전화번호 중 길이가 작은 것을 선택 strlen = min(len(pivot), len(phone_book[j])) # 번호끼리 서로 접두어인 경우가 있을 시 False 반환 if pivot[:strlen] == phone_book[j][:strlen]: return False # 접두어인 경우가 하나도 없다면 True 반환 return True 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/42577","link":"/2020/09/14/algo-020/"},{"title":"[프로그래머스] Level 2 더 맵게","text":"풀이 12345678910111213141516171819202122232425262728import heapqdef solution(scoville, K): answer = 0 # 리스트를 힙으로 변환 heapq.heapify(scoville) # 현재 가장 작은 스코빌 지수가 K 보다 크면 while문 스킵 while scoville[0] &lt; K: # 모든 음식의 스코빌 지수를 K이상으로 만들 수 없는 경우 -1 반환 if len(scoville) == 1: return -1 # 스코빌 지수가 가장 작은 음식 + 두 번째로 스코빌 지수가 작은 음식 * 2 tmp = heapq.heappop(scoville) + heapq.heappop(scoville) * 2 # 힙에 저장 heapq.heappush(scoville, tmp) # 섞은 횟수 +1 answer += 1 # 현재 스코빌 지수가 가장 작은 음식 선택 a = heapq.heappop(scoville) # 해당 음식의 스코빌 지수가 K 이상이라면 지금까지 섞은 횟수 반환 if a &gt;= K: return answer # 아니라면 다시 해당 값 저장 else: heapq.heappush(scoville, a) return answer 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/42626","link":"/2020/09/24/algo-021/"},{"title":"[프로그래머스] Level 2 조이스틱","text":"풀이 12345678910111213141516171819202122232425262728293031323334353637383940414243def solution(name): answer = 0 name = list(name) # 시작 알파벳 tmp = ['A']*len(name) # 커서의 현재 위치 cursor = 0 while True: left = 1 right = 1 # 현재 커서 위치의 글자가 A가 아닐 경우 if name[cursor] != 'A': # 커서를 위, 아래 움직였을때 더 작은 값을 추가 answer += min(ord(name[cursor]) - ord(&quot;A&quot;), (ord(&quot;Z&quot;) - ord(name[cursor])+1)) # 현재 위치를 A로 바꾼다 name[cursor] = 'A' # name의 글자들이 모두 A가 되면 종료 if name == tmp: break # 커서를 왼쪽으로 이동했을 시 값이 A가 아닐 때까지 탐색 for i in range(1, len(name)): if name[cursor-i] == 'A': left += 1 else: break # 커서를 오른쪽으로 이동했을 시 값이 A가 아닐 때까지 탐색 for i in range(1, len(name)): if name[cursor+i] == 'A': right += 1 else: break # 왼쪽, 오른쪽 둘중 가까운 쪽으로 먼저 커서 이동 if right &gt; left: answer += left cursor -= left else: answer += right cursor += right return answer 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/42860","link":"/2020/09/28/algo-023/"},{"title":"[프로그래머스] Level 2 쿼드압축 후 개수 세기","text":"풀이 123456789101112131415import numpy as npdef solution(arr): def fn(a): # 4등분한 조각에서 해당 부분이 모두 0이면 [1, 0] 반환 if np.all(a == 0): return np.array([1, 0]) # 4등분한 조각에서 해당 부분이 모두 0이면 [0, 1] 반환 if np.all(a == 1): return np.array([0, 1]) # 다음 탐색을 위해 배열 길이를 반으로 줄임 n = a.shape[0] // 2 # 4등분으로 나누어서 재귀적으로 수행 return fn(a[n:, n:]) + fn(a[n:, :n]) + fn(a[:n, :n]) + fn(a[:n, n:]) # 결과로 나온 배열을 리스트 형태로 변환 return fn(np.array(arr)).tolist() numpy 라이브러리에 대해 공부할 게 많은 것 같다.해당 라이브러리를 이용하면 배열 조작이 수월해진다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/68936","link":"/2020/10/13/algo-026/"},{"title":"[프로그래머스] Level 2 괄호 변환","text":"풀이 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def divide(w): # 1번 조건, 빈 문자열인 경우, 빈 문자열 반환 if len(w) == 0: return '' # 2번 조건, 균형잡힌 괄호 문자열 u, v로 분리 u = '' for i in w: u += i if u.count('(') == u.count(')'): # 3. '('와 ')'의 개수가 같고 끝이 ')'일 경우 올바른 괄호 문자열이다. if i == ')': # 문자열 v에 대해 1단계부터 다시 수행 및 3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환 return u + divide(w.replace(u,'',1)) # 4. 올바른 괄호 문자열이 아닐 경우 else: # 4-1 ~ 4-5 과정 실행 및 문자열 v에 대해 1단계부터 수행 return reverse_bracket(u, divide(w.replace(u,'',1)))# 균형잡힌 괄호일 때 올바른지 체크def check(text): l_cnt = 0 r_cnt = 0 for i in text: if i == '(': l_cnt += 1 else: r_cnt += 1 if l_cnt &lt; r_cnt: return False return Truedef reverse_bracket(u, v): # 4-1. 빈 문자열에 첫 번째 문자로 '('를 붙임 tmp = '(' # 4-2 ~ 4-3 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙임, ')'를 다시 붙임 tmp += v + ')' # 4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙임 for i in u[1:-1]: if i == '(': tmp += ')' else: tmp += '(' # 4-5. 생성된 문자열 반환 return tmpdef solution(w): # 주어진 w가 올바르고 균형잡힌 괄호인지 체크 if check(w): return w # 아닐 경우 문자열 분리 실행 return divide(w) 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/60058","link":"/2020/09/29/algo-025/"},{"title":"[프로그래머스] Level 2 땅따먹기","text":"풀이 123456789101112def solution(land): # 첫 시작 행 저장 new_land = [land[0]] for i in range(1,len(land)): tmp = [] # 4개 열에 대해 순회하면서 자신의 행이 아닌 곳의 값 중에서 가장 큰 값을 선택하여 자기 자신과 더한다. for j in range(4): tmp.append(land[i][j] + max(new_land[i-1][:j] + new_land[i-1][j+1:])) # 누적해서 계산하기 위해 계산한 값을 저장 new_land.append(tmp) return max(new_land[len(land)-1]) 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/12913","link":"/2020/10/21/algo-028/"},{"title":"[프로그래머스] Level 2 삼각 달팽이","text":"풀이 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def solution(n): answer = [] # 숫자 저장 tmp = [[0]*(i+1) for i in range(n)] # 출발 값 지정 i = -1 j = 0 num = 0 # 배열 순회 # 3가지로 방향을 나눌 수 있다. # 1. i가 1씩 증가, num 1씩 증가 이후 n 1감소 # 2. j가 1씩 증가, num 1씩 증가 이후 n 1감소 # 3. i,j 각각 1씩 감소, num 1씩 증가 이후 n 1감소 # 다시 1번으로 가서 반복 # 만약 n이 0이 되면 순회 종료 while True: # 1. i가 1씩 증가, num 1씩 증가 이후 n 1감소 for _ in range(n): num += 1 i += 1 tmp[i][j] = num n -= 1 if n == 0: break # 2. j가 1씩 증가, num 1씩 증가 이후 n 1감소 for _ in range(n): num += 1 j += 1 tmp[i][j] = num n -= 1 if n == 0: break # 3. i,j 각각 1씩 감소, num 1씩 증가 이후 n 1감소 for _ in range(n): i -= 1 j -= 1 num += 1 tmp[i][j] = num n -= 1 if n == 0: break # 반환 형식에 맞게 리스트에 모두 저장 for i in tmp: for j in i: answer.append(j) return answer 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/68645","link":"/2020/09/24/algo-022/"},{"title":"[프로그래머스] Level 2 올바른 괄호","text":"풀이 12345678910111213141516171819def solution(s): stack = [] for i in s: # 열린 괄호일 경우 stack에 추가 if i == &quot;(&quot;: stack.append(i) # 닫힌 괄호면서 현재 stack이 비어있으면 False elif i == &quot;)&quot; and len(stack) == 0: return False # 닫힌 괄호면서 현재 stack의 가장 끝 부분이 열린 괄호라면 pop elif i == &quot;)&quot; and stack[-1] == &quot;(&quot;: stack.pop() # stack에 남은 열린 괄호가 있다면 올바르게 짝지어지지 않음을 의미하므로 False if len(stack) != 0: return False return True 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/12909","link":"/2021/01/01/algo-030/"},{"title":"[프로그래머스] Level 3 등굣길","text":"풀이 1234567891011121314151617181920def solution(m, n, puddles): # 그래프 생성, 계산을 편하게 하기위해 m+1, n+1 graph = [[0]*(m+1) for i in range(n+1)] # 시작 위치인 집을 1로 초기화 graph[1][1] = 1 for i in range(1, n+1): for j in range(1, m+1): # 시작 위치인 집은 스킵 if i == 1 and j == 1: continue # 물 웅덩이가 있는 곳 if [j,i] in puddles: # 해당 위치의 경우의 수를 0으로 만듬 graph[i][j] = 0 # 물 웅덩이가 아닐 경우 else: # 현재 위치에서 윗칸과 왼쪽 칸을 더한 값이 해당 위치로 올 수 있는 모든 경우의 수 graph[i][j] = graph[i][j-1] + graph[i-1][j] # 문제의 조건대로 1000000007로 나눈 값을 return return graph[n][m] % 1000000007 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/42898","link":"/2020/09/29/algo-024/"},{"title":"[프로그래머스] Level 2 기능개발","text":"풀이 12345678910111213141516def solution(progresses, speeds): answer = [] time = 0 count = 0 while len(progresses) &gt; 0: if progresses[0] + (time * speeds[0]) &gt;= 100: progresses.pop(0) speeds.pop(0) count += 1 else: if count &gt; 0: answer.append(count) count = 0 time +=1 answer.append(count) return answer 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/42586","link":"/2021/01/21/algo-032/"},{"title":"[프로그래머스] Level 4 무지의 먹방 라이브","text":"풀이 12345678910111213141516171819202122232425262728293031323334353637import heapqdef solution(food_times, k): # 전체 음식을 먹는 시간보다 k가 크거나 같으면 -1 if sum(food_times) &lt;= k: return -1 # 파이썬에서 제공되는 힙은 최소 힙이다. # 시간이 작은 음식을 기준으로 k에 가깝도록 빠르게 감소 시켜야므로 # 시간이 작은 순서대로 음식을 우선 순위 큐에 저장 q = [] for i in range(len(food_times)): heapq.heappush(q, (food_times[i], i+1)) # 음식을 먹는데 사용한 시간 sum_time = 0 # 직전에 다먹은 음식 시간 prev_time = 0 # 남아있는 음식의 개수 food_count = len(food_times) while sum_time + ((q[0][0] - prev_time) * food_count) &lt;= k: now_time = heapq.heappop(q)[0] sum_time += (now_time - prev_time) * food_count food_count -= 1 prev_time = now_time # 남아있는 음식 중 순서가 빠른 순서대로 정렬 answer = sorted(q, key=lambda x:x[1]) # (k - 지금까지 음식을 먹는데 사용한 총 시간) = 남은 시간 # food_count = 남아있는 음식의 개수 # 두 값을 이용해 나머지를 구하면 섭취해야 되는 음식의 번호를 알 수 있다. return answer[(k - sum_time) % food_count][1] 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/42891","link":"/2021/01/06/algo-031/"},{"title":"[프로그래머스] SQL Level 1 모든 레코드 조회하기 MySQL","text":"풀이 123SELECT ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKEFROM ANIMAL_INSORDER BY ANIMAL_ID order by 문을 활용해서 정렬하면 된다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59034","link":"/2020/07/26/algorithm-sql-001/"},{"title":"[프로그래머스] Level 1 신규 아이디 추천","text":"풀이 1234567891011121314151617181920212223242526272829303132333435363738394041def solution(new_id): answer = '' ## 1단계 new_id = new_id.lower() ## 2단계 &amp; 3단계 tmp = '' for str in new_id: if(str == '-' or str == '_' or str == '.' or (97 &lt;= ord(str) &lt;= 122) or (48 &lt;= ord(str) &lt;= 57)): if tmp == '.' and str == '.': tmp = str continue tmp = str answer += str ## 4단계 if len(answer) != 0: if answer[0] == '.': answer = answer[1:] if len(answer) != 0: if answer[-1] == '.': answer = answer[:-1] ## 5단계 if not len(answer): answer = 'a' ## 6단계 if len(answer) &gt;= 16: answer = answer[:15] if answer[-1] == '.': answer = answer[:-1] ## 7단계 if len(answer) &lt;= 2: while len(answer) &lt; 3: answer += answer[-1] return answer 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/72410","link":"/2021/01/27/algo-033/"},{"title":"[프로그래머스] Level 3 보석쇼핑","text":"풀이 1234567891011121314151617181920212223242526272829303132333435from collections import defaultdictdef solution(gems): # 첫 시작은 맨 앞과 맨 뒤의 인덱스 값이다. answer = [0, len(gems)] d = defaultdict(int) # 중복되지 않은 보석의 총 개수를 구한다. gems_size = len(set(gems)) # gems에 들어있는 제일 처음 보석과 보석의 위치를 딕셔너리에 저장 d[gems[0]] = 1 # 투 포인터를 사용하여 탐색하므로 두 개의 포인터의 시작 값을 0으로 지정 s, e = 0, 0 # 두 개의 포인터가 gems의 인덱스 범위 밖으로 넘어가면 탐색 중단 while s &lt; len(gems) and e &lt; len(gems): # 중복되지 않은 보석의 총 개수와 딕셔너리에 저장된 개수가 같을 경우 if gems_size == len(d): # 이전의 포인터 사이의 거리보다 현재 포인터 사이의 거리가 더 작을 경우 if answer[1] - answer[0] &gt; e - s: # 위치 값을 갱신 answer = [s+1, e+1] # 딕셔너리에 저장된 시작 보석 인덱스 값을 -1 감소 d[gems[s]] -= 1 if d[gems[s]] == 0: del d[gems[s]] s += 1 else: e += 1 if e == len(gems): break d[gems[e]] += 1 return answer 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/67258","link":"/2020/10/25/algo-029/"},{"title":"[프로그래머스] SQL Level 1 역순 정렬하기 MySQL","text":"풀이 123SELECT NAME, DATETIMEFROM ANIMAL_INSORDER BY ANIMAL_ID DESC order by 문과 desc 속성을 이용해서 역순으로 정렬하면 된다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59035","link":"/2020/07/26/algorithm-sql-002/"},{"title":"[프로그래머스] SQL Level 1 어린 동물 찾기 MySQL","text":"풀이 123SELECT ANIMAL_ID, NAMEFROM ANIMAL_INSWHERE INTAKE_CONDITION NOT IN (&quot;Aged&quot;) 여기서 말하는 어린 동물이란 INTAKE_CONDITION이 “Aged”가 아닌 경우를 말한다.따라서 where문과 NOT IN을 활용하여 “Aged”가 아닌 경우를 찾으면 된다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59037","link":"/2020/07/28/algorithm-sql-004/"},{"title":"[프로그래머스] SQL Level 1 동물의 아이디와 이름 MySQL","text":"풀이 123SELECT ANIMAL_ID, NAMEFROM ANIMAL_INSORDER BY ANIMAL_ID order by 문을 활용하여 ANIMAL_ID순으로 조회한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59403","link":"/2020/07/29/algorithm-sql-005/"},{"title":"[프로그래머스] SQL Level 1 여러 기준으로 정렬하기 MySQL","text":"123SELECT ANIMAL_ID, NAME, DATETIMEFROM ANIMAL_INSORDER BY NAME, DATETIME DESC order by 문을 활용하여 NAME 순으로 정렬한 후 DATETIME의 역순으로 정렬시킨다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59404","link":"/2020/07/29/algorithm-sql-006/"},{"title":"[프로그래머스] SQL Level 1 아픈 동물 찾기 MySQL","text":"풀이 123SELECT ANIMAL_ID, NAMEFROM ANIMAL_INSWHERE INTAKE_CONDITION LIKE &quot;Sick&quot; 여기서 말하는 아픈 동물이란 INTAKE_CONDITION이 “Sick”에 해당하는 경우를 말한다.where 문을 활용하여 아픈 동물에 해당하는 “Sick”을 찾아 조회하면 된다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59036","link":"/2020/07/28/algorithm-sql-003/"},{"title":"[프로그래머스] SQL Level 1 최댓값 구하기 MySQL","text":"풀이 12SELECT MAX(DATETIME) AS 시간FROM ANIMAL_INS MAX를 활용하여 DATETIME의 가장 큰 값을 구한 뒤 AS를 사용하여 컬럼 값을 DATETIME에서 시간으로 변경한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59415","link":"/2020/07/30/algorithm-sql-008/"},{"title":"[프로그래머스] Level 3 자물쇠와 열쇠","text":"풀이 123456789101112131415161718192021222324252627282930313233343536373839import numpy as npdef solution(key, lock): key_len = len(key) lock_len = len(lock) # key를 조건에 맞게 끼워 맞추기 위해 3배 크기의 새로운 자물쇠 생성 new_lock = [[0 for i in range(lock_len*3)] for j in range(lock_len*3)] # 기존의 lock을 중앙에 배치 for i in range(lock_len,lock_len*2): for j in range(lock_len, lock_len*2): new_lock[i][j] = lock[i-lock_len][j-lock_len] # 쉽게 조작하기 위해 배열로 변환 key = np.array(key) new_lock = np.array(new_lock) # key를 90도씩 4번 돌리기 때문에 4번의 반복 for _ in range(4): # key를 90도 회전 key = np.rot90(key) # key를 new_lock에 순차적으로 끼워 맞춤 for x in range(lock_len * 2): for y in range(lock_len * 2): for i in range(key_len): for j in range(key_len): new_lock[x+i][y+j] += key[i][j] # 끼워 맞췄을 때 자물쇠 부분이 모두 1이면 True if np.all(new_lock[lock_len:lock_len*2, lock_len:lock_len*2] == 1): return True # 자물쇠가 맞춰지지 않았을 경우 # 키를 끼워 맞추기 전으로 다시 원래대로 값을 되돌림 for i in range(key_len): for j in range(key_len): new_lock[x+i][y+j] -= key[i][j] return False 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/60059","link":"/2020/10/18/algo-027/"},{"title":"[프로그래머스] SQL Level 2 동명 동물 수 찾기 MySQL","text":"풀이 12345SELECT NAME, COUNT(NAME) AS COUNTFROM ANIMAL_INSGROUP BY NAMEHAVING COUNT(NAME) &gt;= 2ORDER BY NAME GROUP BY절을 통해 NAME에서 공통적인 데이터끼리 묶은 뒤 HAVING절로 이 중에서 2이상인 그룹만 추출한다. 그 뒤 COUNT로 최종적으로 남은 데이터들을 count 한 뒤 ORDER BY로 NAME 순으로 정렬한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59041","link":"/2020/08/02/algorithm-sql-013/"},{"title":"[프로그래머스] SQL Level 2 최솟값 구하기 MySQL","text":"풀이 12SELECT MIN(DATETIME) AS 시간FROM ANIMAL_INS MIN을 활용하여 DATETIME의 가장 작은 값을 구한 뒤 AS를 사용하여 컬럼 값을 DATETIME에서 시간으로 변경한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59038","link":"/2020/07/31/algorithm-sql-009/"},{"title":"[프로그래머스] SQL Level 2 입양 시각 구하기(1) MySQL","text":"풀이 12345SELECT HOUR(DATETIME) AS HOUR, COUNT(DATETIME) AS COUNTFROM ANIMAL_OUTSGROUP BY HOURHAVING HOUR &gt;= 9 and HOUR &lt; 20ORDER BY HOUR SELECT에서 HOUR(DATETIME)을 HOUR로 별칭(ALIAS)으로 지정한다.HOUR는 MySQL에서 해당 날짜에 대해 시간만을 반환한다.GROUP BY로 그룹화한 뒤 HAVING절을 이용해 09:00부터 19:59까지 시간을 지정하고 ORDER BY를 통해 시간대 순으로 정렬한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59412","link":"/2020/08/02/algorithm-sql-014/"},{"title":"[프로그래머스] SQL Level 2 고양이와 개는 몇 마리 있을까 MySQL","text":"풀이 1234SELECT ANIMAL_TYPE, COUNT(ANIMAL_TYPE) AS countFROM ANIMAL_INSGROUP BY ANIMAL_TYPEORDER BY ANIMAL_TYPE GROUP BY 절을 활용하여 고양이와 개를 그룹별로 분리한 다음, COUNT를 활용하여 수를 세면 된다.이때 GROUP BY 절만 사용해도 예시와 같이 Cat, Dog 순서로 나열이 되지만 문제의 조건에 고양이를 개보다 먼저 조회하라는 조건이 있기 때문에 GROUP BY 절만 활용하면 틀렸다고 결과가 나온다. ORDER BY 절을 활용하여 정렬한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59040","link":"/2020/08/01/algorithm-sql-012/"},{"title":"[프로그래머스] SQL Level 2 동물 수 구하기 MySQL","text":"풀이 12SELECT COUNT(*) AS countFROM ANIMAL_INS COUNT를 활용하여 모든 동물의 수를 구한 뒤 AS를 사용하여 컬럼 값을 count로 변경한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59406","link":"/2020/07/31/algorithm-sql-010/"},{"title":"[프로그래머스] SQL Level 2 중복 제거하기 MySQL","text":"풀이 12SELECT COUNT(DISTINCT NAME) AS countFROM ANIMAL_INS DISTINCT를 활용하면 중복되는 데이터를 제외해준다. 이를 이용해 중복되는 NAME 값을 제외하고, 이 값을 집계함수인 COUNT를 이용해 NULL을 제외한 이름만을 카운트한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59408","link":"/2020/08/01/algorithm-sql-011/"},{"title":"[프로그래머스] SQL Level 4 입양 시각 구하기(2) MySQL","text":"풀이 1234567SET @HOUR = -1;SELECT (@HOUR := @HOUR + 1) AS HOUR,(SELECT COUNT(*)FROM ANIMAL_OUTSWHERE HOUR(DATETIME) = @HOUR) AS COUNTFROM ANIMAL_OUTSWHERE @HOUR &lt; 23 입양 시각 구하기(1) 문제와 유사하지만 0 ~ 23까지 모든 HOUR를 출력해야 한다. MySQL SETSET @변수명 = ‘값’; HOUR 라는 변수에 -1을 대입한다.@HOUR := @HOUR + 1을 통해 HOUR을 1씩 증가시켜 0 ~ 23까지 모든 시간에 대한 COUNT를 구한다.WHERE 절을 통해 23시까지만 출력되게 한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59413","link":"/2020/08/03/algorithm-sql-015/"},{"title":"[프로그래머스] SQL Level 1 상위 n개 레코드 MySQL","text":"풀이 1234SELECT NAMEFROM ANIMAL_INSORDER BY DATETIMELIMIT 1 order by 문을 활용하여 DATETIME 순으로 정렬한 후MySQL의 LIMIT문을 사용하여 가장 상위의 1개의 레코드만 보이게 한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59405","link":"/2020/07/30/algorithm-sql-007/"},{"title":"[프로그래머스] SQL Level 1 이름이 없는 동물의 아이디 MySQL","text":"풀이 123SELECT ANIMAL_IDFROM ANIAML_INSWHERE NAME IS NULL IS NULL을 쓰면 되는 간단한 문제이다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59039","link":"/2020/08/03/algorithm-sql-016/"},{"title":"[프로그래머스] SQL Level 1 이름이 있는 동물의 아이디 MySQL","text":"풀이 1234SELECT ANIMAL_IDFROM ANIAML_INSWHERE NAME IS NOT NULLORDER BY ANIMAL_ID IS NOT NULL을 이용해 NAME이 NULL인 값을 제외하고 추출한다. ORDER BY를 이용해 오름차순으로 정렬한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59407","link":"/2020/08/04/algorithm-sql-017/"},{"title":"[프로그래머스] SQL Level 2 NULL 처리하기 MySQL","text":"풀이 123SELECT ANIMAL_TYPE, IFNULL(NAME, &quot;No name&quot;) AS NAME, SEX_UPON_INTAKEFROM ANIAML_INSORDER BY ANIMAL_ID IFNULL은 MySQL에서 NULL인 값을 다른 값으로 출력하게 해주는 함수이다. 아래와 같이 사용할 수 있다. IFNULL(컬럼, “대체할 값”) IFNULL을 이용하여 NAME안의 NULL인 값을 “No name”으로 출력한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59410","link":"/2020/08/04/algorithm-sql-018/"},{"title":"[프로그래머스] SQL Level 3 없어진 기록 찾기 MySQL","text":"풀이 12345SELECT OUTS.ANIAML_ID, OUTS.NAMEFROM ANIAML_INS INSRIGHT JOIN ANIMAL_OUTS OUTS ON INS.ANIMAL_ID = OUTS.ANIMAL_IDWHERE INS.ANIMAL_ID IS NULLORDER BY OUTS.ANIMAL_ID 입양을 간 기록은 있는데, ANIMAL_OUTS 테이블에만 ANIMAL_ID, NAME 값이 있고 보호소에 들어온 기록이 없는 동물의 ID와 이름 ANIMAL_INS 테이블에는 ANIMAL_OUTS 테이블에는 있는 동물이 NULL값으로 되어있는 것을 말한다. 이를 토대로 SQL을 작성한다면 RIGHT JOIN을 사용하면 된다. WHERE을 이용하여 ANIMAL_INS의 데이터가 없는 경우를 찾는다. 그 ORDER BY를 통해 ID순으로 정렬한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59042","link":"/2020/08/05/algorithm-sql-019/"},{"title":"[프로그래머스] SQL Level 4 보호소에서 중성화한 동물 MySQL","text":"풀이 12345SELECT INS.ANIMAL_ID, INS.ANIMAL_TYPE, INS.NAMEFROM ANIAML_INS INSLEFT JOIN ANIMAL_OUTS OUTS ON INS.ANIMAL_ID = OUTS.ANIMAL_IDWHERE INS.SEX_UPON_INTAKE LIKE 'I%' AND OUTS.SEX_UPON_OUTCOME NOT LIKE 'I%'ORDER BY INS.ANIMAL_ID 보호소에 들어올 당시에는 중성화가 되지 않음 INS.SEX_UPON_INTAKE 값이 Intact로 시작하는 경우 보호소를 나갈 당시에는 중성화된 동물 OUTS.SEX_UPON_OUTCOME 값이 Intact를 제외한 값인 경우 LIKE절을 활용하여 Intact가 있는지 여부와 Intact를 NOT LIKE절을 활용하여 제외한 경우를 찾으면 된다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59045","link":"/2020/08/06/algorithm-sql-022/"},{"title":"[프로그래머스] SQL Level 3 오랜 기간 보호한 동물(1) MySQL","text":"풀이 123456SELECT INS.NAME, INS.DATETIMEFROM ANIAML_INS INSLEFT JOIN ANIMAL_OUTS OUTS ON INS.ANIMAL_ID = OUTS.ANIMAL_IDWHERE OUTS.DATETIME IS NULLORDER BY INS.DATETIMELIMIT 3 입양을 못 간 동물을 기준으로 하기 때문에 ANIMAL_INS 테이블을 기준으로 JOIN을 한다.WHERE 절을 이용해 ANIMAL_OUTS 테이블의 DATETIME이 NULL인 경우를 찾는다.그 중 가장 오래 보호소에 있었던 동물이므로 보호 시작일이 가장 빠른 동물을 찾으면 될 것이다.ORDER BY 절을 통해 ANIMAL_INS 테이블의 DATETIME을 오름차순 정렬한다.마지막으로 LIMIT를 사용해 3마리까지만 조회한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59044","link":"/2020/08/06/algorithm-sql-021/"},{"title":"[프로그래머스] SQL Level 2 루시와 엘라 찾기 MySQL","text":"풀이 1234SELECT ANIMAL_ID, NAME, SEX_UPON_INTAKEFROM ANIAML_INSWHERE NAME IN ('Lucy', 'Ella', 'Pickle', Rogan', 'Sabrina', 'Mitty')ORDER BY ANIMAL_ID WHERE 절의 IN을 활용하여 조회한다.아이디순으로 조회해달라는 조건이 있으므로 ORDER BY를 통해 아이디순으로 정렬한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59046","link":"/2020/08/07/algorithm-sql-023/"},{"title":"[프로그래머스] SQL Level 3 있었는데요 없었습니다 MySQL","text":"풀이 12345SELECT INS.ANIAML_ID, INS.NAMEFROM ANIAML_OUTS OUTSLEFT JOIN ANIMAL_INS INS ON INS.ANIMAL_ID = OUTS.ANIMAL_IDWHERE INS.DATETIME &gt; OUTS.DATETIMEORDER BY INS.DATETIME 보호 시작일에 해당하는 데이터는 제대로 입력되었으므로 해당 데이터가 있는 테이블을 기준으로 JOIN을 한다. 그 뒤 WHERE절을 이용해 보호 시작일(OUTS.DATETIME)보다 입양일(OUTS.DATETIME)이 더 빠른 경우를 찾는다.마지막으로 ORDER BY절을 통해 보호 시작일이 빠른 순으로 정렬한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59043","link":"/2020/08/05/algorithm-sql-020/"},{"title":"[프로그래머스] SQL Level 2 중성화 여부 파악하기 MySQL","text":"풀이 12345678SELECT ANIMAL_ID, NAME,CASEWHEN SEX_UPON_INTAKE NOT LIKE &quot;Intact%&quot;THEN &quot;O&quot;ELSE &quot;X&quot;END AS &quot;중성화&quot;FROM ANIAML_INSORDER BY ANIMAL_ID CASE ~ WHEN ~ THEN ~ ELSE ~ END를 사용하는 문제이다.NOT LIKE를 사용하여 Intact가 포함된 단어이면 X, 아니면 O로 표시한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59409","link":"/2020/08/08/algorithm-sql-025/"},{"title":"[프로그래머스] SQL Level 2 DATETIME에서 DATE로 형 변환 MySQL","text":"풀이 12SELECT ANIMAL_ID, NAME, DATE_FORMAT(DATETIME, '%Y-%m-%d') AS &quot;날짜&quot;FROM ANIAML_INS INS DATE_FORMAT 함수를 사용하면된다. DATE_FORMAT 함수주어진 시간에 대한 데이터를 원하는 형태로 변환하는 함수이다.DATE_FORMAT(date, format)DATE_FORMAT 참고 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59414","link":"/2020/08/09/algorithm-sql-027/"},{"title":"[프로그래머스] SQL Level 2 이름에 el이 들어가는 동물 찾기 MySQL","text":"풀이 1234SELECT ANIMAL_ID, NAMEFROM ANIAML_INSWHERE ANIMAL_TYPE IN ('Dog') AND NAME LIKE '%EL%'ORDER BY NAME WHERE절을 사용하여 개(Dog)이면서 이름이 EL이 포함된 것을 조회하면된다.이름순으로 조회하라는 조건이 있으므로ORDER BY절을 통해 정렬한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59047","link":"/2020/08/07/algorithm-sql-024/"},{"title":"[프로그래머스] SQL Level 3 오랜 기간 보호한 동물(2) MySQL","text":"풀이 123456SELECT OUTS.ANIMAL_ID, OUTS.NAMEFROM ANIAML_INS INSRIGHT JOIN ANIMAL_OUTS OUTS ON INS.ANIMAL_ID = OUTS.ANIMAL_IDWHERE OUTS.DATETIME IS NOT NULLORDER BY OUTS.DATETIME - INS.DATETIME DESCLIMIT 2 입양을 간 날짜 OUTS.DATETIME에 처음 보호를 시작한 날짜 INS.DATETIME를 뺀 날짜가 보호 기간이 될 것이다.ORDER BY 를 사용하여 가장 보호 기간이 오래된 동물을 찾는다.LIMIT를 사용하여 그 중에서 최상위 2개까지만 조회한다. 출처 : 프로그래머스 코딩 테스트 연습https://programmers.co.kr/learn/courses/30/lessons/59411","link":"/2020/08/08/algorithm-sql-026/"},{"title":"[JavaScript] Async Await","text":"Async Await Async, Await는 자바스크립트 비동기 처리 방법 중 하나이다.우리가 일반적으로 동기식으로 코드를 작성하듯이 비동기 처리를 작성할 수 있도록 도와준다. 때문에 Callback이나 Promise보다 코드를 읽기가 수월하고 이해가 쉽다. Async Await 예제123456789101112131415161718192021function delay(ms) { return new Promise((resolve) =&gt; setTimeout(resolve, ms));}async function getHi() { await delay(1000); return &quot;Hi&quot;;}async function getUser() { await delay(1000); return &quot;daphne&quot;;}async function getTest() { const hi = await getHi(); const user = await getUser(); return `${hi} ${user}`;}getTest().then(console.log); async, await를 이용한 간단한 예제이다.getTest() 함수에서 await getHi()와 await getUser()을 통해 미리 비동기적으로 Hi와 user의 이름을 받아두었다가 해당 문자를 출력하는 예제이다. 이처럼 비동기적인 처리를 간단하게 작성할 수 있는 것을 볼 수 있는데 여기서 문제점이 있다. getHi가 처리될 때까지 getUser를 실행하지 못한다는 점이다. 로직상으로 두 개의 함수는 상관관계가 없다. 누가 먼저 실행되든 상관없다는 말이다. 이를 해결하기 위해 await를 병렬 처리하는 방법에 대해 알아보자. Async Await 예외 처리 Async Await에서는 예외처리를 try &amp; catch로 간편하게 처리할 수 있다. 1234567891011121314151617181920212223242526function delay(ms) { return new Promise((resolve) =&gt; setTimeout(resolve, ms));}async function getHi() { await delay(1000); throw &quot;error&quot;; //return 'Hi';}async function getUser() { await delay(1000); return &quot;daphne&quot;;}async function getTest() { try { const hi = await getHi(); const user = await getUser(); return hi + &quot; &quot; + user; } catch (err) { return err; }}getTest().then(console.log); throw를 통해 에러를 전달해주고 catch에서 받아서 에러를 처리해준다. Await 병렬 처리1234567891011121314151617181920212223function delay(ms) { return new Promise((resolve) =&gt; setTimeout(resolve, ms));}async function getHi() { await delay(1000); return &quot;Hi&quot;;}async function getUser() { await delay(1000); return &quot;daphne&quot;;}async function getTest() { const hiPromise = getHi(); const userPromise = getUser(); const hi = await hiPromise; const user = await userPromise; return `${hi} ${user}`;}getTest().then(console.log); getHi와 getUser 함수를 await으로 처리하지 말고 미리 실행시켜 둔 값을 await에 담는 방법이다. 이를 통해 병렬적으로 await를 수행할 수 있게 된다. 위의 getTest() 부분을 더 간략하게 표시할 수 있는 방법이 있다. Promise에서 제공하는 API중 하나인 all()을 사용하면 되는데, 코드를 수정하면 다음과 같다. 123function getTest() { return Promise.all([getHi(), getUser()]).then((hiUser) =&gt; hiUser.join(&quot; &quot;));} all()함수안에 비동기 처리할 함수들을 배열안에 모두 주어서 각각의 값들을 배열로 받는 모습을 볼 수 있다.","link":"/2020/10/09/async-await-js/"},{"title":"[백준] 9020번 골드바흐의 추측","text":"풀이 12345678910111213141516171819202122232425262728293031import sysN = int(sys.stdin.readline())numbers = []primes = []a = [False, False] + [True] * (10000)for i in range(N): numbers.append(int(sys.stdin.readline()))for i in range(2, 10001): if a[i]: primes.append(i) for j in range(2*i, 10001, i): a[j] = Falsefor num in numbers: fir, sec = 0, len(primes) -1 ans1, ans2 = 0, 0 while(fir &lt;= sec): sum = primes[fir] + primes[sec] if sum == num: ans1, ans2 = primes[fir], primes[sec] fir += 1 sec -= 1 elif sum &lt; num: fir += 1 else: sec -= 1 print(ans1, ans2) 에라토스테네스의 체를 통해 미리 모든 소수를 구한 뒤 소수만을 이용해 두 개의 수를 찾는데, 빠르게 찾기위해 소수 배열의 처음과 끝부분에 포인터를 두고 찾는 투 포인터 방식을 사용한다. 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/9020","link":"/2020/08/15/baekjoon-002/"},{"title":"[백준] 11047번 동전 0","text":"풀이 1234567891011121314N, K = input().split()N = int(N)K = int(K)coins = []ans = 0for i in range(N): coins.append(int(input()))for i in range(len(coins)-1, -1, -1): if K &gt;= coins[i]: ans += (K // coins[i]) K %= coins[i]print(ans) 각 동전의 가치가 이미 오름차순으로 주어지므로 그리디 알고리즘을 통해 풀 수 있는 문제이다.가장 큰 단위의 가치부터 차례로 비교하는데, K와 같거나 K보다 작은 가치인 경우 나눈 몫을 동전의 개수로, 나머지를 다시 K에 넣어 K값이 0으로 나누어 떨어질 때까지 계산한다. 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/11047","link":"/2020/08/14/baekjoon-001/"},{"title":"[백준] 2606번 바이러스","text":"풀이 123456789101112131415161718192021222324252627282930313233from collections import dequecomputer = int(input())computer_edge = int(input())# 그래프 생성graph = dict()for i in range(computer_edge): a, b = map(int,input().split()) if a in graph: graph[a].append(b) else: graph[a] = [b] if b in graph: graph[b].append(a) else: graph[b] = [a]# BFS를 통해 1번 컴퓨터와 연결된 모든 노드 조사def bfs(graph, n): # 1번 컴퓨터와 연결되어 있다면 visited에 저장됨 visited = [] q = deque() q.append(n) while q: node = q.popleft() if node not in visited: visited.append(node) q.extend(graph[node]) # 자기 자신인 1번 컴퓨터를 뺀 나머지 컴퓨터 수 return len(visited) - 1print(bfs(graph, 1)) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/2606","link":"/2020/08/20/baekjoon-003/"},{"title":"AWS RDS 사용하기","text":"RDS 란? 아마존 관계형 데이터베이스 서비스(Amazon Relational Database Service)을 의미하며 아마존 웹 서비스(AWS)가 서비스하는 분산 관계형 데이터베이스를 말한다. 왜 RDS를 사용해야 하는가?보통의 경우 데이터베이스를 사용한다면 2가지 방법을 고려할 수 있을 것이다. RDS를 사용한다. EC2 인스턴스에 데이터베이스를 직접 설치한다. 당장 지불하는 비용만을 보면 직접 설치하는 방법이 비용이 싸다.하지만 RDS를 사용함으로써 갖게 되는 이점을 놓칠 수 있다. RDS를 사용함으로써 생기는 장점 간단한 셋업 손쉬운 스토리지의 확장 편리한 백업 이 밖에도 여러 기능들을 제공해준다. 이처럼 RDS를 사용함으로써 인프라를 신경쓰지 않고 개발에만 집중할 수 있다.물론 실제 사용할 때는 이 밖에도 많은 것을 고려해야 할 것이다. RDS 사용하기1. AWS에서 데이터베이스 RDS 선택 2. 파라미터 그룹 설정파라미터 그룹은 만들고자 하는 DB 인스턴스의 DB 엔진 구성을 설정할 수 있다.예를 들면 character_set을 utf8bm4로 설정하는 것과 같은 것을 할 수 있다. 좌측의 nav바에서 파라미터 그룹을 선택해줍니다. 파라미터 그룹 생성을 통해 파라미터 그룹 생성을 시작합니다. 파라미터 그룹 이름과 설명을 입력하고 생성 클릭 파라미터 그룹이 생성된 것을 확인할 수 있다. 생성한 파라미터 그룹 이름을 클릭하여 세부 설정을 해보자 기본적으로 이모티콘도 인식이 되게끔 하기위해 utf8bm4 설정을 한다. character_set라고 검색을 한 후 파라미터 편집 버튼을 클릭한다. 모든 값을 utf8bm4로 설정한다. 모두 체크를 한 후 변경 사항 저장 버튼을 클릭한다. collation이라고 검색한다. collation_server를 utf8bm4_unicode_ci로 설정 collation_connection를 utf8bm4_general_ci로 설정 똑같이 변경 사항 저장을 한다. 3. 데이터베이스 생성데이터베이스 생성 버튼을 클릭하여 데이터베이스를 생성한다. 표준 생성을 선택 후 만들고자 하는 DB 유형 선택여기서는 MySQL을 생성할 것이므로 MySQL을 선택했다. 사용하려는 버전을 선택한다.템플릿을 프리 티어로 설정하면 성능은 떨어지지만 일정 기간 동안 무료로 사용이 가능하다. DB 인스턴스 식별자를 입력한다.마스터 사용자 이름은 DB에 접근할 때 DB 관리자 계정을 의미한다.마스터 암호도 마찬가지이다. DB 인스턴스 크기는 무료로 사용하는 것이기 때문에 그대로 둔다.스토리지 용량도 그대로 두면 된다.스토리지 자동 조정은 스토리지 공간이 일정 공간 이상 되면 자동으로 확장시키는 것인데 과금 요소가 될 수 있으므로 체크 해제해둔다. VPC는 기본적으로 설정되어 있는 것을 그대로 둔다.서브넷 그룹도 마찬가지로 그대로 둔다. 퍼블릭 액세스 가능은 예로 설정한다.예로 설정함으로써 외부에서 DB 접근이 가능하게 해준다. VPC 보안그룹은 새로 생성을 클릭하여 새 보안 그룹을 만들어준다.test_rules와 같은 이름으로 설정 후 가용 영역을 설정해준다.EC2와 같은 가용 영역에 설정해두면 같은 가용 영역에 있기 떄문에 성능상 이점을 가져올 수 있다. 추가 연결 구성에서 데이터베이스 포트를 지정하는데 MySQL은 기본적으로 3306으로 보통 약속이 되어있기 때문에 3306으로 해준다. 초기 데이터베이스 이름을 설정하면 DB를 생성할 때 자동으로 만들어준다.여기서는 따로 설정하지는 않을 것이다. DB 파라미터 그룹을 아까 전에 만들었던 test로 선택해준다. 자동 백업 활성화와 모니터링은 과금의 요소가 될 수 있으므로 체크 해제 해준다. 다른 것은 기본 상태 그대로 둔다.삭제 방지 활성화를 체크해준다. 이후 데이터베이스 생성 버튼을 클릭하면 데이터베이스가 생성된다. 생성된 데이터베이스는 DB 인스턴스나 데이터베이스 탭에서 확인이 가능하다. 생성한 데이터베이스로 접근하여 보안 그룹 규칙을 수정한다.인바운드 규칙 편집에 들어가서 인바운드 규칙을 아래와 같이 수정하고 규칙 저장을 한다. 해당 설정은 모든 IP 대역에서 내 DB에 접근이 가능하도록 설정한 것이다.일반적으로 이러한 설정은 위험하다. 사용법을 익히는 것이기 때문에 이렇게 설정해준다. 4. 데이터베이스 접근하기아래의 명령어를 입력하면 생성한 데이터베이스로 접근이 가능하다.RDS Host 주소는 RDS 데이터베이스의 각각의 엔드포인트를 의미한다. 1mysql -h &quot;RDS Host 주소&quot; -u root -p 5. 로컬에서 만든 DB 덤프 생성하기로컬에서 만든 DB를 똑같이 복사해서 옮길 수 있다. 1mysqldump -u root -p &quot;DB 이름&quot; &gt; &quot;파일명&quot;.sql 해당 명령어를 통해 sql 파일로 만들 수 있다. 이 파일을 이용해서 RDS에 복사할 수 있다. 6. 생성한 덤프로 RDS에 적용하기1mysql -h &quot;RDS Host 주소&quot; -u root -p &quot;생성할 DB 이름&quot; &lt; &quot;덤프 해놓은 sql 파일명&quot;.sql","link":"/2021/01/02/aws-rds/"},{"title":"[백준] 1929번 소수","text":"풀이 123456789101112131415161718import sysm, n = map(int,sys.stdin.readline().split())# 소수 구하는 함수# m이상 n이하의 소수를 구한다.def prime(m, n): nums = [False, False] + (n-1)*[True] primes = [] for i in range(2, n+1): if nums[i]: # 만약 해당 소수가 m이상일 경우 출력 if i &gt;= m: print(i) for j in range(2*i, n+1, i): nums[j] = False# 함수 실행prime(m,n) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/1929","link":"/2020/08/22/baekjoon-005/"},{"title":"[백준] 2581번 소수","text":"풀이 1234567891011121314151617181920212223242526272829m = int(input())n = int(input())# 소수 구하는 함수def prime(n): nums = [False, False] + (n-1)*[True] primes = [] for i in range(2, n+1): if nums[i]: primes.append(i) for j in range(2*i, n+1, i): nums[j] = False return primes# n까지의 소수 구하기A = prime(n)answer = []# m이상 n이하의 자연수 중 소수 구하기for i in range(m,n+1): if i in A: answer.append(i)# 만약 m이상 n이하의 자연수 중 소수가 없을 경우 -1if answer: print(sum(answer)) print(min(answer))else: print(-1) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/2581","link":"/2020/08/22/baekjoon-004/"},{"title":"[백준] 7562번 나이트의 이동","text":"풀이 123456789101112131415161718192021222324252627282930313233343536373839404142from collections import dequen = int(input())# 나이트가 이동할 수 있는 모든 지점dx = [-2,-2,-1,1,2,2,1,-1]dy = [-1,1,2,2,1,-1,-2,-2]def bfs(x,y, x_e, y_e): q = deque() q.append([x,y]) board[x][y] = 1 while q: x, y = q.popleft() # 도착 지점에 도달하면 이때까지의 이동한 횟수를 출력 if x == x_e and y == y_e: return board[x][y] -1 # 현재 위치에서 이동할 수 있는 모든 경우의 수 for i in range(8): nx = x + dx[i] ny = y + dy[i] # 이동한 위치가 체스판 범위에서 벗어나지 않을 경우 if 0 &lt;= nx &lt; l and 0 &lt;= ny &lt; l: # 만약 지금까지 나이트가 해당 지점을 방문하지 않았다면 # 현재 위치를 큐에 저장 # 이동 횟수 +1 if board[nx][ny] == 0: q.append([nx,ny]) board[nx][ny] = board[x][y] + 1for i in range(n): l = int(input()) x, y = map(int,input().split()) x_e, y_e = map(int,input().split()) # 나이트가 해당 지점에 방문했는지 판단 # 방문 했다면 몇 회만에 방문했는지 저장 board = [[0]*l for _ in range(l)] print(bfs(x,y,x_e,y_e)) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/7562","link":"/2020/08/25/baekjoon-006/"},{"title":"[백준] 1912번 연속합","text":"풀이 12345678910n = int(input())num_list = list(map(int,input().split()))ans = [num_list[0]]for i in range(n-1): # 이전까지의 누적 값 + 현재값 vs 현재 값 더 큰 값을 선택 ans.append(max(ans[i] + num_list[i+1],num_list[i+1]))print(max(ans)) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/1912","link":"/2020/08/25/baekjoon-007/"},{"title":"[백준] 11057 오르막 수","text":"풀이 1234567891011121314151617181920212223n = int(input())# 수의 길이인 n이 최대 1000이므로 1000까지 구한다.dp = [[0 for i in range(10)] for i in range(1001)]# 나머지 10007 저장mod = 10007# 수의 길이가 1일때 0 ~ 9까지의 수는 모두 오르막 수에 해당 된다.for i in range(10): dp[1][i] = 1# 자리수 0 1 2 3 4 5 6 7 8 9# 1 1 1 1 1 1 1 1 1 1 1# 2 10 9 8 7 6 5 4 3 2 1# 3 55 45 36 28 21 15 10 6 3 1# 각각의 자리 수는 이전 자리 수를 포함해서# 끝 자리 수까지 모두 더한 것임을 알 수 있다.for i in range(2, n+1): for j in range(10): dp[i][j] = sum(dp[i-1][j:])print(sum(dp[n]) % mod) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/11057","link":"/2020/08/26/baekjoon-008/"},{"title":"[백준] 2805 나무자르기","text":"풀이 12345678910111213141516171819202122232425n, m = map(int,input().split())trees = list(map(int, input().split()))# 절단 가능한 최소 높이와 최대 높이를 검색 범위로 설정s, e = 1, max(trees)# 벌목된 나무 총합def check(trees, mid): sum = 0 for i in trees: if i &gt;= mid: sum += i - mid return sumans = 0# 시작점과 끝점이 같아지면 탐색 종료while s &lt;= e: mid = (s+e) // 2 # 벌목된 나무의 총합이 목표값 보다 크면 절단기 높이를 증가 if check(trees, mid) &gt;= m: s = mid + 1 ans = mid # 벌목된 나무의 총합이 목표값 보다 작으면 절단기 높이를 감소 else: e = mid - 1print(ans) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/2805","link":"/2020/09/01/baekjoon-009/"},{"title":"[백준] 11724 연결 요소의 개수","text":"풀이 123456789101112131415161718192021222324252627282930import sys# 런타임 에러 방지를 위한 최대 재귀 깊이 설정sys.setrecursionlimit(10000)n, m = map(int,sys.stdin.readline().split())graph = [[] for _ in range(n+1)]visited = [False] * (n+1)cnt = 0for i in range(m): u, v = map(int, sys.stdin.readline().split()) graph[u].append(v) graph[v].append(u)def dfs(i): # 방문했다면 True visited[i] = True for j in graph[i]: # 연결되어 있는 다른 노드 방문 if not visited[j]: dfs(j)# 1번 노드부터 n번까지 순회하며 방문 여부를 확인for i in range(1, n+1): # 방문되지 않았다는 것은 연결되지 않음을 의미 if not visited[i]: cnt += 1 dfs(i)print(cnt) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/11724","link":"/2020/09/05/baekjoon-011/"},{"title":"[백준] 1753 최단경로","text":"풀이 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import sys, heapq# 노드의 개수 v, 간선의 개수 ev, e = map(int, sys.stdin.readline().split())# 시작 노드 번호 kk = int(sys.stdin.readline())# 노드 간의 거리는 10이하의 자연수이므로# 노드 간의 최대 거리는 10 x v(노드 개수)이다.# 이보다 +1 큰 수를 지정해 노드 간의 거리가 무한, 즉 이어지지 않았음을 표시INF = 10 * v +1# 방향 그래프 생성graph = [[] for _ in range(v+1)]for i in range(e): a, b, w = map(int, sys.stdin.readline().split()) graph[a].append((b,w))# 노드 간의 거리를 무한으로 모두 초기화distance = [INF] * (v+1)# 다익스트라 알고리즘def dijkstra(start): q = [] # 우선 순위 큐를 이용 heapq.heappush(q, (0, start)) # 시작 노드는 거리가 0으로 시작 distance[start] = 0 while q: dist, node = heapq.heappop(q) # 시작 노드부터 현재 선택된 노드로 가는 총 거리 dist보다 # 이전에 계산된 거리가 더 짧다면 스킵 if distance[node] &lt; dist: continue for i in graph[node]: # 현재 선택된 노드와 연결된 다음 노드 : i[0] # 현재 선택된 노드와 연결된 다음 노드까지의 거리 : i[1] cost = dist + i[1] # 이전에 계산된 거리보다 cost가 작다면 # 큐에 지금까지 더해진 최소 거리와 해당 노드를 저장 if cost &lt; distance[i[0]]: distance[i[0]] = cost heapq.heappush(q, (cost, i[0]))# 시작 노드 k에서 각 노드까지의 거리를 구함dijkstra(k)for i in range(1, v+1): if distance[i] == INF: print(&quot;INF&quot;) else: print(distance[i]) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/1753","link":"/2020/09/06/baekjoon-013/"},{"title":"[백준] 2667 단지번호붙이기","text":"풀이 123456789101112131415161718192021222324252627282930313233343536373839404142434445n = int(input())graph = []for i in range(n): graph.append(list(map(int, input())))# 단지 수ans = 0# 각 단지내 집의 수 카운트cnt = 0# 각 단지내 집의 수 저장res = []# DFS 탐색# 하나의 단지를 모두 탐색하면 Truedef dfs(graph, x, y): global cnt if x &lt;= -1 or x &gt;= n or y &lt;= -1 or y &gt;= n: return False if graph[x][y] == 1: cnt += 1 graph[x][y] = 0 dfs(graph, x-1, y) dfs(graph, x, y-1) dfs(graph, x+1, y) dfs(graph, x, y+1) return True return Falsefor i in range(n): for j in range(n): if dfs(graph, i, j) == True: ans += 1 res.append(cnt) cnt = 0print(ans)# 각 단지에 속하는 집의 수를 오름차순 정렬res.sort()for i in res: print(i) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/2805","link":"/2020/09/04/baekjoon-010/"},{"title":"[백준] 18405 경쟁적 전염","text":"풀이 123456789101112131415161718192021222324252627282930313233343536373839from collections import dequeimport sysn, k = map(int, sys.stdin.readline().split())graph = []# 바이러스의 번호, 시간, 바이러스의 위치를 저장data = []for i in range(n): graph.append(list(map(int, sys.stdin.readline().split()))) for j in range(n): if graph[i][j] != 0: data.append((graph[i][j], 0, i, j))target_s, target_x, target_y = map(int, sys.stdin.readline().split())dx = [0, 0, 1, -1]dy = [1, -1, 0, 0]# 가장 낮은 번호의 바이러스부터 퍼지므로 오름차순 정렬data.sort()q = deque(data)while q: v, s, x, y = q.popleft() if target_s == s: break for i in range(4): nx = x + dx[i] ny = y + dy[i] if 0 &lt;= nx &lt; n and 0 &lt;= ny &lt; n: if graph[nx][ny] == 0: graph[nx][ny] = v q.append((graph[nx][ny], s+1, nx, ny))print(graph[target_x-1][target_y-1]) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/18405","link":"/2020/09/07/baekjoon-015/"},{"title":"[백준] 18352 특정 거리의 도시 찾기","text":"풀이 1234567891011121314151617181920212223242526272829303132# 도시 간의 거리가 무조건 1이기 때문에 BFS로 풀이가 가능하다.# 만약 도시 간의 거리가 각각 다르다면 다익스트라 알고리즘을 이용해야 한다.from collections import dequeimport sysn, m, k, x = map(int,sys.stdin.readline().split())graph = [[] for _ in range(n+1)]for _ in range(m): a, b = map(int,sys.stdin.readline().split()) graph[a].append(b)distance = [-1] * (n+1)distance[x] = 0def bfs(x): q = deque() q.append(x) while q: node = q.popleft() for i in graph[node]: if distance[i] == -1: distance[i] = distance[node] + 1 q.append(i)bfs(x)check = Falsefor i in range(1, n+1): if distance[i] == k: print(i) check = Trueif check == False: print(-1) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/18352","link":"/2020/09/07/baekjoon-014/"},{"title":"[백준] 18428 감시 피하기","text":"풀이 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from itertools import combinationsn = int(input())graph = []# 장애물을 설치할 수 있는 'X'가 있는 좌표 모음x_point = []# 선생님들의 위치에 대한 좌표 모음teachers = []for i in range(n): graph.append(list(map(str, input().split()))) for j in range(n): if graph[i][j] == 'X': x_point.append((i,j)) if graph[i][j] == 'T': teachers.append((i,j))# 선생님의 현재 위치에서 특정 방향으로 감시를 진행# 장애물인 'O'가 탐색되면 False# 학생인 'S'가 탐색되면 Truedef watch(x, y, direction): if direction == 0: while y &gt;= 0: if graph[x][y] == 'S': return True if graph[x][y] == 'O': return False y -= 1 if direction == 1: while y &lt; n: if graph[x][y] == 'S': return True if graph[x][y] == 'O': return False y += 1 if direction == 2: while x &gt;= 0: if graph[x][y] == 'S': return True if graph[x][y] == 'O': return False x -= 1 if direction == 3: while x &lt; n: if graph[x][y] == 'S': return True if graph[x][y] == 'O': return False x += 1 return Falsedef process(): for x, y in teachers: for i in range(4): if watch(x, y, i): return True return False# 모든 학생들이 감시로부터 피할 수 있는지의 여부# 기본 값 False# 피하도록 할 수 있다면 Truefind = False# 장애물을 설치할 수 있는 조합을 구하여 완전탐색for data in combinations(x_point, 3): for x, y in data: graph[x][y] = 'O' if not process(): find = True break # 만약 원하는 조합이 아니었을 시 설치된 장애물을 없애기 for x, y in data: graph[x][y] = 'X'if find: print('YES')else: print('NO') 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/18428","link":"/2020/09/07/baekjoon-016/"},{"title":"[백준] 14502 연구소","text":"풀이 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from itertools import combinationsfrom collections import dequeimport copyn, m = map(int, input().split())# 전체 영역 저장graph = []# 빈 칸의 위치 저장z_point = []# 바이러스의 위치 저장virus = []for i in range(n): graph.append(list(map(int, input().split()))) for j in range(m): if graph[i][j] == 0: z_point.append((i,j)) if graph[i][j] == 2: virus.append((i, j))dx = [0, 0, 1, -1]dy = [1, -1, 0, 0]# BFS 탐색을 통해 바이러스 전파def virus_move(graph): # 3개의 벽을 세운 것을 복사 tmp_graph = copy.deepcopy(graph) q = deque(virus) virus_cnt = 0 while q: x, y = q.popleft() for i in range(4): nx = x + dx[i] ny = y + dy[i] # 영역을 벗어나지 않고 if 0 &lt;= nx &lt; n and 0 &lt;= ny &lt; m: # 방문한 지점이 0일 경우 if tmp_graph[nx][ny] == 0: # 바이러스를 뜻하는 2로 변경 tmp_graph[nx][ny] = 2 q.append((nx,ny)) # 바이러스 카운트 +1 virus_cnt += 1 # 안전 영역의 최대 크기 = 전체 0의 개수 - 벽을 추가한 개수(3) - 바이러스 카운트 return len(z_point) - 3 - virus_cntres = 0# 벽을 설치할 수 있는 모든 조합을 구하여 완전 탐색for data in combinations(z_point, 3): for a, b in data: graph[a][b] = 1 # 안전 영역 값이 가장 클 경우를 저장 res = max(res, virus_move(graph)) # 벽을 세운 것을 다시 초기화 for a, b in data: graph[a][b] = 0print(res) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/14502","link":"/2020/09/08/baekjoon-017/"},{"title":"[백준] 7576 토마토","text":"풀이 1234567891011121314151617181920212223242526272829303132333435363738from collections import dequen, m = map(int, input().split())graph = []# 익은 토마토의 위치를 저장tomato = []# 토마토가 익기까지 걸리는 일수ans = 0for i in range(m): graph.append(list(map(int, input().split()))) for j in range(n): if graph[i][j] == 1: tomato.append((i,j,ans))dx = [0, 0, 1, -1]dy = [1, -1, 0, 0]cnt = 0q = deque(tomato)while q: x, y, ans = q.popleft() for i in range(4): nx = x + dx[i] ny = y + dy[i] # 범위를 벗어나지 않으면서 익지 않은 토마토일 경우 if 0 &lt;= nx &lt; m and 0 &lt;= ny &lt; n and graph[nx][ny] == 0: # 익은 토마토로 변경 graph[nx][ny] = 1 # q에 해당 위치를 추가하고 일수 증가 q.append((nx, ny, ans+1))# 만약 익지않은 토마토가 남아 있다면 -1로 답을 변경for i in range(m): for j in range(n): if graph[i][j] == 0: ans = -1print(ans) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/7576","link":"/2020/09/10/baekjoon-018/"},{"title":"[백준] 2644 촌수계산","text":"풀이 123456789101112131415161718192021222324252627282930313233343536import sysfrom collections import deque# 전체 사람의 수 nn = int(sys.stdin.readline())# 촌수를 계산해야 하는 서로 다른 두 사람의 번호x, y = map(int, sys.stdin.readline().split())# 부모 자식들 간의 관계의 개수m = int(sys.stdin.readline())# 그래프 생성graph = [[] for _ in range(n+1)]for i in range(m): a, b = map(int, sys.stdin.readline().split()) graph[a].append(b) graph[b].append(a)# 촌수 누적 촌수를 계산할 수 없을 때 -1 이 되어야 하므로 -1로 초기화count = [-1] * (n+1)# 시작 노드는 0으로 시작count[x] = 0def bfs(node): q = deque() q.append(node) while q: node = q.popleft() for i in graph[node]: if count[i] == -1: count[i] = count[node] + 1 q.append(i)bfs(x)# x 노드 부터 시작해서 y노드에 도착할 때 까지의 누적된 촌수를 알 수 있다.print(count[y]) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/2644","link":"/2020/09/05/baekjoon-012/"},{"title":"[백준] 14501 퇴사","text":"풀이 123456789101112131415161718192021222324252627282930n = int(input())# 1일부터 이므로 각각 0번째 미리 추가해둠# 상담일 수 저장day = [0]# 상담 시 받을 수 있는 금액 저장pay = [0]for _ in range(n): t, p = map(int, input().split()) day.append(t) pay.append(p)def dfs(d, cost): global ans # 상담의 최대 이익 저장 if d == n + 1: ans = max(ans, cost) return if d + day[d] &lt;= n + 1: dfs(d + day[d], cost + pay[d]) if d + 1 &lt;= n + 1: dfs(d + 1, cost)# 최대 수익ans = 0dfs(1, 0)print(ans) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/14501","link":"/2020/09/16/baekjoon-020/"},{"title":"[백준] 14891 톱니바퀴","text":"풀이 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from collections import deque# 톱니바퀴 1~4# t[i][0] = 톱니바퀴 12시방향, t[i][2] 톱니바퀴 3시 방향, t[i][6] 톱니바퀴 9시 방향t = [deque(map(int,input())) for _ in range(4)]# deque의 rotate(x) 함수는 x가 양수면 오른쪽으로 수 만큼 회전하고 음수면 반대로 회전한다.def turn_t(t_num, d): # 톱니바퀴 시작 번호 t_num -= 1 # 현재 기준 톱니바퀴 값 저장 tmp_2 = t[t_num][2] tmp_6 = t[t_num][6] # 현재 톱니바퀴 회전 t[t_num].rotate(d) # 기준 회전 방향 저장 tmp_d = d # 톱니 기준 왼쪽 d = tmp_d for i in range(t_num-1, -1, -1): if t[i][2] != tmp_6: tmp_6 = t[i][6] t[i].rotate(d*-1) d *= -1 else: break # 톱니 기준 오른쪽 d = tmp_d for i in range(t_num+1, 4): if t[i][6] != tmp_2: tmp_2 = t[i][2] t[i].rotate(d*-1) d *= -1 else: breakk = int(input())for _ in range(k): # 톱니바퀴 번호, 회전 방향 t_num, dircetion = map(int, input().split()) turn_t(t_num, dircetion)res = 0# 점수 게산for i in range(4): if t[i][0] == 1: res += 2 ** iprint(res) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/14891","link":"/2020/09/23/baekjoon-022/"},{"title":"[백준] 14499 주사위 굴리기","text":"풀이 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859n, m, x, y, k = map(int, input().split())# 주사위에 적힌 숫자 저장dice_num = [0] * 6# 지도board = []for _ in range(n): board.append(list(map(int, input().split())))# 이동하는 명령 저장moves = list(map(int, input().split()))# 동 서 북 남dx = [0, 0, -1, 1]dy = [1, -1, 0, 0]# 이동할 때마다 저장된 번호의 위치 변경def moving(direction): # 동 if direction == 0: dice_num[0], dice_num[2], dice_num[3], dice_num[5] = dice_num[2], dice_num[5], dice_num[0], dice_num[3] # 서 elif direction == 1: dice_num[0], dice_num[2], dice_num[3], dice_num[5] = dice_num[3], dice_num[0], dice_num[5], dice_num[2] # 북 elif direction == 2: dice_num[0], dice_num[1], dice_num[4], dice_num[5] = dice_num[1], dice_num[5], dice_num[0], dice_num[4] # 남 elif direction == 3: dice_num[0], dice_num[1], dice_num[4], dice_num[5] = dice_num[4], dice_num[0], dice_num[5], dice_num[1]for move in moves: move -= 1 nx = x + dx[move] ny = y + dy[move] # 지도 범위를 벗어나면 해당 명령 무시 if nx &gt;= n or 0 &gt; nx or 0 &gt; ny or ny &gt;= m: continue # 주사위를 이동한 좌표 x, y = nx, ny # 주사위 굴리기 moving(move) # 만약 이동한 칸의 쓰여있는 숫자가 0이면 if board[x][y] == 0: # 주사위의 바닥면에 쓰인 수가 칸에 복사 board[x][y] = dice_num[0] else: # 아닐 경우 칸에 쓰여있는 숫자가 주사위 바닥면으로 복사 dice_num[0] = board[x][y] # 칸에 쓰여 있는 수 0으로 변경 board[x][y] = 0 # 항상 주사위의 윗 면에 쓰여있는 수 출력 # 주사위 윗 면 : dice_num[5] # 주사위 아랫 면 : dice_num[0] print(dice_num[5]) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/14499","link":"/2020/09/23/baekjoon-021/"},{"title":"[백준] 1012 유기농 배추","text":"풀이 123456789101112131415161718192021222324252627282930313233343536373839404142434445import sys# 런타임 에러 방지를 위한 최대 재귀 깊이를 설정sys.setrecursionlimit(50000)t = int(input())# 배추가 서로 인접해있는 것을 하나의 그룹으로 생각하여 그룹의 개수를 구하는 문제이다.# DFS 탐색def dfs(x, y): # 범위를 벗어나면 즉시 종료 if x &lt;= -1 or x &gt;= m or y &lt;= -1 or y &gt;= n: return False # 현재 노드를 방문하지 않았을 경우 if graph[x][y] == 1: # 해당 노드를 방문처리 graph[x][y] = 0 # 상하좌우 방향으로 이동 후 탐색 dfs(x-1, y) dfs(x+1, y) dfs(x, y-1) dfs(x, y+1) return True return Falsefor i in range(t): m, n, k = map(int, input().split()) graph = [[0 for i in range(n)] for j in range(m)] for i in range(k): a, b = map(int, input().split()) graph[a][b] = 1 ans = 0 # 모든 노드에 대하여 배추가 인접한 경우를 탐색 for i in range(m): for j in range(n): # 해당 위치에서 DFS 수행 # 하나의 그룹이 모두 탐색되었다면 True가 반환된다. if dfs(i,j) == True: ans += 1 print(ans) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/1012","link":"/2020/09/10/baekjoon-019/"},{"title":"[백준] 14888 연산자 끼워넣기","text":"풀이 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from itertools import permutationsimport sysn = int(sys.stdin.readline())a = list(map(int, sys.stdin.readline().split()))calculate = list(map(int, sys.stdin.readline().split()))operator = ['+', '-', '*', '/']# 모든 연산자를 저장tmp_c = []# 입력받은 연산자의 개수대로 tmp_c에 저장for i in range(4): for j in range(calculate[i]): tmp_c.append(operator[i])# 연산자에 따라 계산def calculation(o, num, res): if o == '+': res += num if o == '-': res -= num if o == '*': res *= num if o == '/': if res &lt; 0: res *= -1 res = res // num res *= -1 else: res = res // num return res# 최대 값 저장max_num = -sys.maxsize -1# 최소 값 저장min_num = sys.maxsize# 연산자의 모든 경우의 수를 구한 후 중복 제거# permutations(list, x)는 list에서 x개를 꺼내는 모든 경우의 수를 구하는 함수이다.c_list = set(permutations(tmp_c, n-1))# 모든 연산의 경우의 수 완전 탐색for c in c_list: # 처음 시작은 항상 a의 첫 번째 값 res = a[0] for i in range(len(c)): res = calculation(c[i], a[i+1], res) # 이전 값 보다 크면 해당 값을 저장 max_num = max(res, max_num) # 이전 값 보다 작으면 해당 값을 저장 min_num = min(res, min_num)# 최대 값, 최소 값 출력print(max_num)print(min_num) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/14888","link":"/2020/09/24/baekjoon-023/"},{"title":"[백준] 10816 숫자 카드 2","text":"풀이 123456789101112131415161718192021222324252627282930313233# 이분 탐색import sysn = int(sys.stdin.readline())num_card = list(map(int, sys.stdin.readline().split()))m = int(sys.stdin.readline())target_list = list(map(int, sys.stdin.readline().split()))dic = {}# 가지고 있는 숫자 카드 마다의 개수를 dic에 저장for i in num_card: # dic에 존재하면 카드 개수를 +1 if i in dic: dic[i] += 1 # dic에 존재하지 않으면 새로 카드를 생성 1부터 시작 else: dic[i] = 1ans = []# 상근이가 몇 개 가지고 있는 숫자 카드인지 구한다.for target in target_list: # dic 안에 존재하면 해당 카드의 개수를 ans에 추가 if target in dic: ans.append(dic[target]) # 가지고 있지 않은 카드이면 0을 ans에 추가 else: ans.append(0)# 공백으로 구분하여 출력for i in ans: print(i, end=' ') 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/10816","link":"/2020/10/10/baekjoon-025/"},{"title":"[백준] 2110 공유기 설치","text":"풀이 1234567891011121314151617181920212223242526272829303132333435363738394041# 공유기 설치import sysinput = sys.stdin.readlinen, c = map(int, input().split())x = []for i in range(n): x.append(int(input().rstrip()))# 이분 탐색을 하기 위해 데이터를 정렬한다.x.sort()# 집의 최소 위치는 1이기 때문에 1을 준다start = 1# 공유기 사이의 최대 거리는 제일 먼 거리에 있는 집 보다 클 수 없다.end = x[-1]result = 0while start &lt;= end: mid = (start + end) // 2 tmp = x[0] count_c = 1 for i in x: # 현재 위치의 집 - 이전 위치의 집이 mid보다 크거나 같으면 if i - tmp &gt;= mid: # 카운트 하고 count_c += 1 # tmp를 현재 위치로 변경 tmp = i # 카운트한 공유기 개수가 목표 공유기 개수보다 작으면 # 목표한 공유기 사이의 거리를 줄임 if c &gt; count_c: end = mid - 1 # 목표한 공유기 사이의 거리를 늘리고 # 해당 거리를 저장 else: start = mid + 1 result = midprint(result) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/2110","link":"/2020/10/12/baekjoon-027/"},{"title":"[백준] 10815 숫자 카드","text":"풀이 12345678910111213141516171819202122232425262728293031323334353637import sys# 이진 탐색def binary_search(array, target, start, end): while start &lt;= end: mid = (start + end) // 2 if array[mid] == target: return mid if array[mid] &gt; target: end = mid - 1 else: start = mid + 1 return Noneinput = sys.stdin.readlinen = int(input())array = list(map(int, input().split()))m = int(input())x = list(map(int, input().split()))# 숫자 카드의 개수 저장tmp = {}for i in x: tmp[i] = 0# 이분 탐색을 위해 정렬x.sort()# 가지고 있는 숫자 카드를 하나씩 이분 탐색for target in array: # 만약에 존재하면 해당 값을 +1 if binary_search(x, target, 0, m-1) != None: tmp[target] += 1for i in tmp.values(): print(i, end=' ') 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/10815","link":"/2020/10/14/baekjoon-028/"},{"title":"[백준] 1920 수 찾기","text":"풀이 1234567891011121314151617181920212223242526272829# 이분 탐색def binary_search(array, target, start, end): while start &lt;= end: mid = (start + end) // 2 # 찾은 경우 중간점 인덱스 반환 if array[mid] == target: return mid # 타겟보다 중간점 값이 큰 경우 왼쪽 확인 elif array[mid] &gt; target: end = mid - 1 # 타겟보다 중간점 값이 작은 경우 오른쪽 확인 else: start = mid + 1 # 타겟이 존재하지 않는 경우 None 반환 return Nonen = int(input())array = list(map(int, input().split()))m = int(input())x = list(map(int, input().split()))# 이분 탐색은 정렬된 데이터만 가능하므로 정렬array.sort()for i in x: if binary_search(array, i, 0, n-1) != None: print(1) else: print(0) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/1920","link":"/2020/10/10/baekjoon-024/"},{"title":"[백준] 1654 랜선 자르기","text":"풀이 123456789101112131415161718192021222324252627282930313233343536import sysinput = sys.stdin.readlinek, n = map(int, input().rstrip().split())array = []for i in range(k): array.append(int(input()))# 필요한 랜선의 개수는 항상 1보다 커야하므로 시작을 1로 지정start = 1# 자르는 단위의 최대 길이는 가지고 있는 랜선의 최대 길이와 같다.end = max(array)result = 0# 이분 탐색while start &lt;= end: total = 0 mid = (start + end) // 2 # 랜선을 잘라서 나온 개수를 total에 저장 for x in array: total += x // mid # 자른 개수가 n보다 작을 경우 자르는 단위를 줄인다. if n &gt; total: end = mid - 1 # 자른 개수가 n과 같거나 클 경우 해당 단위를 저장한다. # 자르는 단위를 증가시켜 최적의 값을 찾는다. else: result = mid start = mid + 1print(result) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/1654","link":"/2020/10/11/baekjoon-026/"},{"title":"[백준] 9461 파도반 수열","text":"풀이 12345678910111213141516n = int(input())# 테스트 케이스 저장target = []for i in range(n): target.append(int(input()))# 파도반 수열 저장dp = [0,1,1,1,2,2]# d[i] = d[i-1] + d[i-5]for i in range(6, max(target)+1): dp.append(dp[i-1] + dp[i-5])for i in target: print(dp[i]) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/9461","link":"/2020/10/15/baekjoon-029/"},{"title":"[백준] 2798 블랙잭","text":"풀이 12345678910111213from itertools import combinationsn, m = map(int,input().split())cards = list(map(str, input().split()))ans = 0# 3장이 모이는 모든 카드의 조합을 구함for card in combinations(cards, 3): card_sum = sum(list(map(int, card))) # 3장을 더한 값이 m을 넘지 않을 경우 중 최대 값 저장 if card_sum &lt;= m: ans = max(ans, card_sum)print(ans) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/2798","link":"/2020/10/16/baekjoon-030/"},{"title":"[백준] 2231 분해합","text":"풀이 123456789101112131415161718# 0부터 n까지 모든 경우의 수를 구하면 탐색 시간이 너무 오래 걸린다.# 때문에 자리수 * 9를 n에서 뺀 값부터 시작한다.# 각 자리수는 최대 9의 수를 가지기 때문에 예를 들어 n이 3자리 수이면# 생성자를 제외한 분해합의 범위는 0 + 0 + 0 ~ 9 + 9 + 9 까지 가능할 것이다.# 식으로 나타내면 n - (n의 자리 수 길이) * 9# 그 이하의 수에선 생성자를 구할 수 없다.# 단, 해당 식이 1보다 작으면 1부터 시작하게 한다.n = int(input())ans = nfor i in range(max(1, n - len((str(n))) * 9), n): if n == i + sum(map(int, str(i))): ans = min(ans, i)if ans == n: ans = 0print(ans) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/2231","link":"/2020/10/17/baekjoon-031/"},{"title":"[백준] 10989 수 정렬하기","text":"풀이 12345678910111213141516# 계수 정렬로 O(n+k)의 시간 복잡도를 가진다.# n은 n개의 수를 가리킨다.# k는 수의 범위 1~10000을 가리킨다.# 따라서 최악의 경우에도 10,000,000 + 10,000의 시간 복잡도를 가진다.import sysn = int(sys.stdin.readline())array = [0] * 10001for i in range(n): array[int(sys.stdin.readline())] += 1for i in range(1, len(array)): if array[i] != 0: for j in range(array[i]): print(i) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/10989","link":"/2020/11/04/baekjoon-032/"},{"title":"[백준] 10989 통계학","text":"풀이 123456789101112131415161718192021222324252627282930313233import sysfrom collections import Counterinput = sys.stdin.readlinen = int(input())array = []for i in range(n): array.append(int(input()))array.sort()cnt = Counter(array)# 최빈값 구하기cnt = cnt.most_common()if len(cnt) != 1: # 최빈값에 해당하는 숫자가 2개면 두번째 값을 최빈값으로 지정 if cnt[0][1] == cnt[1][1]: cnt = cnt[1][0] else: cnt = cnt[0][0]# 주어진 숫자가 1개만 있을 경우 해당 값을 최빈값으로 지정else: cnt = cnt[0][0]print(round(sum(array) / n))# 주어진 숫자의 개수가 홀수라면 중앙 값을 출력, 짝수라면 두개의 평균 값을 출력print(array[n // 2] if n %2 != 0 else round((array[n // 2] + array[n //2+1])/2))print(cnt)print(array[-1] - array[0]) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/2108","link":"/2020/11/05/baekjoon-033/"},{"title":"[백준] 10989 소트인사이드","text":"풀이 12n = sorted(list(str(input())), reverse=True)print((int(''.join(n)))) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/1427","link":"/2020/11/08/baekjoon-034/"},{"title":"[백준] 1439 뒤집기","text":"풀이 12345678910111213141516171819s = str(input())zero_cnt = 0one_cnt = 0if s[0] == &quot;0&quot;: one_cnt +=1else: zero_cnt += 1for i in range(len(s) -1): # 현재 값이 다음 값이랑 다를 경우 if s[i] != s[i+1]: if s[i+1] == &quot;0&quot;: one_cnt += 1 else: zero_cnt += 1print(min(zero_cnt, one_cnt)) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/1439","link":"/2021/01/02/baekjoon-036/"},{"title":"[백준] 11650 좌표정렬하기","text":"풀이 123456789101112131415161718# 좌표 정렬하기import sysinput = sys.stdin.readlinen = int(input())array = []for i in range(n): array.append(list(map(int, input().split())))# lambda를 이용해 첫번째 인자 x[0]부터 정렬하고, 그 뒤 x[1]을 기준으로 정렬한다.array = sorted(array, key=lambda x: (x[0], x[1]))for i in array: print(i[0], i[1]) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/11650","link":"/2020/11/15/baekjoon-035/"},{"title":"[백준] 18406 럭키 스트레이트","text":"풀이 123456789101112n = str(input())n1 = n[:len(n)//2]n2 = n[len(n)//2:]sum1 = sum(list(map(int, n1)))sum2 = sum(list(map(int, n2)))if sum1 == sum2: print(&quot;LUCKY&quot;)else: print(&quot;READY&quot;) 출처 : 백준 ONLINE JUDGEhttps://www.acmicpc.net/problem/18406","link":"/2021/01/03/baekjoon-037/"},{"title":"[비타알고] 수의 비밀(★1)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드구현12345678num = int(input())while(num % 2 == 0): num /= 2if num == 1: print(&quot;Yes&quot;)else: print(&quot;No&quot;) 비트마스크123456num = int(input())if num == (num &amp; (-num)): print(&quot;Yes&quot;)else: print(&quot;No&quot;) 풀이간단하게 생각해서 구현에 집중한다면 2로 나누어 떨어질 때까지 나누어보는 방법이 있다.하지만 해당 방법은 수가 커지면 커질수록 연산이 기하급수적으로 많아지기 때문에 좋은 방법이 아니다. 비트마스크를 사용하면 이를 해결할 수 있다.여기서 나오는 2의 k승인 형태의 수들은 모두 2진수로 나타내었을때 항상 1인 bit가 하나만 나온다. 입력 받는 수를 num이라 했을 때, (num &amp; (-num))은 가장 마지막에 bit만 켜져있는 수가 된다. 따라서 num의 bit가 1개가 아닌 2개 이상이 켜져있다면 num과 (num &amp; (-num))은 같을 수 없다. 하지만 num의 bit가 1개만 켜져 있다면 두 개의 수는 같을 것이다.","link":"/2020/08/04/bitaalgo-002/"},{"title":"[비타알고] 애틋한 친구(★1)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드12345678910111213141516171819202122232425N = int(input())location = []# 친구들간의 거리를 구하는 함수# 굳이 루트를 씌우지 않아도 비교가 가능하다.def dist(i, j): return (location[i][0] - location[j][0]) **2 + (location[i][1] - location[j][1]) **2for i in range(N): x ,y = list(map(int, input().split())) location.append([x,y])d = 0max_dist = 0ans1, ans2 = 0, 0for i in range(N): for j in range(i, N): d = dist(i, j) if max_dist &lt; d: max_dist = d ans1 = i ans2 = jprint(str(ans1+1) + ' ' + str(ans2+1)) 풀이각각의 친구들사이의 모든 거리를 구해서 서로 가장 거리가 먼 사람을 구하면 되는 문제이다.완전 탐색을 통해 풀 수 있다.","link":"/2020/08/05/bitaalgo-004/"},{"title":"[비타알고] 구슬 수집가(★2)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드12345678N, K = map(int,input().split())boxes = list(map(int,input().split()))ans = 0for i in range(K-1, -1, -1): ans += (N // boxes[i]) N = N % boxes[i]print(ans) 풀이최소 개수의 상자를 이용하여 정리하고 싶다고 하였다.문제 조건을 보면 상자의 크기가 오름차순으로 정렬되어 나오고 상자 크기간의 관계가 항상 정수배를 만족한다고 나와있다. 이는 탐욕 알고리즘을 통해 풀 수 있는 조건이 된다. 가장 큰 상자에 최대한 넣을 수 있는 만큼 구슬을 넣고, 그러고도 구슬이 남는다면 다음 큰 상자에 구슬을 넣는 방식을 반복하면 된다.","link":"/2020/08/11/bitaalgo-006/"},{"title":"[비타알고] 택배왕 안홍자(★3)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드12345678910111213141516171819202122232425N = int(input())pay = []check = [False] * 11ans = 0for i in range(N): # 지역별 보수 저장 pay.append(list(map(int, input().split())))def go(s, sum): global ans, pay, check, N if s == start and sum: # 배달을 나간 후 다시 시작지점으로 돌아왔을 경우 ans = max(ans, sum) # 이전의 보수와 비교해서 최대 보수 갱신 return for i in range(N): if check[i]: # 한 번 방문했던 지역인지 확인, 이미 방문했다면 True, 안했다면 False continue if pay[s][i]: check[i] = True go(i, sum + pay[s][i]) check[i] = Falsefor i in range(N): # 출발 지역 선택 start = i go(i,0)print(ans)","link":"/2020/08/09/bitaalgo-005/"},{"title":"[비타알고] 학생회실에는 프린터가 한 대 뿐입니다.(★2)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드12345678910N = int(input())time = list(map(int, input().split()))time.sort()ans = 0tmp = 0for i in time: tmp += i ans += tmpprint(ans) 풀이간단히 생각하면 모든 사람이 프린터를 사용하기까지 소요되는 가장 적은 시간을 구하는 것이다.프린터는 한 대뿐이기 때문에 사용 중인 사람이 있다면 기다려야한다. 하지만 앞 사람이 프린트를 사용하는 시간이 길수록 뒤의 사람들이 지체되는 시간은 그만큼 점점 늘어난다.때문에 정렬을 하여 가장 시간이 적게 걸리는 사람부터 프린트를 하게하여 최소한의 시간을 구한다.","link":"/2020/08/11/bitaalgo-007/"},{"title":"[비타알고] 부업의 달인(★3)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드123456789101112131415N = int(input())work = []e = 0ans = 0for i in range(N): work.append(list(map(int,input().split())))work_sort = sorted(work, key=lambda x:x[1])for i in work_sort: if i[0] &gt;= e: ans += 1 e = i[1]print(ans) 풀이세 가지의 방법을 생각해볼 수 있다. 시작 시간이 가장 빠른 부업을 먼저 시작하는 방법 걸리는 시간이 짧은 부업을 먼저 시작하는 방법 끝나는 시간이 가장 빠른 부업을 먼저 시작하는 방법 이 중에서 최대한 많은 부업을 할 수 있는 방법은 부업이 끝나는 시간을 기준으로 하는 방법이다. 따라서 끝나는 시간을 오름차순으로 정렬해준 후 겹치는지 확인하면서 개수를 세면 된다.","link":"/2020/08/12/bitaalgo-008/"},{"title":"[비타알고] 환상의 조합(★2)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드12345678910111213141516N, S = map(int, input().split())status = list(map(int,input().split()))cnt = 0hong = status[0]del status[0]def solve(cur, sum): global cnt if cur == (N-1): # 모든 팀원을 체크한 경우 cnt += (sum == S) return solve(cur + 1, sum) solve(cur + 1, sum + status[cur])solve(0, hong)print(cnt) 풀이홍현이를 포함한 부분집합의 합이 S가 되는 경우의 수를 찾는 문제이다.재귀 함수를 이용하여 풀어보자.","link":"/2020/08/05/bitaalgo-003/"},{"title":"[비타알고] 세포분열(★3)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드12345678910111213141516171819202122232425262728293031N, K, T = map(int, input().split())mod = 1000000007def pow(a, n): global mod res = 1 while n: if n % 2: res *=a res %= mod a *= a a %= mod # 큰 값끼리의 연산에서는 몫을 구할 때 주의 / 연산자 대신 // 연산자를 써야된다. # / 연산자를 쓰면 부동 소수점 오차 문제 때문에 변환과정에서 오차가 생긴다. n //= 2 return resdef solve(n, k, t): # 해당 문제를 토대로 등비수열의 합을 식으로 나타내면 # N(K^T -1)/(K-1) 이다. # 이를 1000000007 로 나눈 나머지를 구해야 한다. # mod = 1000000007 # 나머지 연산자의 성질 # (a-b)%c = ((a%c)-(b%c)+c)%c # 페르마의 소정리를 이용 # N(K^T -1)/(K-1) % mod # N(K^T -1)(K-1)^-1 % mod # (((N(K^T -1)) % mod) * (K-1)^(mod-2) % mod) % mod # (((N % mod * (K^T -1) % mod)) % mod * (K-1)^(mod-2) % mod) % mod res = (((N % mod * (pow(k,t) % mod - 1 + mod) % mod)) % mod * pow(k-1, mod-2) % mod) % mod return resprint(solve(N,K,T))","link":"/2020/08/22/bitaalgo-010/"},{"title":"[비타알고] 특등사수(★2)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드123456789101112from math import gcdN = int(input())location = []ans = 0for i in range(N): location.append(list(map(int, input().split())))for i in location: if gcd((abs(i[0])), abs(i[1])) == 1: ans += 1print(ans) 풀이여기서 중요한 것은 원점에 서 있으며 좌표평면의 x, y 값이 정수인 모든 지점에 표적이 놓여있다는 사실이다. 즉, 주어진 표적만 있다고 생각하면 되는 것이 아니라 이미 모든 지점에 표적이 놓여있는 상태임을 인지해야 한다. 이 점을 잊지말고 풀면 된다. 좌표의 x와 y가 서로소여야 문제의 조건에 맞게 된다.","link":"/2020/08/12/bitaalgo-009/"},{"title":"[비타알고] 치킨집 사장님(★2)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드1234567891011N = int(input())mod = 1000000007ans = [0, 1, 1]# 닭을 계산하는 식을 점화식 형태로 나타내면 피보나치 수열과 같은 점화식이 만들어진다.# 이를 토대로 동적 계획법 중 상향식 방법(Bottom-up)으로 구하면 시간내에 구할 수 있다.for i in range(3, N+1): ans.append(ans[i-1]+ ans[i-2]) ans[i] %= modprint(ans[N])","link":"/2020/08/23/bitaalgo-011/"},{"title":"[비타알고] 다리 건설(★3)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드1234567891011# 가장 긴 증가하는 부분 수열의 길이를 구하는 문제n = int(input())seq = list(map(int,input().split()))ans = [1] * nfor i in range(1, n): for j in range(0, i): if seq[j] &lt; seq[i]: ans[i] = max(ans[i], ans[j]+1)print(max(ans))","link":"/2020/08/24/bitaalgo-012/"},{"title":"[비타알고] 맛있는 삼겹살(★2)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드12345678910111213141516171819n = int(input())meat = list(map(int,input().split()))# 고기를 뒤집어야 하는 최대 시간을 오름차순으로 정렬meat.sort()time = 0cnt = 0# 각 시간에 뒤집을 고기를 확인for i in meat: if i &gt;= time: time +=1 cnt +=1 else: continueprint(cnt)","link":"/2020/08/29/bitaalgo-013/"},{"title":"[비타알고] 문단속(★2)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드1234567891011121314151617181920212223n = int(input())go = list(map(int, input().split()))# 문을 열고 들어갔으면 닫고 나와야 한다.# 즉, 가장 나중에 들어온 데이터가 가장 먼저 처리되어야 하는 것을 알 수 있다.# 이를 생각해 스택 구조를 이용해 풀 수 있다.def s(go): stack = [] for i in go: if i &gt; 0: stack.append(i) else: if len(stack) &gt; 0 and stack[-1] == abs(i): stack.pop() else: return &quot;no&quot; if len(stack) == 0: return &quot;yes&quot; else: return &quot;no&quot;print(s(go))","link":"/2020/08/30/bitaalgo-014/"},{"title":"[비타알고] 시공의 폭풍 속으로(★1)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드1234567team_pick = list(map(int, input().split()))my_pick = list(map(int, input().split()))cnt = 0for i in my_pick: if i not in team_pick: cnt +=1print(cnt) 풀이구현을 하면 되는 문제이다.팀이 선택한 영웅을 리스트에 저장하고 내가 선택하고자 하는 영웅을 리스트에 저장한다.내가 선택하고자 하는 영웅이 팀이 선택한 영웅중에 없다면 cnt를 1씩 증가시킨다.","link":"/2020/08/04/bitaalgo-001/"},{"title":"[비타알고] 찾아라 비밀의 열쇠(★2)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드123456789101112131415161718192021222324252627282930313233343536import sysn, k, c = map(int, sys.stdin.readline().split())a = list(map(int, sys.stdin.readline().split()))b = list(map(int, sys.stdin.readline().split()))# 문을 열 수 있는 열쇠 번호를 정렬a.sort()# 이분 탐색을 이용하여 맞는 열쇠를 찾음def check(a, num): # 문을 열 수 있는 열쇠의 최소 번호와 최대 번호 s, e = 0, len(a) -1 while s &lt;= e: mid = (s+e) // 2 # 문을 열 수 있는 열쇠를 찾으면 True if a[mid] == num: return True elif a[mid] &lt; num: s = mid + 1 else: e = mid - 1 # 해당 열쇠로 문을 열지 못하면 False return Falsecnt = 0# 홍현이가 가지고 있는 열쇠와 하나씩 비교for i in b: if check(a, i): cnt += 1 # 필요한 열쇠의 최소 개수가 되면 yes 출력 후 종료 if cnt == c: print(&quot;yes&quot;) break# 만약 필요한 열쇠 개수가 부족하면 no 출력if cnt &lt; c: print(&quot;no&quot;)","link":"/2020/09/01/bitaalgo-015/"},{"title":"[비타알고] 프로그래밍 경진대회(★3)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드1234567891011121314151617181920212223242526272829303132import sysn = int(sys.stdin.readline())a = list(map(int, sys.stdin.readline().split()))k = int(sys.stdin.readline())# 제한 인원 수에 따라 참가 가능한 모든 참가자 수를 구하는 함수def check(a, mid, k): sum = 0 for i in a: # 해당 단체의 인원이 제한 인원을 초과하면 제한 인원까지만 등록 sum += min(mid, i) return sum# 등록할 수 있는 최소 인원과 최대 인원s, e = 0, max(a)sum = sum(a)ans = 0# 전체 인원의 합이 K보다 작은 경우if k &gt;= sum: print(e)else: while s &lt;= e: mid = (s + e) // 2 # 수용할 수 있는 인원 수 보다 크면 제한 인원을 감소 if check(a, mid, k) &gt; k: e = mid -1 # 수용할 수 있는 인원 수 보다 작으면 제한 인원을 증가 else: s = mid +1 ans = mid print(ans)","link":"/2020/09/01/bitaalgo-016/"},{"title":"[비타알고] 보안 검색(★3)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드12345678910111213141516171819202122232425262728293031323334353637import sysn, k = map(int, sys.stdin.readline().split())a = list(map(int, sys.stdin.readline().split()))# 보안 검색을 마치기 위해 걸리는 시간을 정렬a.sort()def check(a, mid, k): res = 0 # 해당 시간에 따라 # 각각의 보안 검색대가 보안검색이 가능한 # 최대 승객 수를 모두 더한다. for i in a: res += (mid // i) if res &gt;= k: return res return resl = 0# 모든 승객이 검색이 끝나는 최대 시간# 대기 중인 승객수 10^9# 보안 검색대에서 걸리는 최대 시간 10^6# 두 수를 곱한 10^15가 된다.# 따라서 해당 값을 최대로 설정하고 이분 탐색을 한다.r = 1e15ans = 1e15while l &lt;= r: mid = (l + r) // 2 # 모든 승객이 보안 검색을 마칠 수 있다면 검색에 걸리는 최소 시간을 줄인다. # 검색을 마칠 수 있는 최적의 값을 구한다. if check(a, mid, k) &gt;= k: ans = min(ans, mid) r = mid - 1 # 모든 승객 보안검색을 마칠 수 없다면 검색에 걸리는 최소 시간을 늘린다. else: l = mid + 1print(int(ans))","link":"/2020/09/01/bitaalgo-017/"},{"title":"[비타알고] 우주의 평화를 위하여(★3)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드1234567891011121314151617181920212223242526272829303132333435363738394041424344import sysn = int(sys.stdin.readline())machine = []# 격자판 생성for i in range(n): machine.append(list(map(int, sys.stdin.readline().split())))# 작동 횟수 초기화ans = 0def check(x, y, size): global machine, ans # 격자판 크기가 1x1이면 작동 횟수 1 증가 if size == 1: ans += 1 return tmp = False target = machine[x][y] for i in range(size): for j in range(size): # 만약 모든 기계가 같은 종류가 아닐 시 탐색을 종료 if machine[i+x][j+y] != target: tmp = True break if tmp: break # 4등분으로 나누어서 다시 탐색 if tmp: half = size // 2 half_x = x + half half_y = y + half check(x, y, half) check(half_x, y, half) check(x, half_y, half) check(half_x, half_y, half) # 모든 기계가 같은 종류라면 작동 횟수 1 증가 else: ans += 1check(0, 0, n)print(ans)","link":"/2020/09/01/bitaalgo-019/"},{"title":"[부스트코스] 웹의 동작 (HTTP 프로토콜 이해)","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/lecture/16661/ HTTP(Hypertext Transfer Protocol)란? 서버와 클라이언트가 인터넷상에서 데이터를 주고받기 위한 프로토콜(protocol) HTTP 작동방식 Server/Client 모델을 따른다. 클라이언트에서 요청(request)를 보내면 서버는 요청을 처리해서 응답(reponse)하는 구조 URL (Uniform Resource Locator) 특정 웹 서버의 특정파일에 접근하기 위한 경로 혹은 주소 HTTP (Hypertext Transfer Protocol) 요청 메서드 : GET, PUT, POST, PUSH, OPTIONS 등의 요청 방식이 온다. 요청 URI : 요청하는 자원의 위치를 명시한다. HTTP 프로토콜 버전 : 웹 브라우저가 사용하는 프로토콜 버전이다. 각각의 메소드들 GET : 정보를 요청하기 위해서 사용한다. (SELECT) POST : 정보를 밀어넣기 위해서 사용한다. (INSERT) PUT : 정보를 업데이트하기 위해서 사용한다. (UPDATE) DELETE : 정보를 삭제하기 위해서 사용한다. (DELETE) HEAD : (HTTP)헤더 정보만 요청한다. 해당 자원이 존재하는지 혹은 서버에 문제가 없는지를 확인하기 위해서 사용한다. OPTIONS : 웹서버가 지원하는 메서드의 종류를 요청한다. TRACE : 클라이언트의 요청을 그대로 반환한다. 예컨대 echo 서비스로 서버 상태를 확인하기 위한 목적으로 주로 사용한다.","link":"/2020/07/19/boostcourse-1-1/"},{"title":"[비타알고] 난 전설 같은 건 믿지 않아(★2)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드123456789101112131415161718192021import sysn, k = map(int, sys.stdin.readline().split())# 하노이의 탑 문제이다.# 재귀 호출을 통해 풀 수 있다.def hanoi(n, start, end): # 기둥의 번호는 1, 2, 3인데 모두 합하면 6이다. # 1번, K번이 아닌 기둥은 6에서 1과 K를 빼면 구할 수 있다. next = 6 - start - end # 만약 원판이 1개만 남았다면 K번 기둥으로 옮긴 후 종료 if n == 1: print(n, end) return # N-1 개의 원판을 1번, K번이 아닌 기둥으로 이동 hanoi(n - 1, start, next) # N번 원판을 K번 기둥으로 이동 print(n, end) # N-1 개의 원판을 K번 기둥으로 이동 hanoi(n - 1, next, end)hanoi(n, 1, k)","link":"/2020/09/01/bitaalgo-018/"},{"title":"[비타알고] 살아있는 폭탄(★3)","text":"*이 글은 구름edu의 위클리 비타알고 시즌2 코딩테스트 대비 입문편을 기반으로 쓰여진 글입니다.출처 : 위클리 비타알고 시즌2 코딩테스트 대비 입문편 문제 소스코드12345678910111213141516171819202122232425262728293031323334353637383940414243from collections import dequen = int(input())board = []for i in range(n): board.append(list(map(int, input().split())))# 폭탄이 터지는 범위dx = [0, 0, -1, 1]dy = [-1, 1, 0, 0]# BFSdef bomb(board, dx, dy, n): q = deque() # 폭탄이 위치한 좌표를 queue에 저장 for i in range(n): for j in range(n): if board[i][j] == 1: q.append((i, j)) ans = 0 while q: # queue에 저장한 좌표를 꺼냄 x, y = q.popleft() ans = max(ans, board[x][y]) # 상하좌우 4방향으로 폭탄이 이동하는 지점 for i in range(4): # 현재 좌표에서 상하좌우 이동할 좌표를 지정 nx = x + dx[i] ny = y + dy[i] # 이동하는 지점이 격자판을 벗어나지 않으면서 해당 지점이 0이 아닐 경우 if 0 &lt;= nx and nx &lt; n and 0 &lt;= ny and ny &lt; n and board[nx][ny] == 0: # 이동한 지점에 이전 지점 + 1 한 값을 저장 board[nx][ny] = board[x][y] + 1 # queue에 해당 좌표를 추가 q.append((nx, ny)) return ansprint(bomb(board, dx, dy, n))","link":"/2020/09/02/bitaalgo-020/"},{"title":"[부스트코스] CSS 기본 Style 변경하기","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/lecture/16675/ CSS 기본 스타일 변경하기font 색상 변경 color : red; color : rgba(255, 0, 0, 0.5); color : #ff0000; font 사이즈 변경 font-size : 16px; font-size : 1em; 배경색 background-color : #ff0; background-image, position, repeat 등의 속성이 있다. background : #0000ff url(“…/gif”) no-repeat center top; // 한줄로 정의도 가능 글씨체/글꼴 font-family : “Gulim”; font-family : monospace; 웹 폰트브라우저에서 기본으로 지원하지 않는 폰트를 웹으로부터 다운로드 받아 사용할 수 있다.다양한 종류의 웹폰트를 사용할 수 있지만 다운로드를 받아야하는 단점때문에 다운로드 시간이 길어지게 되면 화면이 노출되는 시간이 느려져 오히려 사용자에게 불편함을 느끼게 할 수 있다.","link":"/2020/07/23/boostcourse-1-10/"},{"title":"[부스트코스] CSS layout","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/lecture/16677/ CSS layout엘리먼트를 화면에 배치하는 것을 layout 작업이라고도 하고, Rendering 과정이라고도 한다.기본 엘리먼트는 위에서 아래로 배치되는 것이 기본이지만, 다양한 방식으로 배치할 수 있도록 해주는 다양한 속성들이 있다.아래의 속성들은 주로 사용되는 배치 속성들이다. 123display(block, inline, inline-block)position(static, absolute, relative, fixed)float(left, right) display:blockdisplay속성이 block이거나 inline-block인 경우 그 엘리먼트는 벽돌을 쌓듯이 블록을 가지고 쌓인다. 123&lt;div&gt;block1&lt;/div&gt;&lt;div&gt;blcok2&lt;/div&gt;&lt;div&gt;block3&lt;/div&gt; 123456div { width: 100px; height: 100px; border: 1px solid gray; display: block;} display:inlinedisplay속성이 inline인 경우 우측으로, 그리고 아래쪽으로 빈자리를 차지하며 흐른다.높이와 넓이를 지정해도 반영이 되지 않는다. 123&lt;div&gt;block1&lt;/div&gt;&lt;div&gt;blcok2&lt;/div&gt;&lt;div&gt;block3&lt;/div&gt; 123456div { width: 100px; height: 100px; border: 1px solid gray; display: inline;} position:static, relative, absolute, fixedposition 속성을 사용하면 상대적/절대적으로 어떤 위치에 엘리먼트를 배치하는 것이 수월하다. 123456&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;static&quot;&gt;static(default)&lt;/div&gt; &lt;div class=&quot;relative&quot;&gt;relative(left:10px)&lt;/div&gt; &lt;div class=&quot;absolute&quot;&gt;absolute(left:130px;top:30px)&lt;/div&gt; &lt;div class=&quot;fixed&quot;&gt;fixed(top:250px)&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829.wrap { position: relative;}.wrap &gt; div { width: 150px; height: 100px; border: 1px solid gray; font-size: 0.7em; text-align: center; line-height: 100px;}.relative { position: relative; left: 10px; top: 10px;}.absolute { position: absolute; left: 130px; top: 30px;}.fixed { position: fixed; top: 250px;} position 속성으로 특별한 배치를 할 수 있다.position 속성은 기본 static이다.그냥 순서대로 배치된다. absolute는 기준점에 따라서 특별한 위치에 위치한다.top / left / right/ bottom으로 설정한다.기준점을 상위엘리먼트로 단계적으로 찾아가는데 static이 아닌 position 속성이 기준이다.만약 static이 아닌 상위 엘리먼트가 없을 경우 body를 기준으로 삼는다. relative는 원래 자신이 위치해야 할 곳을 기준으로 이동한다.top / left / right/ bottom으로 설정한다.위의 경우 원래 relative클래스를 가진 div는 static클래스를 가진 div 바로 아래에 붙어서 위치해야 하지만 relative속성에 의해 위에서 10px, 왼쪽에서 10px 떨어진 곳에 위치하게 되었다. fixed는 viewport(전체화면) 좌측, 맨 위를 기준으로 동작한다.스크롤등을 통해 화면을 이동해도 고정된 위치에 계속 나타나게 된다. margin엘리먼트들은 margin의 값을 통해 배치될 수 있다.margin은 위 / 아래 / 좌 / 우 엘리먼트와 본인 간의 간격이다. float원래 flow에서 벗어날 수 있고 둥둥 떠다닐 수 있는 속성일반적인 배치에 따라서 배치된 상태에서 float는 벗어난 형태로 특별히 배치된다. box-model블록 엘리먼트의 경우 box의 크기와 간격에 관한 속성으로 추가 결정한다.margin, padding, border, outline으로 생성되는 것box-shadow 속성도 box-model에 포함지어 설명할 수 있다.","link":"/2020/07/23/boostcourse-1-11/"},{"title":"[부스트코스] Servlet 생명 주기","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/lecture/16688/ Servlet 생명 주기 WAS는 서블릿 요청을 받으면 해당 서블릿이 메모리에 있는지 확인한다. if(메모리에 없음) {해당 서블릿 클래스를 메모리에 올림init() 메소드를 실행}service() 메소드를 실행 WAS가 종료되거나, 웹 어플리케이션이 새롭게 갱신될 경우 destroy() 메소드가 실행된다.","link":"/2020/07/24/boostcourse-1-13/"},{"title":"[부스트코스] Servlet","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/lecture/16686/ 자바 웹 어플리케이션(Java Web Application) WAS에 설치(deploy)되어 동작하는 어플리케이션 자바 웹 어플리케이션에는 HTML, CSS, 이미지, 자바로 작성된 클래스(Servlet도 포함, package, 인터페이스 등), 각종 설정 파일 등이 포함된다. 서블릿(Servlet)이란? 자바 웹 어플리케이션의 구성요소 중 동적인 처리를 하는 프로그램의 역할 WAS에 동작하는 JAVA 클래스 서블릿은 HttpServlet을 상속받아야 한다. 서블릿과 JSP로부터 최상의 결과를 얻으려면, 웹 페이지를 개발할 때 이 두 가지(JSP, 서블릿)를 조화롭게 사용해야 한다. ex)JSP : 웹 페이지를 구성하는 화면Servlet : 복잡한 프로그래밍","link":"/2020/07/24/boostcourse-1-12/"},{"title":"[부스트코스] Request, Response 객체 이해하기","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/lecture/16689/ 요청과 응답WAS는 웹 브라우저로부터 Servlet요청을 받으면, 요청할 때 가지고 있는 정보를 HttpServletRequest객체를 생성하여 저장 웹 브라우저에게 응답을 보낼 때 사용하기 위하여 HttpServletReponse객체를 생성 생성된 HttpServletRequest, HttpServletReponse 객체를 서블릿에게 전달 HttpServletRequest http프로토콜의 request정보를 서블릿에게 전달하기 위한 목적으로 사용 헤더정보, 파라미터, 쿠키, URI, URL 등의 정보를 읽어 들이는 메소드를 가지고 있다. Body의 Stream을 읽어 들이는 메소드를 가지고 있다. HttpServletReponse WAS는 어떤 클라이언트가 요청을 보냈는지 알고 있고, 해당 클아이언트에게 응답을 보내기 위한 HttpServletReponse객체를 생성하여 서블릿에게 전달한다. 서블릿은 해당 객체를 이용하여 content type, 응답코드, 응답 메시지 등을 전송한다.","link":"/2020/07/24/boostcourse-1-14/"},{"title":"[부스트코스] 웹 서버","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/lecture/16665/ 웹 서버란? 웹 서버는 소프트웨어를 보통 말하지만, 웹 서버 소프트웨어가 동작하는 컴퓨터를 말한다. 웹 서버의 가장 중요한 기능은 클라이언트가 요청하는 HTML문서나 각종 리소스를 전달하는 것이다. 웹 브라우저나 웹 크롤러가 요청하는 리소스는 컴퓨터에 저장된 정적(static)인 데이터이거나 동적인 결과가 될 수 있다. 웹 서버 소프트웨어의 종류 가장 많이 사용하는 웹서버: Apache, Nginx, Microsoft IIS Apache 웹 서버는 Apache Software Foundation에서 개발한 웹 서버로 오픈소스 소프트웨어이며, 대부분의 운영체제에서 설치 및 사용이 가능하다. Nginx는 차세대 웹 서버로 불리며 더 적은 자원으로 더 빠르게 데이터를 서비스하는 것을 목적으로 만들어진 서버이며 Apache 웹 서버와 마찬가지로 오픈소스 소프트웨어이다. 추가사항웹 크롤링 네이버, 구글과 같은 검색을 하게 해주는 포털사이트들은 검색어를 입력하면 검색어가 포함된 웹 페이지 목록을 보여준다.이는 웹 크롤링을 통해 미리 사전에 검색어와 관련된 사이트들을 DB화 하고 이를 통해 클라이언트가 요청한 검색어에 걸맞는 데이터를 웹서버가 전달해준다.","link":"/2020/07/22/boostcourse-1-4/"},{"title":"[부스트코스] 웹 Front-End와 웹 Back-End","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/lecture/16662/ 웹 프론트엔드? 웹에서 사용자에게 보여지는 것들, 사용자의 요청에 의해서 반응하여 동작하는 것을 말한다. 웹 프론트엔드의 역할 웹콘텐츠를 잘 보여주기 위해 구조를 만든다. - HTML 적절한 배치와 일관된 디자인 등을 제공한다. - CSS 사용자 요청을 잘 반영한다. - Javascript 웹 백엔드? backend는 정보를 처리하고 저장하며, 요청에 따라 정보를 내려주는 역할을 한다. ex) 쇼핑몰 웹사이트에서의 백엔드의 역할 상품 정보를 가지고 있다. 주문을 받아서 저장한다. 사용자가 관심있어 하는 상품을 골라준다. 백엔드 개발자가 알아야 할 것들 프로그래밍 언어(JAVA, Python, PHP, Javascript 등) 웹의 동작 원리 알고리즘(algorithm), 자료구조, 운영체제, 네트워크 등의 CS 지식 프레임워크에 대한 이해(ex: Spring) DBMS에 대한 이해와 사용방법(ex: MySQL, Oracle 등)","link":"/2020/07/20/boostcourse-1-2/"},{"title":"[부스트코스] WAS","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/lecture/16666/ 클라이언트/서버 구조클라이언트(Client)는 서비스(Service)를 제공하는 서버(Server)에게 정보를 요청하여 응답받은 결과를 사용한다. DBMS(Data Base Management Service)다수의 사용자가 데이터베이스 내의 데이터에 접근할 수 있도록 해주는 소프트웨어 미들웨어(MiddleWare)클라이언트 관리의 부담을 줄이기위해 또 다른 서버를 둔 방식으로 클라이언트와 DBMS 사이에서 필요한 대부분의 로직을 수행한다.이를 통해 클라이언트는 입력과 출력만 담당하게 한다. WAS(Web Application Server)WAS는 일종의 미들웨어로 웹 클라이언트의 요청 중 웹 애플리케이션이 동작하도록 지원하는 목적을 가진다. 웹서버 vs WAS WAS도 보통 자체적으로 웹 서버 기능을 내장하고 있다. 현재는 WAS가 가지고 있는 웹 서버도 정적인 콘텐츠를 처리하는데 있어서 성능상 큰 차이가 없다. 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성을 위해 웹 서버와 WAS를 대체로 분리한다.","link":"/2020/07/22/boostcourse-1-5/"},{"title":"[부스트코스] browser의 동작","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/lecture/16663/ browser의 동작 HTML을 해석해서 DOM Tree를 생성, CSS를 해석해서 CSS Tree(CSS Object Model)을 만든다. DOM Tree와 CSS Tree는 Render Tree로 다시 조합된다. Render Tree정보를 통해서 화면에 어떻게 나타낼지 Painting과정을 거치게 된다. [참고 1]: How Browsers Work: Behind the scenes of modern web browsershttps://www.html5rocks.com [참고 2]: 브라우저는 어떻게 동작하는가?(위 [참고 1]의 번역본)http://d2.naver.com","link":"/2020/07/21/boostcourse-1-3/"},{"title":"[부스트코스] HTML","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/lecture/16669/ HTML tag의 종류 링크 이미지 목록 제목 ul/li 태그, img 태그, heading 태그, p 태그 등이 자주 사용된다.필요한 태그를 찾아서 적절한 의미에 맞는 태그를 사용하는 것이 중요하다. HTML Layout 태그레이아웃을 구성하는 태그도 의미에 맞춰서 사용된다. header section nav footer aside HTML 구조 설계 구조화 설계는 문서를 쓰는 것과 비슷하다. 영역을 나눠서 상단/본문/네비게이션과 같이 큰 부분부터 분리해서 설계한다. 큰 부분부터 시작해서 작은 부분으로 점점 좁혀가면서 HTML 문서를 작성한다. class와 id 속성ID 고유한 속성으로 한 HTML 문서에 하나만 사용가능하다. 고유한 ID 값이 있으면 하나하나에 특별한 제어를 할 수 있으며 검색에도 용이하다. Class 하나의 HTML 문서 안에 중복해서 사용가능하다. 하나의 태그에 여러 개의 다른 class 이름을 공백을 기준으로 나열할 수 있다. 홈페이지 전체적인 스타일을 일관성 있게 지정하기 위해 class 사용은 필수적이다. 회사에서의 개발은 보통 협업으로 이루어지기 때문에 사전에 개발단계에서 코드 컨벤션을 만들어 규칙을 정하기도 한다.","link":"/2020/07/22/boostcourse-1-6/"},{"title":"[부스트코스] CSS 상속과 우선순위 결정","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/lecture/16674/ 상속과 우선순위 결정보통의 경우 inline &gt; internal &gt; external로 우선순위가 결정된다.하지만, internal과 external은 같은 우선순위를 가진다. 1234&lt;head&gt;&lt;style&gt;div { color:red;}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css.css&quot;&gt;&lt;/head&gt; 만약 css.css에서 div color 값을 blue로 주었다면, 뒤에 선언된 external방식의 css 내용이 반영된다. 즉, blue로 색깔이 나타난다. 선언방식에 따른 차이같은 선택자(selector)라면 나중에 선언한 것이 반영된다.선택자의 표현이 구체적인 것이 있다면 먼저 적용된다. body &gt; span (O) span (X) ID &gt; CLASS &gt; ELEMENT 순으로 반영123&lt;div id=&quot;a&quot; class=&quot;b&quot;&gt; text.....&lt;/div&gt; 1234567891011#a { color : red;}.b { color : blue;}div { color : green;} 위 코드에서는 id인 a의 색상이 적용되게 되어 red가 적용이 된다.CSS 적용은 id &gt; class &gt; element 순으로 우선순위를 가지며 이러한 성질을 캐스캐이딩(cascading)이라고 한다.","link":"/2020/07/22/boostcourse-1-8/"},{"title":"[부스트코스] CSS Selector","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/lecture/16676/ CSS Selectorelement에 style 지정을 위한 3가지 기본 선택자 tag로 지정 12345&lt;style&gt; span { color: red; }&lt;/style&gt; id로 지정 123456789&lt;style&gt; #spantag { color: red; }&lt;/style&gt;&lt;body&gt; &lt;span id=&quot;spantag&quot;&gt; HELLO World! &lt;/span&gt;&lt;/body&gt; class로 지정 123456789&lt;style&gt; .spanClass { color: red; }&lt;/style&gt;&lt;body&gt; &lt;span class=&quot;spanClass&quot;&gt; HELLO World! &lt;/span&gt;&lt;/body&gt; CSS Selector의 다양한 활용 그룹 선택(여러 개 셀렉터에 같은 style을 적용할 때) 1234567891011121314h1,span,div { color: red;}h1,span,div#id { color: red;}h1.span,div.classname { color: red;} 자식 선택 (&gt;) : 자식은 바로 하위엘리먼트를 가리킨다. 아래의 경우 span tag 2만 red 색상이 적용된다. 123456&lt;div id=&quot;jisu&quot;&gt; &lt;div&gt; &lt;span&gt; span tag &lt;/span&gt; &lt;/div&gt; &lt;span&gt; span tag 2 &lt;/span&gt;&lt;/div&gt; 123#jisu &gt; span { color: red;} n번째 자식요소 선택(nth-child) 첫번째 단락입니다. 에 red 색상이 적용 1234567&lt;div id=&quot;jisu&quot;&gt; &lt;h2&gt;단락 선택&lt;/h2&gt; &lt;p&gt;첫번째 단락입니다&lt;/p&gt; &lt;p&gt;두번째 단락입니다&lt;/p&gt; &lt;p&gt;세번째 단락입니다&lt;/p&gt; &lt;p&gt;네번째 단락입니다&lt;/p&gt;&lt;/div&gt; 123#jisu &gt; p:nth-child(2) { color: red;} nth-child vs nth-of-type nth-child(n) : 태그 상관 없이 n번째를 찾아서 적용(자식 태그) nth-of-type(n) : 같은 태그의 n번째를 찾아서 적용","link":"/2020/07/23/boostcourse-1-9/"},{"title":"[부스트코스] CSS 선언 방법","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/lecture/16673/ CSS의 구성123span { color : red;} span : selector(선택자) color : property red : value style을 HTML 페이지에 적용하는 3가지 방법1. inlineHTML 태그 안에다가 적용한다.다른 CSS파일에 적용한 것보다 가장 먼저 적용된다. 1&lt;p style=&quot;border:1px solid gray;color:red;font-size:2em;&quot;&gt; 2. internalstyle 태그로 지정한다.구조와 스타일이 섞이게 되므로 유지보수가 어렵다.별도의 CSS 파일을 관리하지 않아도 되며 서버에 CSS 파일을 부르기 위해 별도의 브라우저가 요청을 보낼 필요가 없다. 12345678910111213&lt;head&gt;&lt;style&gt;p { font-size : 2em; border : 1px solid gray; color : red;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;...&lt;/div&gt;&lt;/body&gt; 3. external외부파일(.css)로 지정하는 방식주로 이 방법을 많이 사용한다.css 코드를 구현하고, style.css와 같은 별도 파일로 만든다.이후 link태그로 추가하면 된다. 1234567891011121314151617&lt;html&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4. 우선순위inline은 별도의 우선순위를 갖지만, internal과 external은 우선순위가 동등하다. 따라서 겹치는 선언이 있을 경우 나중에 선언된 속성이 반영된다.","link":"/2020/07/22/boostcourse-1-7/"},{"title":"[부스트코스] 자바스크립트 변수-연산자-타입","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/lecture/16693/ 자바스크립트의 버전 자바스크립트 버전은 ECMAScript(줄여서 ES)의 버전에 따라서 결정되고, 이를 자바스크립트 실행 엔진이 반영한다. 2018년을 중심으로 ES6를 지원하는 브라우저가 많아서 몇 년간 ES6 문법이 표준으로 쓰이고 있다. ES6은 ES5문법을 포함하고 있어 하위호환성 문제가 없다. feature별로 지원하지 않는 브라우저가 있을 수 있어 주의해야 한다. 변수변수는 var, let, const로 선언할 수 있다.어떤 것을 사용하는 가에 의해서 scope, 즉 변수의 유효범위가 달라진다.ES6이전까지는 var를 사용해서 변수를 선언할 수 있다. 1234567var a = 2;var a = &quot;aaa&quot;;var a = &quot;aaa&quot;;var a = true;var a = [];var a = {};var a = undefined; 연산자연산자 우선순위를 표현하기 위해서는 ()를 사용하면 된다.수학 연산자는 +, -, \\*, /, % 등이있다.논리연산자, 관계연산자, 삼항연산자가 있다. 변수에 논리연산자를 활용할 수 있다. 12345678const name = &quot;crong&quot;;const result = name || &quot;codesquad&quot;;console.log(result);// 결과 : crongvar name = &quot;&quot;;var result = name || &quot;codesquad&quot;;console.log(result);// 결과 : codesquad 연산자 - 삼항연산자간단한 비교와 값 할당은 삼항연산자를 사용할 수 있다. A ? B : C 에서 A가 참이면 B를 A가 거짓이면 C를 선택한다. 1234const data = 11;const result = data &gt; 10 ? &quot;ok&quot; : &quot;fail&quot;;console.log(result);// 결과 : ok 연산자 - 비교연산자자바스크립트에서는 ==을 사용할 때 암묵적으로 타입을 바꿔서 비교하려는 성질이 있다.그래서 ===를 사용해야하는데 ===는 타입이 정확한지까지 비교하기 때문이다. 비교할때는 == 보다는 ===를 사용하자 123456789100 == false;// 결과 : false&quot;&quot; == false;// 결과 : truenull == false;// 결과 : false0 == &quot;0&quot;;// 결과 : truenull == undefined;// 결과 : true 자바스크립트의 Type자바스크립트 타입에는 다양한 것이 존재한다. 1&gt; undefined, null, boolean, number, string, object, function, array, Date, RegExp 타입은 선언할 때가 아니고, 실행타임에 결정된다. 함수안에서의 파라미터나 변수는 실행될 때 그 타입이 결정된다. 타입을 체크하는 또렷한 방법은 없다. 보통 toString.call 함수를 이용해서 결과를 매칭하곤 하는데, 문자, 숫자와 같은 스크립트 기본 타입은 typeof 키워드를 사용해서 체크할 수 있다. 배열은 타입을 체크하는 isArray 함수가 있다. 브라우저마다 지원범위를 살펴보고 사용해야 한다.","link":"/2020/08/15/boostcourse-2-1/"},{"title":"[부스트코스] 프로젝트 A-1 리뷰 받은 내용에 대한 간단 요약","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/joinLectures/12944 자바 8 날짜 API -&gt; LocalDateTime API자바 7까지는 날짜를 표기할 때 Calendar, Date, SimpleDateFormat들을 사용했지만 문제가 많아서 자바 8이후 부터는 LocalDateTime API로 대체됨. 참고Java8의 날짜 API 사용하기 &gt; 자바 기본 날짜클래스(Calendar, Date)의 문제점 어노테이션 @Override 사용 생활화상속 받은쪽에서 재정의한 메소드의 경우 @Override 위에 붙여주기이유 : 다른 사람이 봤을때 변경된 사실을 명시적으로 알 수 있게 되어 컴파일시 이 부분에 대한 오류 인지가 가능 자바 코드 작성법자바에서 클래스, 메소드, 변수는 카멜 케이스로 작성 html 코드 작성법html에서 class명명은 스네이크 케이스, 케밥 케이스를 주로 사용id 명명에는 카멜 케이스를 주로 사용 참고코드 표기법 html태그의 lang 속성웹 접근성을 고려한다면 lang 속성의 값을 명확하게 지정하여야 한다.lang 속성으로 지정한 값은 스크린 리더의 기본 문자셋으로 지정되기 때문이다. 예시) 1&lt;html lang=&quot;ko&quot;&gt;&lt;/html&gt; time 태그날짜를 나타낼때에는 의미론(Semantic)적으로 time 태그를 사용하는 것이 좋다.","link":"/2020/07/29/boostcourse-PJT-A-1/"},{"title":"[부스트코스] 자바스크립트 비교-반복-문자열","text":"*이 글은 부스트코스(boostcourse)의 웹 프로그래밍 강의를 듣고 작성되었습니다.https://www.edwith.org/boostcourse-web/lecture/16694/ 비교문if, else if, else가 있다. 분기if문 외에도 switch문을 통해 로직을 분기할 수 있다. 반복for 문이나 while문이 있다. 12345678var arr = [1,2,3];var len = arr.length;sum = 0for(var i=0; i &lt; len; i++){ sum += arr[i]}console.log(sum)// 결과 : 6 문자열 처리123456&quot;ab:cd&quot;.split(&quot;:&quot;); // 결과 : [&quot;ab&quot;, &quot;cd&quot;]&quot;ab:cd&quot;.replace(&quot;:&quot;,&quot;$&quot;) // 결과 : &quot;ab$cd&quot;&quot; abcde &quot;.trim();// 결과 : &quot;abcde&quot; .split(&quot;A&quot;) : A값을 기준으로 나눈 문자를 배열로 변환 .replace(&quot;A&quot;,&quot;B&quot;) : A값을 B값으로 바꿈 .trim() : 문자열 안의 공백을 모두 없애준다.","link":"/2020/08/16/boostcourse-2-2/"},{"title":"마켓컬리 클론 프로젝트 후기","text":"1차 프로젝트로 마켓컬리 사이트를 클론 코딩하였다. 🙌예전부터 마켓컬리와 같은 커머스 사이트를 클론 코딩해보고 싶다고 생각했었는데 이번에 할 수 있게 되어서 너무 좋았다. 😀 마켓컬리 클론 코딩 GitHub 주소(FrontEnd)마켓컬리 클론 코딩 GitHub 주소(BackEnd) [프로젝트 시연 영상] 🥦 마켓컬리(Market Kurly) 클론 마켓컬리(Market Kurly)는 신선 식품 전문 온라인 쇼핑몰이다. 📅 프로젝트 기간2020년 10월 19일 ~ 2020년 10월 30일 [약 2주간 진행] 🥦 Team Bro Kurly &amp; 🧑‍🤝‍🧑 프로젝트 참가자 (Front + Back)팀 이름은 Bro Kurly로 남자들만 모여서 프로젝트를 진행했기에 Bro라는 이름으로 지었다. (팀 이름을 생각해낸 팀원분께 감사를 !) Front-End 4명 Back-End 2명으로 진행하였고 나는 BackEnd 겸 PM을 담당했다. 🛠 SkillsFrontEnd HTML / CSS JavaScript React(CRA 세팅) React(Router DOM) Sass Redux(ReactRedux, Persist, logger) SweatAlert IMport BackEnd Python Django MySQL Bcrypt PyJWT CORS Header RESTful API Twilio (문자 인증 SMS 서비스) 🔨 Tools Git &amp; GitHub Slack Trello (일정 관리 및 작업 현황 확인) Postman (API 관리) Aquery Tool (데이터베이스 모델링) AWS (EC2 서버에 RDS 인스턴스를 연결하여 배포) 📑 기능 구현 사항 메인 페이지 Main Page layout Navigation Bar (BackEnd 카테고리 API 연결) 회원가입 &amp; 로그인 페이지 bcrypt를 사용한 암호화 데코레이터를 이용한 토큰 관리 아이디 &amp; 비밀번호 Validation 장바구니 Shipping Basket Page layout 상품 추가 및 삭제 기능 할인 금액 계산 마이페이지 My Page layout 결제시 적립금 추가 기능 주문서 Order layout Payment 상품 리스트 페이지 Product List filtering Product List Page layout 상품 디테일 페이지 Product Detail layout Related Product Product Review 신상품 &amp; 베스트 페이지 New Product List &amp; Best Product List Page layout New Product List &amp; Best Product filtering 알뜰 쇼핑 페이지 Sales Product List Page layout Sales Product List filtering 할인된 상품만 모아주는 페이지 🔥 프로젝트 진행 과정일정이나 작업 현황 등은 모두 Trello를 활용하여 관리하였다.아래 사진은 프로젝트가 끝난 후의 모습이다. 각 파트별 의미는 다음과 같다. Meetup log - 회의 내용 정리 Backlog Issue - 작업해야할 목록들 Design Issue - 필요한 이미지들을 저장 To Do(This week) - 이번 주까지 해야되는 작업 Doing - 현재 진행 중인 작업 Front-Backend - Front와 Back간의 테스트가 진행 중인 부분 Done(Merge) - 테스트가 끝난 후 작업이 완료된 사항 모델링Aquery Tool을 활용하여 모델링을 진행하였다. API 개발 내가 담당한 부분은 상품에 대한 것들이었다. 카테고리 뷰 API 메인 section 페이지 뷰 API 카테고리 별 상품 리스트 필터링 및 검색 API 상품 디테일 뷰 API 메인 페이지의 MD의 추천 API 특정 상품에 대해 연관된 상품을 가져오는 API 한 달 이내 등록된 상품만 보여주는 신상품 뷰 API 기준에 따라 조회수가 높은 상품만 보여주는 베스트 뷰 API 할인된 상품만 보여주는 알뜰 상품 뷰 API 👀 기억에 남는 코드 카테고리 별 상품의 리스트를 필터링 할 수도 있고 검색도 가능한 API 이다.처음에 API를 만들 때는 두 개의 기능을 분리해서 만들었는데 두 API에는 공통점이 있었다.filter 기능을 사용한다는 것이었는데, Django의 filter 기능을 잘 쓰면 어떻게든 합칠 수 있을 것 같았다. 그래서 한참을 고민한 끝에 하나의 API로 두 가지 기능으로 동작이 가능하게 만들 수 있었다! 👏(하루종일 고민했던 것 같다. 😓) 어떻게 구현했나?filters 라는 빈 딕셔너리를 만들어서 상황에 맞게 filter를 추가하여 결과를 리턴해주는 구조이다.처음에는 if else 지옥😱에 빠져서 이렇게 하는게 최선인지 의심스러웠다.filter하고 싶은 것들을 딕셔너리에 담는다는 것은 생각지도 못했는데 멘토님들이 이런 방법도 있다고 알려주셨다. 성능 개선위의 코드를 보면 select_related를 사용한 것이 보일 것이다. 그 외에도 prefetch_related도 사용하였다. 이를 통해 DB Hit를 최소화하기 위해 노력하였다. 백엔드 개발자라면 극한의 성능과 효율을 추구해야 된다고 생각하기에..! 🔥또한 List Comprehension을 적극적으로 활용하여 일반적인 for문 보다 연산이 빠르게 되도록 노력했다. 클린코드 &amp; 코딩 컨벤션불필요한 코드를 최대한 줄이고자 노력하였다. 또한 사전에 다른 백엔드 분과 정한 컨벤션을 지키고자 노력했다. 아직 완벽하다는 생각은 들지 않는다. 😞 👋 프로젝트 후기PM이라는 자리PM이라는 자리를 처음 맡아보았지만 사실 내가 직접 PM으로서 어떤 일을 했다고는 볼 수 없다. 다른 팀원 분들이 정말 여러 방면으로 많은 도움을 주셨고 덕분에 편하게 프로젝트를 진행할 수 있었다. PM이라는 직책은 아마 앞으로 경험해보기 힘든 직책일 것이다. PM으로서 어떤식으로 생각해야될지, 프로젝트 구성원들에게 프로젝트의 방향성에 대해 어떻게 설명하고 이끌어나갈 수 있을지 고민해볼 수 있었던 것 같다. 배운 점API를 만드는 것보다도 모델링하는 과정이 더 어렵고 힘들었던 것 같다. 더이상 모델링할 게 없다고 생각이 들어서 바로 API를 개발하는 것에 집중하였지만 개발하는 과정에서 모델링이 잘못된 부분이 중간중간 나왔었다. 오히려 이런 부분 때문에 개발 기간이 더 길어졌었던 것 같았다. 2주라는 짧은 기간 안에 개발을 끝내야 하기에 빨리 진행해야 한다는 강박 관념이 생겨서 모델링에 소홀했던 것이 아닌가 생각이 든다. 실제 API를 모두 개발하는 데에는 시간이 많이 걸리지 않았고 오히려 시간이 남았었다.성급하게 하려고 하지말고 천천히 어떻게 구현할지, 어떤 것이 효율적일지 항상 고민하는 습관을 들여야겠다고 생각했다. (물론 실제로 마감기한이 닥치면 또 이렇게 될 것같긴 하다. 😏) 소통의 중요성개발자라고 해서 개발만 한다는 것은 정말 바보같은 생각이다. 예전부터 알고 있던 말이긴 했지만 직접 프로젝트를 하니 더욱 와닿는 말이었다. 사소한 것도 서로 공유하며 소통하는 커뮤니케이션 능력이 중요하다는 걸 깨달았다. 프론트가 보는 관점과 백엔드가 보는 관점이 달라서 사전에 조율하고 맞춰나가야 하는 것들이 많기 때문이다. Git개인적으로 토이 프로젝트를 하는 것만으로는 Git에 대한 경험을 풍부하게 해볼 수 없어서 Git 경험을 쌓고 싶다는 생각에 목이 말랐었는데 이번 기회에 제대로 써볼 수 있어서 좋았다. conflict는 여전히 무섭지만 말이다. 특히 기억나는 점은 기능 별로 branch를 나누어서 개발을 진행했는데, 체계적으로 역할 분담을 하여 개발하는 것 같아서 좋았다.","link":"/2020/11/01/brokurly-review/"},{"title":"[JavaScript] Callback 함수","text":"Callback function이란? 함수로써 다른 함수에 인수로 전달되어 외부 함수 내에서 호출되는 것 여기서 외부 함수란 Callback function 밖의 함수들을 말한다.다음 예시를 보자. 123456789101112function callBack(num) { console.log(&quot;콜백 함수 입니다.&quot;); console.log(num ** 2)}function printNumber(num, callBack) { console.log(&quot;숫자를 출력합니다.&quot;, num); callBack(num); console.log(num);}printNumber(10, callBack); [출력결과] printNumber 함수를 호출하는데, 이 떄 callBack 함수를 인자로 주었다.printNumber 함수가 실행되고 그 안에서 callBack 함수를 호출하여 callBack 함수를 실행한다.","link":"/2020/10/05/callbackfunction-js/"},{"title":"왕실의 나이트","text":"이 글은 이것이 취업을 위한 코딩테스트다 책을 기반으로 쓰여진 글입니다.출처 : 이것이 취업을 위한 코딩테스트다 문제행복왕국의 왕실정원은 체스판과 같은 8 * 8좌표 평면이다.왕실 정원의 특정한 한 칸에 나이트가 서있다. 나이트는 매우 충성스러운 신하로서 매일무술을 연마한다.나이트는 말을 타고 있기 때문에 이동을 할때는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다. 나이트는 특정한 위취에서 다음과 같은 2가지 경우로 이동할 수 있다. 수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기 수직으로 두칸 이동한 뒤에 수평으로 한 칸 이동하기 이처럼 8 * 8 좌표 평면상에서 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성하시오.이떄 왕실의 정원에서 행 위치를 표현할 떄는 1부터 8로 표현하며, 열 위치를 표현할 때는 a부터 h까지 로 표현한다. 예를 들어 만약 나이트가 a1에 있을 때 이동할 수 있는 경우의 수는 다음 2가지이다.a1의 위치는 좌표 평면에서 구석의 위치에 해당하며 나이트는 정원의 밖으로는 나갈 수 없기 때문이다. 오른쪽 두 칸 이동 후 아래로 한 칸 이동하기(c2) 아래로 두 칸 이동 후 오른쪽으로 한 칸 이동하기(b3) 또 다른 예로 나이트가 c2에 위치해 있다면 나이트가 이동할 수 있는 경우의 수는 6가지이다. ▣ 입력조건첫째 줄에 8 * 8 좌표 평면상에서 현재 나이트가 위치한 곳의 좌표를 나타내는 두 문자로 구성된 문자 열이 입력된다. 입력문자는 a1처럼 열과 행으로 이뤄진다. ▣ 출력조건첫째 줄에 나이트가 이동할 수 있는 경우의 수를 출력하시오. 풀이1234567891011121314location = input()a = ord(location[0])b = int(location[1])# 나이트가 이동할 수 있는 모든 경우의 수go = [(2,1),(2,-1), (1, -2), (-1, -2), (-2,-1), (-2, 1), (-1, 2), (1,2)]# 8방향에 대하여 각 위치로 이동이 가능한지 확인cnt = 0for x, y in go: nx, ny = a + x, b + y if ord(&quot;a&quot;) &lt;= nx &lt;= ord(&quot;h&quot;) and 1 &lt;= ny &lt;= 8: cnt += 1print(cnt)","link":"/2020/09/17/coding-test-001/"},{"title":"CircleCI로 S3 배포 자동화하기","text":"CircleCI란? CircleCI에서 CI는 지속적인 통합(continuous integration)의 약자인데, CI를 통해 우리는 생산성, 효율성, 신뢰성을가진 코드를 가질 수 있다. CircleCI는 이를 자동화해주는 도구로 test, build,deploy를 자동화할 수 있게 해준다. CircleCI 장점 모든 작업에 SSH 연결을 통해 빌드 문제를 디버깅 할 수 있다. .circleci/config.yml 파일을 사용해서 작업을 병렬로 처리할 수 있다. 두 개의 간단한 키로 캐싱을 구성하여 워크플로에서 이전 작업의 데이터를 재사용 할 수 있다. 고유한 플랫폼 지원을 위해 자체 호스팅 러너를 구성할 수 있다. 재사용 가능한 구성 패키지인 orbs를 사용하여, 타사 도구와 쉽게 통합이 가능하며 반복되는 프로세스를 자동화 할 수 있다. 다양한 언어로 사전 빌드된 Docker 이미지 사용 자체 test insight를 통해 테스트 성능 분석 및 최적화 가능 CircleCI를 이용한 모든 작업에 대한 모니터링 제공 CircleCI 시작 Github, Bitbucket 등으로 로그인하여 자신의 프로젝트들의 CI/CD를 쉽고 빠르게 빌딩할 수 있다.여기서는 Github으로 연결했다. CircleCI 구성하기 Projects에 들어가면 연결한 Github에 있는 레포지토리들이 보이게 된다. Set Up Project버튼을 누르면 CircleCI 설정 파일인 .circleci/config.yml 파일을 설정할 수 있다.2가지 방법을 제안하는데, 스타터를 이용해 직접 위 파일을 작성하는 방법과 미리 설정된 파일을 사용하는 방법이다. S3에 배포 자동화 하기기본 구성 version &amp; orbs 1234version: 2.1 orbs: aws-cli: circleci/aws-cli@2.0.6 aws-s3: circleci/aws-s3@3.0 version: CircleCI의 버전 설정 orbs: 미리 구성된 패키지를 가져올 때 사용. 여기서는 awc-cli 와 aws-s3 패키지를 가져와서 간편한 설정이 가능하도록함. jobs 12345jobs: build: ... depoly-S3: ... jobs: 작업 목록을 의미 workflows 1234567891011121314151617workflows: build_and_deploy: jobs: - build: filters: tags: only: /v(\\\\d+)\\\\.[0-9]\\\\.[0-9]$/ # 버전 정규식 v1.0.0의 형태 branches: ignore: /.*/ # 모든 브랜치에 대해 트리거에서 제외한다. - depoly-S3: requires: - build # 위의 build job의 작업이 끝나면 실행되도록 설정 filters: tags: only: /v(\\\\d+)\\\\.[0-9]\\\\.[0-9]$/ branches: ignore: /.\\*/ workflows: 작업의 실행 순서 및 트리거 등을 설정한다. filters: 작업을 실행하기 위한 트리거를 설정한다. tags only: 트리거로 사용할 태깅을 등록 한다. 정규식을 사용할 수 있다. branches ignore: 트리거에서 제외할 브랜치를 설정한다. requires: 설정한 작업이 완료되면 실행되도록 설정한다. 프로젝트 빌드 작업 경로 설정 및 node.js 도커 이미지 불러오기 1234567jobs: build: working_directory: ~/repo docker: - image: cimg/node:14.18 steps: ... working_directory: 작업을 실행할 디렉토리 경로 docker: 작업 내부에서 사용할 도커 설정, 여기서는 빌드 시 yarn을 사용하므로 CircleCI가 node.js를 사용할 수 있도록 node.js 도커 이미지를 불러온다. steps: 작업 수행 단계를 의미한다. checkout 12steps: - checkout checkout: CircleCI의 CLI가 실행될 디렉토리를 코드가 있는 위치로 변경한다. restore_cache 1234- restore_cache: keys: - v1-dependencies-{{ checksum &quot;yarn.lock&quot; }} - v1-dependencies- restore_cache: 캐시 복구 기능, checksum 의 yarn.lock을 해싱한 값을 key로 삼아서 캐시를 저장하고 불러올 수 있다. 이전에 yarn을 통해 설치했던 node_modules 패키지들을 매번 설치하지 않고 불러오는게 가능하다. yarn install 123- run: name: install dependencies command: yarn install yarn install을 통해 dependency 설치 save_cache 123- save_cache: key: v1-dependencies-{{ checksum &quot;yarn.lock&quot; }} paths: - node_modules save_cache: 캐시의 key를 지정하고 어떤 파일을 캐시할 것인지 경로를 설정 yarn build 123- run: name: build command: yarn build:production 프로젝트를 빌드한다. 빌드한 현재 작업 디렉토리를 저장하기 1234- persist_to_workspace: # 빌드한 현재 작업 디렉토리 저장 root: . paths: - . persist_to_workspace: 현재 작업 디렉토리를 저장할 수 있다. 이를 통해 다른 작업에서 빌드했던 결과물을 가져올 수 있게 된다. S3에 배포하기 executor 설정 12depoly-S3:executor: aws-cli/default executor: 실행할 CLI 환경을 불러온다. 여기에서는 AWS CLI를 사용하기 위해 aws-cli/default를 불러왔다. 빌드했던 디렉토리 가져오기 123steps: - attach_workspace: # 빌드를 수행한 디렉토리를 가져오기 at: . attach_workspace: 이전에 저장했던 디렉토리를 가져온다. at 에 경로를 지정하여 가져올 수 있다. aws-s3/sync 123456789- aws-s3/sync: arguments: | --delete \\\\ --cache-control &quot;max-age=86400&quot; aws-access-key-id: AWS_ACCESS_KEY_ID aws-region: AWS_REGION aws-secret-access-key: AWS_SECRET_ACCESS_KEY from: &quot;dist&quot; to: &quot;s3://allcobootcamp.com&quot; aws-s3/sync : S3 버킷 안의 디렉토리와 현재 작업 위치의 디렉토리 구조를 맞추는 작업, 없는 디렉토리가 있다면 생성한다. arguments: S3 sync 명령어 세부 설정 (설정 정보 참고) delete: 현재 디렉토리에는 없지만 S3 디렉토리에는 있는 파일은 동기화 중 삭제처리 cache-control: 브라우저의 캐시 정책을 설정한다. max-age=N N초의 동안 캐싱하여 설정된 시간 동안에는 서버에 있는 데이터를 가져오지 않고 로컬에 있는 데이터를 사용한다. from: 빌드한 현재 소스의 위치 to: 업데이트하려는 S3 버킷의 위치 aws-s3 CLI를 사용하려면 해당되는 S3의 정보를 설정해야한다. S3에 접근하기 위해서는 aws-access-key-id, aws-region, aws-secret-access-key가 필요하다. 이는 민감한 정보이기 때문에 별도의 환경 변수로 설정하여 관리하는게 보안상 좋다. 환경 변수를 설정하려면 다음과 같이 하면 된다. 환경 변수를 설정할 프로젝트의 Project Settings에 들어간다. Environment Variables에서 Add Environment Variable 버튼을 누르면 환경 변수를 추가할 수 있다. 환경 변수를 추가한다. aws-s3/copy 1234- aws-s3/copy: arguments: '--dryrun' from: 'dist' to: 's3://allcobootcamp.com' aws-s3/copy: S3 버킷에 현재 소스를 업데이트한다. arguments: S3 copy 명령어 세부 설정 (설정 정보 참고) dryrun: 실제로 실행하지 않고 지정된 명령을 사용하여 수행할 작업을 표시합니다. from: 빌드한 현재 소스의 위치 to: 업데이트하려는 S3 버킷의 위치 전체 설정 정보123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566version: 2.1orbs: aws-cli: circleci/aws-cli@2.0.6 aws-s3: circleci/aws-s3@3.0jobs: build: working_directory: ~/repo docker: - image: cimg/node:14.18 steps: - checkout - restore_cache: keys: - v1-dependencies-{{ checksum &quot;yarn.lock&quot; }} - v1-dependencies- - run: name: install dependencies command: yarn install - save_cache: key: v1-dependencies-{{ checksum &quot;yarn.lock&quot; }} paths: - node_modules - run: name: build command: yarn build:production - persist_to_workspace: # 빌드한 현재 작업 디렉토리 저장 root: . paths: - . depoly-S3: executor: aws-cli/default steps: - attach_workspace: # 빌드를 수행한 디렉토리를 가져온다. at: . - aws-s3/sync: arguments: | --delete \\ --cache-control &quot;max-age=86400&quot; aws-access-key-id: AWS_ACCESS_KEY_ID aws-region: AWS_REGION aws-secret-access-key: AWS_SECRET_ACCESS_KEY from: 'dist' to: 's3://allcobootcamp.com' - aws-s3/copy: arguments: '--dryrun' from: 'dist' to: 's3://allcobootcamp.com'workflows: build_and_deploy: jobs: - build: filters: tags: only: /v(\\d+)\\.[0-9]\\.[0-9]$/ # 버전 정규식 v1.0.0의 형태 branches: ignore: /.*/ - depoly-S3: requires: - build filters: tags: only: /v(\\d+)\\.[0-9]\\.[0-9]$/ branches: ignore: /.*/","link":"/2022/02/16/circleci-001/"},{"title":"Clean Code 리뷰 1 ~ 2장","text":"의도를 분명히 밝히는 변수 이름을 사용하세요변수의 존재 이유, 기능, 사용법 등이 변수/함수/클래스 명에 드러나야 합니다. 따로 주석이 필요하지 않을 정도로 말이죠. 코드를 읽는 이가 사전 지식을 가지고 있다고 가정하고 변수 이름을 지으면 안됩니다. Bad1const d; // 경과 시간(단위: 날짜) Good1234const elapsedTimeInDays: number;const daysSinceCreation: number;const daysSinceModification: number;const fileAgeInDays: number; Bad123456789function getThem(): number[][] { const list1: number[][] = new Array(); for (const x of theList) { if (x[0] === 4) { list1.push(x); } } return list1;} Good123456789function getFlaggedCells(): number[][] { const flaggedCells: number[][] = new Array(); for (const cell of gameBoard) { if (cell[STATUS_VALUE] === FLAGGED) { flaggedCells.push(cell); } } return flaggedCells;} 의미 있게 변수 이름을 구분하세요아래와 같이 명명하면 어떤 함수를 호출할지 알 수 없게 됩니다. 읽는 사람이 차이를 알도록 이름을 지어야 합니다. Bad123function getUserInfo(): User;function getUserDetails(): User;function getUserData(): User; Good1function getUser(): User; 발음할 수 있는 변수 이름을 사용하세요발음하기 쉬운 이름으로 변수 이름을 지어야 합니다. 발음하기 어려운 이름으로 지으면 커뮤니케이션 하기도 어려워집니다. Bad12345type Dtarcrd102 = { genymdhms: Date; modymdhms: Date; pszqint: number;}; Good12345type Customer = { generationTimestamp: Date; modificationTimestamp: Date; recordId: number;}; 검색하기 쉬운 이름을 사용하세요상수와 같은 경우 숫자 그대로 표현하면 검색하기 힘들어집니다. 예를 들어 MILLISECONDS_IN_A_DAY는 검색으로 찾기 쉽지만 단순히 숫자 86400000로 나타낸다면 읽는 사람으로 하여금 어떤 의미를 가지는지 알 수 없게 됩니다. Bad1setTimeout(restart, 86400000); Good123const MILLISECONDS_IN_A_DAY = 24 * 60 * 60 * 1000;setTimeout(restart, MILLISECONDS_IN_A_DAY); 인코딩을 피하세요(변수에 부가 정보를 덧붙여 표기하는 것을 뜻함) 변수 명에 해당 변수의 타입(string, number 등)을 적지 마세요 변수의 종류를 구분하는 접두어를 붙이지 마세요(각각의 변수들을 다른 색상으로 표시하거나 눈에 띄게 보여주는 IDE를 사용하는 것이 맞습니다) 인코딩 예외 인터페이스 이름을 지을 때 IShapeFactory와 같이 인터페이스를 뜻하는 I를 붙이지 마세요. 해당 인터페이스를 사용하는 구현 클래스에 ShapeFactoryImp와 같이 인코딩 하세요. 암시적인 이름은 사용하지 마세요자신의 기억력을 과시하지 마세요.자신만이 아는 단어나 기발한 이름을 쓰지 마세요.명시적인 것이 암시적인 것보다 좋습니다.명료함이 최고입니다. Bad123const u = getUser();const s = getSubscription();const t = charge(u, s); Good123const user = getUser();const subscription = getSubscription();const transaction = charge(user, subscription); 클래스 이름 명사 혹은 명사구를 사용하세요(Customer, WikiPage, Account, AddressParser 등) Manager, Processor, Data, Info와 같은 단어를 피하세요 동사를 사용하지 마세요 메서드 이름 동사 혹은 동사구를 사용하세요(postPayment, deletePayment, deletePage, save 등) 접근자, 변경자, 조건자는 get, set, is로 시작하세요 Good1234const name: string = employee.getName();customer.setName(&quot;mike&quot;);if (paycheck.isPosted())... 불필요한 문맥은 추가하지 마세요클래스/타입/객체에 이름에 의미가 담겨 있다면, 변수 이름에서 반복하지 마세요 Bad123456789type Car = { carMake: string; carModel: string; carColor: string;};function print(car: Car): void { console.log(`${car.carMake} ${car.carModel} ${car.carColor}`);} Good123456789type Car = { make: string; model: string; color: string;};function print(car: Car): void { console.log(`${car.make} ${car.model} ${car.color}`);} [참고 문헌] Clean Codeclean-code-typescript","link":"/2021/04/19/clean-code-001/"},{"title":"게임 개발","text":"이 글은 이것이 취업을 위한 코딩테스트다 책을 기반으로 쓰여진 글입니다.출처 : 이것이 취업을 위한 코딩테스트다 문제현민이는 게임캐릭터가 맵 안에서 움직이는 시스템을 개발중이다. 캐릭터가 있는 장소는 1 _ 1 크기의 정사각형으로 이뤄진 N _ M 크기의 직사각형으로, 각각의 칸은 육지 또는 바다이다. 캐릭터는 동서남북 중 한 곳을 바라본다. 맵의 각칸은 (A, B)로 나타낼 수 있고, A는 북쪽으로부터 떨어진 칸의 개수, B는 서쪽으로부터 떨어진 칸의 개수이다. 캐릭터는 상하좌우로 움직일 수 있고, 바다로 되어 있는 공간에는 갈 수 없다. 캐릭터의 움직임을 설정하기 위해 정해놓은 매뉴얼은 이러하다. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향(반시계 방향으로 90도 회전한 방향)부터 차례대로 갈 곳을 정한다. 캐릭터의 바로 왼쪽 방향에 아직 가보지 않은 칸이 존재한다면, 왼쪽 방향으로 회전한 다음 왼쪽으로 한 칸을 전진 한다. 왼쪽 방향에 가보지 않은 칸이 없다면, 왼쪽 방향으로 회전만 수행하고 1단계로 돌아간다. 만약 네 방향 모두 이미 가본 칸이거나 바다로 되어있는 칸인 경우에는, 바라보는 방향을 유지한 채로 한 칸 뒤로 가고 1단계로 돌아간다. 단, 이때 뒤쪽 방향이 바다인 칸이라 뒤로 갈 수 없는 경우에는 움직임을 멈춘다. 현민이는 위과정을 반복적으로 수행하면서 캐릭터의 움직임에 이상이 있는지 테스트 하려고 한다.매뉴얼에 따라 캐릭터를 이동시킨 뒤에, 캐릭터가 방문한 칸의 수를 출력하는 프로그램을 만드시오. ▣ 입력조건첫째 줄에 맵의 세로 크기 N과 가로 크기 M을 공백으로 구분하여 입력한다. (3 &lt;= N, M &lt;= 50 )둘째 줄에 게임 캐릭터가 잇는 칸의 좌표 (A,B)와 바라보는 방향 d가 각각 서로 공백으로 구분하여 주어진다. 방향 d의 값으로는 다음과 같이 4가지가 존재한다. 0:북쪽 1:동쪽 2:남쪽 3:서쪽 셋째 줄부터 맵이 육지인지 바다인지에 대한 정보가 주어진다. N개의 줄에 맵의 상태가 북쪽부터 남쪽 순서대로, 각 줄의 데이터는 서쪽부터 동쪽 순서대로 주어진다. 맵의 외곽은 항상 바다로 되어 있다. 0:육지 1:바다 처음에 게임 캐릭터가 위치한 칸과 상태는 항상 육지이다. ▣ 출력조건첫째 줄에 이동을 마친 후 캐릭터가 방문한 칸의 수를 출력한다. 풀이123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960n, m = map(int, input().split())a, b, d = map(int, input().split())board = []visit = [[0] * m for _ in range(n)]for _ in range(n): board.append(list(map(int, input().split())))# 북 동 남 서dx = [-1, 0, 1, 0]dy = [0, 1, 0, -1]# 현재 위치에서 왼쪽 방향으로 회전def turn_left(direction): direction -= 1 if direction == -1: direction = 3 return direction# 현재 위치 방문 표시visit[a][b] = 1# 이동 시작cnt = 1while True: d = turn_left(d) nx = a + dx[d] ny = b + dy[d] # 현재 가려는 방향쪽의 칸이 방문하지 않았고 바다가 아닌 경우 if board[nx][ny] == 0 and visit[nx][ny] == 0: # 해당 칸 방문 표시 visit[nx][ny] = 1 # 해당 위치로 현재 위치 변경 a, b = nx, ny # 방문 카운트 +1 cnt += 1 # 방향 카운트 0으로 초기화 turn_cnt = 0 continue # 방문 했거나 바다인 경우 else: # 방향 카운트 +1 turn_cnt += 1 # 4방향 모두 갔는데 이동하지 못했을 경우 if turn_cnt == 4: # 바라보는 방향을 유지한 채로 뒷 칸의 위치를 생성 nx = a - dx[d] ny = b - dy[d] # 뒤쪽 방향이 바다가 아닌 경우 뒤로 이동 if board[nx][ny] == 0: a = nx b = ny # 바다인 경우 반복문 종료 else: break turn_cnt = 0# 결과 출력print(cnt)","link":"/2020/09/17/coding-test-002/"},{"title":"CSS layout float","text":"float propertyfloat는 뜨다라는 의미를 가지고 있는데 의미 그대로 어떠한 요소를 떠다니는 것처럼 보이게 할 수 있는 속성이다. float에서 사용하는 값은 3개이다. 몇 가지 더 있지만 아래의 값들이 주로 사용되는 값이며 이 중에서도 left와 right가 많이 사용된다. float: left float: right float: none float의 활용주로 사용되는 곳은 아래의 그림과 같이 img옆에 p태그 등과 같은 글씨를 놓고 싶을 때 사용한다. 또한 레이아웃을 나눌 때도 사용이 된다.아래의 예시처럼 활용할 수 있다. See the Pen poyKBgZ by Daphne_dev (@daphne-dev) on CodePen. 이처럼 레이아웃을 유동성있게 변하게 해주지만 사용할 떄 주의할 점이 있다. float속성을 가진 요소는 부모가 높이를 인지할 수 없어서 부모를 벗어나는 경우가 있다.아래의 예시처럼 말이다. See the Pen bGpKJgL by Daphne_dev (@daphne-dev) on CodePen. 이를 해결하기 위해 overflow: hidden을 생각할 수 있다. See the Pen mdPKgWW by Daphne_dev (@daphne-dev) on CodePen. 하지만 해당 방법은 완벽하지 않다.아래의 예시를 보자. See the Pen vYGrMZg by Daphne_dev (@daphne-dev) on CodePen. 만약 부모 요소의 width와 height가 정해져있고 자식 요소 중에 부모 요소보다 크기가 크게 설정되어 있다면 box3과 같이 부모 요소를 넘어서 잘려서 표시되게 된다. 이를 해결하기위해 clear: both를 사용할 수 있다.after을 활용해 가상 요소를 생성하고 clear 속성을 거기에 부여하여 float를 해제할 수 있다.해당 속성을 사용할 때 꼭 content: &quot;&quot;;를 부모 요소의 가상 요소에 써주도록 하자.content:&quot;&quot;;를 써주지 않으면 정상적으로 clear:both가 적용되지 않으므로 주의하자. See the Pen NWNzmaM by Daphne_dev (@daphne-dev) on CodePen.","link":"/2020/09/15/css-layout-float/"},{"title":"CSS layout inline &amp; inline-block &amp; block","text":"display property 어떠한 요소를 화면에 어떻게 표시할 지 선택하는 속성이다. display에서 사용하는 값은 4개이다. display: inline display: block display: inline-block display: none inline요소를 inline으로 표시하는 속성inline이라는 말 그대로 inline요소는 요소끼리 서로 한 줄에, 바로 옆에 위치한다. See the Pen jOqKJvG by Daphne_dev (@daphne-dev) on CodePen. inline 속성을 줌으로써 한 줄에 표시하게 되는 것을 볼 수 있다. blockblock 속성은 바로 옆(좌우측)에 다른 요소를 붙여넣을 수 없다는 뜻이다.inline 요소와 성질이 반대되는 속성이다. See the Pen wvGXOQJ by Daphne_dev (@daphne-dev) on CodePen. block 속성을 줌으로써 각각의 div가 각각 한 줄 씩 자리를 차지한 것을 볼 수 있다. inline-blockinline-block은 block 속성에 inline 효과를 준 것이다. See the Pen XWdYGox by Daphne_dev (@daphne-dev) on CodePen. inline처럼 한 줄에 배치되지만 block 속성으로 크기가 변하지 않고 있음을 확인할 수 있다. nonenone 속성은 화면에 아예 표시하지 않음을 의미한다.주로 hover과 같이 활용하여 특정 동작을 하면 none 속성을 해제해 보이도록 표시하는 역할을 한다. See the Pen bGpKZzW by Daphne_dev (@daphne-dev) on CodePen. none을 줌으로써 공간자체를 차지하지 않고 화면에서 완전히 보이지 않음을 확인할 수 있다.","link":"/2020/09/15/css-layout-inline/"},{"title":"음료수 얼려먹기","text":"이 글은 이것이 취업을 위한 코딩테스트다 책을 기반으로 쓰여진 글입니다.출처 : 이것이 취업을 위한 코딩테스트다 문제N * M 크기의 얼음틀이 있다. 구멍이 뚫려있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다. 구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한다. 이때 얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성하시오. 다음의 4 X 5 얼음 틀 예시에서는 아이스크림이 총 3개 생성된다. ▣ 입력조건 첫 번째 줄에 얼음 틀의 세로 길이 N과 가로 길이 M이 주어진다.(1 &lt;= N, M &lt;= 1000) 두 번째 줄부터 N + 1 번째 줄까지 얼음 틀의 형태가 주어진다. 이때 구멍이 뚫려있는 부분은 0, 그렇지 않은 부분은 1이다. ▣ 출력조건 한 번에 만들 수 있는 아이스크림의 개수를 출력한다. 풀이1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from collections import dequen, m = map(int, input().split())# 그래프 생성graph = []for i in range(n): graph.append(list(map(int, input())))# 상하좌우 탐색dx = [0, 0, 1, -1]dy = [1, -1, 0, 0]# BFSdef bfs(x, y): # 현재 위치를 큐에 집어넣음 q = deque() q.append((x,y)) # 만약 현재 위치가 1이라면 아이스크림을 만들 수 없는 공간이거나 이미 탐색한 곳이므로 False 반환 if graph[x][y] == 1: return False # 현재 위치를 기준으로 BFS 탐색 while q: x, y = q.popleft() # 현재 위치 값을 0에서 1로 변경 graph[x][y] = 1 # 상하좌우 탐색 for i in range(4): nx = x + dx[i] ny = y + dy[i] # 얼음 틀 범위에서 벗어나지 않으면서 그 위치의 값이 0인 경우에만 큐에 집어넣음 if 0 &lt;= nx &lt; n and 0 &lt;= ny &lt; m and graph[nx][ny] == 0: q.append((nx,ny)) # 하나의 아이스크림이 만들어지는 공간을 모두 탐색한 경우 True return Truecnt = 0for i in range(n): for j in range(m): # 현재 위치에서 BFS 수행 if bfs(i, j) == True: cnt += 1print(cnt) 책에서는 DFS로 풀이가 되어있지만 BFS로 풀어보았다.","link":"/2020/10/05/coding-test-003/"},{"title":"[DataBase] 관계형 데이터 베이스","text":"DataBase란? Database : 데이터를 저장 및 보존하는 시스템 Application에서는 데이터가 메모리 상에서 존재한다. 메모리는 휘발성이라는 특성을 가지고 있기 떄문에 보존되지 않는다. 해당 애플리케이션이 종료되면 메모리에 있던 데이터들은 다시 읽어 들일 수 없다. 데이터를 장기 기간동안 저장 및 보존하기 위해서 데이터베이스를 사용한다. Database는 크게 2가지로 나뉘는데 관계형 데이터베이스(RDBMS)와 비관계형 데이터 베이스인 NoSQL이 있다. 결국 데이터베이스는 데이터들을 안전하고 체계적으로 저장하고 보존하기 위해 생각해낸 방법이다. 관계형 데이터베이스(RDBMS, Relational DataBase Management System) 관계형 데이터 모델에 기초를 둔 데이터베이스 시스템관계형 데이터란 데이터를 서로 상호관련성을 가진 형태로 표현한 데이터를 말함ex) MySQL, Postgres, Oracle DB 관계형 데이터베이스의 특징 모든 데이터들은 2차원 테이블로 표현 각각의 테이블은 서로 상호관련성을 가지고 서로 연결될 수 있다. 각각의 테이블을 컬럼(column)과 row(로우)로 구성 컬럼은 테이블의 각 항목을 말한다. 로우는 각 항목들의 실제 값을 말한다. 각 로우는 저만의 고유 키(Primary Key)가 있다. 테이블 간의 연결크게 3가지의 종류가 있다. one to one one to many many to many 1. One to One 테이블 A의 로우와 테이블 B의 로우가 정확히 1:1 매칭이 되는 관계 2. One to Many 테이블 A의 로우가 테이블 B의 여러 로우와 연결이 되는 관계 1:N 관계 3. Many to Many 테이블 A의 여러 로우가 테이블 B의 여러 로우와 연결이 되는 관계 N:N 관계 테이블을 연결하는 방법 특정 테이블의 고유 키가 되는 로우를 Foreign key(외부키)로 사용하여 주로 연결한다. 앞의 one to one 예에서 user_profiles 테이블의 user_id 컬럼은 user 테이블에 걸려있는 외부 키로 지정한다. 즉, user_id의 값은 users 테이블의 id 값이며 user_id 값은 무조건 users 테이블의 id 컬럼에 존재하는 값만 생성될 수 있다. 만약 users 테이블에 없는 id 값이 user_id에 지정되면 에러가 난다. 테이블을 연결하는 이유 하나의 테이블에 모든 정보를 다 넣으면 동일한 정보들이 불필요하게 중복되어 저장되기 때문이다. 이로 인해 더 많은 디스크(저장공간)를 사용하게 된다. 잘못된 데이터가 저장될 가능성이 높아진다. 테이블을 연결하면 위의 문제가 해결된다. 이렇게 여러 테이블에 나누어서 저장하는 것을 normalization(정규화)라고 한다.","link":"/2020/09/25/database-001/"},{"title":"CSS layout position","text":"position property 웹에서 복잡한 레이아웃을 만들게 도와주는 CSS 속성 중 하나이다. position에서 사용하는 값은 4개이다.주로 쓰이는 속성은 relative 와 absolute이다. position: static; position: relative; position: absolute; position: fixed; relativerelatvie 속성은 그 자체로 의미가 없다. top, right, bottom, left 속성을 통해 원래의 위치에서 이동할 수 있다.위의 4개의 속성은 position이라는 속성이 있을 때만 적용되는 속성이다. See the Pen oNxyoXJ by Daphne_dev (@daphne-dev) on CodePen. 위의 예제를 보자relative 박스는 위치의 변화가 없다.즉, relative 자체만으로는 아무런 효과를 줄 수 없다.top: -20, left: 30을 줌으로써 위로 20px 이동하고 왼쪽으로 30px 떨어진다. 마이너스 값을 주면 아래로 떨어지지 않고 위로 올라가게 된다. absoluteabsolute 속성은 이름과 같이 절대적인 위치에 둘 수 있다.특정 부모에 대해 절대적으로 움직이는데, 부모 중에 position이 relative, fixed, absolute 하나라도 있으면 해당 부모에 대해 절대적으로 움직인다. See the Pen ExKRbKR by Daphne_dev (@daphne-dev) on CodePen. 위의 예제를 보자div박스를 position: relative;로 설정하였다.부모가 position: relative; 속성이므로자식인 p태그에 position: absolute; 속성을 주면 부모에 대해 절대적으로 움직이게 된다.right: 0;에 bottom: 0;을 주어 부모를 기준으로 우측 아래에 위치하게 하였다. absolute값을 갖게되면 내용의 크기만큼만 가로크기가 된다. fixedfixed는 말그대로 고정됐다는 의미이다.absoulte처럼 따로 부모가 필요없이 혼자 동작한다.fixed는 눈에 보이는 브라우저 화면 크기만큼, 화면 내에서만 움직인다. See the Pen qBZKPmV by Daphne_dev (@daphne-dev) on CodePen. 위의 예제를 보자스크롤을 위아래로 움직여보면 fixed로 설정된 박스는 스크롤을 해도 항상 같은 위치에 있게 된다.","link":"/2020/09/14/css-layout-position/"},{"title":"[DataBase] SQL(RDBMS) VS NoSQL","text":"NoSQL이란? 비관계형 타입의 데이터를 저장할 때 주로 사용되는 데이터베이스 시스템관계형 데이터베이스와 다르게 비관계형이기 때문에 데이터들을 저장하기 전에 정의할 필요가 없다.MongoDB, Redis, Cassandra 등이 대표적인 NoSQL 데이터베이스이다. SQL(RDBMS) VS NoSQLSQL 장점 관계형 데이터베이스는 데이터를 효율적, 체계적으로 저장 및 관리가 가능 데이터 구조를 정의함으로써 데이터의 완전성이 보장 트랜잭션 정형화된 데이터, 데이터의 완전성이 중요한 데이터를 저장하는데 유리하다. ex) 전자상거래 정보, 은행 계좌 정보, 거래 정보 등 SQL 단점 테이블 구조 변화 등에 덜 유연하다. 확장성이 낮다. (확장하는데 비용이 많이 듬) NoSQL 장점 데이터 구조를 미리 정의하지 않아도 됨으로 저장하는 데이터의 구조 변화에 유연하다. 확장하기 비교적 쉽다. 방대한 양의 데이터를 저장하는데 유리하다. 비정형화된 데이터나 완전성이 상대적으로 덜 유리한 데이터를 저장하는데 유리하다. ex) 로그데이터 NoSQL 단점 데이터의 완전성이 덜 보장된다. 트랜잭션이 안되거나 비교적 불안정하다.","link":"/2020/10/04/database-002/"},{"title":"[DataBase] SQL 기본 쿼리문 사용하기 1","text":"쿼리문이란? Database에서 내가 원하는 대로 데이터를 조작하려면 어떻게 해야할까?데이터를 저장할 곳을 생성하거나, 데이터를 저장, 수정, 삭제 등을 쿼리문을 통해 조작할 수 있다. DDL(Data Define Language) DDL은 데이터베이스의 schema(형태)를 정의할 수 있는 쿼리문을 의미CREATE, ALTER, DROP이 대표적이다. CREATE DATABASE &amp; TABLECREATE 쿼리문을 통해 데이터베이스나 테이블을 생성할 수 있다. 12CREATE DATABASE my_database; # 데이터베이스를 생성하는 명령어SHOW DATABASES; # 저장한 데이터베이스를 보는 명령어 데이터베이스를 생성하였으니 들어가서 사용해보자. 1USE my_database; # 생성한 데이터베이스에 접근하는 명령어 이제 테이블을 생성해보자.보통 일반적으로 테이블의 이름은 복수형으로 짓는다. 123456789101112131415CREATE TABLE categories( id INT NOT NULL AUTO_INCREMENT, # id 컬럼을 정수, NULL을 허용하지 않으며 테이블에 데이터를 넣을 때마다 자동으로 값을 증가시키게 설정 name VARCHAR(100) NOT NULL, # name 컬럼을 100의 크기를 가지는 문자열로 NULL을 허용하지 않도록 설정 PRIMARY KEY (id) # 이 테이블의 primary key를 id로 설정한다.);CREATE TABLE products( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, category_id INT, PRIMARY KEY (id), FOREIGN KEY (category_id) REFERENCES category (id) # category 테이블의 id를 외래키로 지정); 이제 아래 쿼리문을 입력해보자 123SHOW TABLES; # 현재 데이터베이스에 존재하는 테이블을 볼 수 있는 명령어DESC categories; # 테이블의 설정 정보를 볼 수 있는 명령어DESC products; 아래와 같이 테이블이 생성된 것을 확인할 수 있다. DML(Data Manipulation Language) DML은 데이터를 조작하는 쿼리문을 의미INSERT, UPDATE, DELETE가 대표적이다. INSERT INTO (table)생성한 테이블에 데이터를 넣어보자. 12INSERT INTO categories (name) VALUES ('juice'); # categories 테이블에 name 컬럼의 값을 'juice'라는 값으로 데이터를 넣겠다는 의미INSERT INTO categories (name) VALUES ('foood'); 1SELECT * FROM categories; # 테이블안의 데이터를 조회하는 쿼리문 '*'은 테이블의 모든 컬럼을 조회하겠다는 의미 UPDATE (table) SET (column)데이터를 넣고보니 데이터가 잘못 입력됐다는 것을 알게 되었다.foood를 food로 데이터를 수정해보자 12UPDATE categories SET name='food' where id=2;# categories 테이블에 id가 2인 데이터에 대해 name을 `food`로 `UPDATE` 하겠다는 의미 DELETE FROM (table)테이블에서 특정 데이터를 지워보자. 12DELETE FROM categories WHERE name='food';# categories 테이블에서 name이 food인 데이터를 삭제하겠다는 의미 DQL(Data Query Language) DQL은 데이터를 쿼리하는데 사용되는 SQL을 뜻한다.Query(쿼리)란 묻다, 질문하다라는 의미이다.데이터베이스의 데이터를 조회한다고 보면 된다. SELECT현재 각 테이블들에 들어가 있는 데이터이다. 테이블의 특정 컬럼만 보고 싶을 때1SELECT products.name FROM products; WHERE 조건문특정 값만 조회하고 싶을 때, WHERE 절을 사용할 수 있다.다음 예시는 주스 이름만 검색하는 쿼리문이다. 1SELECT products.name FROM products WHERE category_id=1; WHERE + LIKE 조건문LIKE를 사용하면 좀 더 쉽고 자세하게 검색을 할 수 있게 된다.보통 특수문자와 함께 사용하여 검색을 하는데, 아래 예시에서의 %를 양쪽에 붙이면 어떤 글자던 pizza라는 글자가 포함된 모든 데이터를 불러오라는 말이다.다음 예시는 pizza를 검색하는 쿼리문이다. 1SELECT products.name FROM products WHERE products.name LIKE '%pizza%';","link":"/2020/10/24/database-003/"},{"title":"[DataBase] Transaction","text":"트랜잭션(Transaction)이란?트랜잭션은 작업의 완전성을 보장해주는 것이다. 즉, 논리적인 작업을 모두 완벽하게 처리하지 못할 경우 원 상태로 복구해서 작업의 일부만 적용되는 일을 방지하는 기능이다. 트랜잭션과 Lock잠금(Lock)은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다. 트랜잭션은 논리적인 작업 셋 중 한 개든 두 개 이상이든 모든 작업이 제대로 끝나지 않는다면 아무것도 적용되지 않게 보장해준다. 트랜잭션의 특성트랜잭션은 ACID라는 4가지 특성을 만족해야한다. 원자성(Atomicity)트랜잭션 중간에 어떠한 문제가 발생했을 때 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. 일관성(Consistency)트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. 고립성(Isolation)각각의 트랜잭션은 서로 간섭업이 독립적으로 수행되어야 한다. 지속성(Durability)트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. 트랜잭션을 사용할 때 주의할 점트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 일반적으로 데이터베이스에서 커넥션의 개수는 제한적이기 때문인데, 각각의 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 수가 줄어들게 되어 커넥션을 가져가기 위해 기다리는 상황이 발생할 수 있기 때문이다. 교착상태복수의 트랜잭션을 사용할 때 교착상태가 일어날 수 있다. 교착상태란 두 개 이상의 트랜잭션이 특정 자원의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데, 이를 교착상태라고 한다. 예를 들면, 두 개의 A, B 테이블이 있고 각각의 다른 1번, 2번 트랜잭션이 테이블의 잠금을 획득한다고 가정해보자. 1번 트랜잭션이 B의 잠금을 획득2번 트랜잭션이 A의 잠금을 획득 이 상태에서 트랜잭션을 commit 하지 않은채 서로의 첫 번째 행에 대한 잠금을 요청하면 Deadlock이 발생한다. 교착상태의 빈도를 낮추는 방법 트랜잭션을 자주 커밋한다. 정해진 순서로 테이블에 접근하게 한다. 읽기 잠금 획득의 사용을 피한다. 한 테이블의 복수 행을 복수의 연결에서 순서 없이 갱신하면 교착 상태가 발생하기 쉽다. 이 때에는 테이블 단위의 잠금을 획득하여 갱신을 직렬화 하면 동시성은 떨어지지만 교착상태를 회피할 수 있다.","link":"/2021/01/04/database-transaction/"},{"title":"[DataBase] SQL 점 이력, 선분 이력","text":"이력 관리란 ? 모든 업무는 언제 시작해서 언제 끝났는지에 관한 정보가 기록되어 있다. 예를 들면 배송 상태에 따른 이력이 있는데, 배송 시작, 배송 중, 배송 완료 등 각각의 상태에 따라 이력이 관리된다. 이러한 이력을 기록하고 관리하는 것이 이력 관리이다. 이력 관리 대상이러한 이력 관리는 관리하지 않을 때와 비교했을 때 많은 비용이 들어간다. 따라서 이력 관리가 필요한 데이터는 어떤 것인지 잘 판단하는 것이 중요하다. 관리해야할 데이터가 다음 5가지의 조건에 맞는지 확인하자. 변경 내역을 감시할 필요가 있는가? 시간의 경과에 따라 데이터가 변할 수 있는가? 시간의 경과에 따라 관계가 변하는가? 과거의 데이터를 조회할 필요가 있는가? 과거 버전을 보관할 필요가 있는가? 점 이력(시점 이력)과 선분 이력 시점 이력 : 데이터의 변경이 발생한 시각만을 관리 선분 이력 : 데이터 변경의 시작 시점부터 그 상태의 종료 시점까지 관리 시점 이력의 문제점시점 이력으로 이력을 관리했을 때, 특정한 시점의 데이터를 추출하고자 할 경우 불필요한 쿼리를 작성하게 된다. 때문에 이러한 경우 선분 이력을 채택하는 경우가 많다. 선분 이력특정한 시점의 데이터를 추출하고자 할 때, 예를 들어 2020년 11월 10일부터 2020년 11월 20일까지의 모든 주문 상태를 보고 싶다고 할 때, 선분 이력을 적용하면 수월한 관리가 될 수 있다. 123SELECT 주문 상태FROM 주문 이력WHERE 발생 시각 between 2020-11-10 and 2020-11-20 선분 이력에서 종료점 처리 시 주의사항 종료점이 미정이므로 NULL 논리적으로 타당하지만 비교가 불가능 인덱스를 사용하지 못하므로 수행 속도 저하 수렴하므로 최대치 부여 아직 종료되지 않았으므로 무한히 계속되는 것으로 간주 최대치 부여(예: 날짜라면 9999/12/31) 수행 속도에 유리 참고 : http://www.dbguide.net/db.db?cmd=view&amp;boardUid=12856&amp;boardConfigUid=9&amp;categoryUid=216&amp;boardIdx=41&amp;boardStep=1","link":"/2020/11/17/database-005/"},{"title":"[DataBase] Index","text":"인덱스(Index)란? 단어 뜻 그대로 책의 맨 처음이나 맨 마지막에 있는 색인이라고 할 수 있다. 데이터 = 책의 내용데이터가 저장된 레코드의 주소 = 인덱스 목록의 페이지 번호 DBMS의 인덱스는 항상 정렬된 상태를 유지한다.원하는 값을 탐색하는데는 빠르지만 데이터를 추가, 삭제, 수정하는 경우 쿼리문 실행 속도가 느려진다. 즉, 데이터의 저장 성능을 낮추는 대신 데이터의 읽기 속도를 높이는 기능이다. 인덱스 방법B+-Tree 인덱스이름 그대로 데이터를 트리 구조로 저장하는 형태의 인덱스이다. 균형잡힌 뛰어난 범용성 때문에 가장 많이 사용되는 방법이다. 해시 인덱스칼럼(Column)의 값을 이용해 해시 값을 계산하여 인덱싱하는 알고리즘이다. 매우 빠른 검색을 지원하지만 거의 사용되지 않는다. 해시 자체가 1:1로만 대응되는 성질을 가지고 있기 때문에 범위 검색을 할 수 없다는 단점 때문이다. 비트맵 인덱스데이터를 비트 플래그로 변환해서 저장하는 형태의 인덱스이다. 테이블이 많은 행을 가지면서 카디널리티가 낮은 필드에 대해 유리하다. 하지만 키를 갱신할 떄 비용이 너무 크다는 단점이 있어서 갱신이 잘 일어나지 않는 경우에만 쓰인다. 인덱스를 꼭 사용해야 할까?SELECT 쿼리의 성능을 향상시키는 인덱스는 모든 경우에서 좋다고 할 수 있을까?가령 모든 컬럼에 인덱스를 생성하면 매우 빠른 검색 속도를 낼 수 있을까? 결론은 그렇지 않다. 인덱스를 사용하게 되면 INSERT, DELETE, UPDATE 쿼리를 실행할 때 인덱스를 위해 별도의 과정이 추가적으로 발생한다. INSERT 는 인덱스에 대한 데이터를 따로 추가해야한다. DELETE 의 경우 인덱스에 존재하는 값은 삭제되지 않고 사용되지 않는다는 표시로 남게 된다. UPDATE의 경우 INSERT 와 같이 인덱스 데이터가 추가되고 DELETE 와 같이 이전 데이터가 그대로 남아있게 될 것이다. 컬럼에 저장되는 데이터의 형식에 따라서 인덱스의 성능이 좋지 않을 수 있다. 즉, 모든 컬럼에 대해 인덱스를 생성하는 것보다 인덱스가 생성되면 효율이 좋은 컬럼이 있다. 그렇다면 인덱스를 사용하기 위한 좋은 조건은 무엇일까? 다음의 두 가지 지표로 판단할 수 있다. 카디널리티와 선택률이다. 카디널리티가 높아야한다. 선택률이 낮아야한다. 테이블에서 카디널리티가 가장 높은 필드는 모든 레코드에 다른 값이 들어가있는 유일 키 필드이다. 반대로 모든 레코드에 같은 값이 들어가 있다면 카디널리티가 낮은 필드이다. 선택률은 특정 필드값을 선택했을 때 테이블 전체에서 몇 개의 레코드가 선택되는지를 나타내는 개념이다. 예를 들면 100개의 레코드가 있는 테이블에서 where 절을 사용하여 유일 키 값인 id=1 로 조회한다면 단 하나의 레코드만 선택될 것이다.이 때 1/100 = 0.01로 선택률은 1%이다.","link":"/2021/01/04/database-index/"},{"title":"Django에 MySQL 연동하기","text":"이 글은 WSL 우분투 18.04 버전을 기준으로 쓰여진 글입니다. 설정에 참고 바랍니다. MySQL 및 mysqlclient 설치하기123sudo apt-get updatesudo apt-get install mysql-serverpip install mysqlclient 파이썬에서는 mysqlclient라는 라이브러리를 통해 MySQL에 쉽게 연동이 가능하다. MySQL 실행하기12sudo service mysql startsudo mysql -u root -p (참고) MySQL 한글(UTF8) 적용하기 MySQL DB 생성하기DB에 접속 후 show databases;를 입력하면 현재 DB 목록이 나온다.MySQL 계정을 생성하기 위해서는 mysql 이라는 DB에 접근해야 한다. 1CREATE DATABASE starbucks; starbucks 라는 이름의 DB가 생성된 것을 확인할 수 있다. MySQL 계정 생성 및 권한 주기12use mysql;select user, host from user; SELECT User, Host FROM user; 을 입력하면 현재 생성되어 있는 계정의 목록을 볼 수 있다. 이제 계정을 생성해보자 1CREATE USER 'daphne'@'localhost' IDENTIFIED BY 'daphne123456'; 'daphne'@'localhost'에서 daphne는 계정 이름을 의미하고 localhost는 해당 계정에 접근 가능한 IP를 의미한다. IDENTIFIED BY 뒤의 문자는 비밀번호를 입력하는 공간이다. daphne라는 계정이 생성된 것을 확인할 수 있다. 이제 해당 계정이 starbucks DB를 사용할 수 있도록 권한을 부여해주자. 1GRANT ALL PRIVILEGES ON starbucks.* to daphne@localhost; daphne라는 계정이 localhost에서 가지고 있는 권한에 대해 확인해보자. 1SHOW GRANTS FOR 'daphne'@'localhost'; MySQL에서의 설정은 끝났다.django에서의 설정을 알아보자. Django와 MySQL의 연결my_settings.py을 만들어 아래의 정보를 입력한다. 12345678910DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', # 사용할 DB의 종류 'NAME': 'starbucks', # DB 이름 'USER': 'daphne', # DB 계정 이름 'PASSWORD': 'daphne123456', # DB 계정의 패스워드 'HOST': 'localhost', # IP 'PORT': '3306', # 포트 번호 }} settings.py 에 해당 설정을 import 해주고 DATABASES 설정을 변경해준다. 123import my_settings.pyDATABASES = my_settings.DATABASES 이제 python manage.py migrate 명령어를 입력하면 테이블이 MySQL에 생성되는 것을 볼 수 있다. 성공적으로 Django에 MySQL을 연결한 것이다.","link":"/2020/10/01/django-mysql/"},{"title":"Django ORM 활용 1","text":"Django ORM 기본자주 쓰이는 django의 QuerySet Method에 대해 알아보자보통 django에서 QuerySet Method를 실행하면 두 가지의 실행 결과가 나온다. QuerySet을 반환하는 경우 &lt;QuerySet [&lt;Category: Category object (1)&gt;, &lt;Category: Category object (2)&gt;]&gt; 그렇지 않은 경우 &lt;Category: Category object (1)&gt;, 1, True … 이를 염두하고 상황에 맞게 활용하도록 하자. Django CRUDDjango를 MySQL에 연결하여 데이터를 처리해보자. 참고 : Django에 MySQL 연동하기 해보기 전에 미리 세팅을 해보자.django project를 생성하고 app까지 만들었다는 가정하에 진행하겠다.다뤄 볼 테이블들은 Menu, Category, Product로 3가지다.models.py에 아래와 같이 모델을 만들어보자. 12345678910111213141516171819202122# products/models.pyfrom django.db import modelsclass Menu(models.Model): name = models.CharField(max_length=45) class Meta: db_table = 'menus'class Category(models.Model): name = models.CharField(max_length=45) menu = models.ForeignKey(Menu, on_delete=models.CASCADE) class Meta: db_table = 'categories'class Product(models.Model): name = models.CharField(max_length=45) category = models.ForeignKey(Category, on_delete=models.CASCADE) class Meta: db_table = 'products' 마이그레이션 적용을 마치면 MySQL에 3개의 테이블이 생성될 것이다.이제 django shell을 이용하여 간단한 명령어 사용법을 익혀보자.django project를 생성했다면 manage.py가 있는 경로에서 python manage.py shell을 입력하면 django shell이 실행된다. 가장 먼저 모델을 가져다 쓰기위해 import를 하자. from products.models import Menu, Category, Product create()SQL문에서 INSERT를 이용해 Table에 데이터를 추가하는 것과 동일하다. 12In : Menu.objects.create(name=&quot;음료&quot;)Out : &lt;Menu: Menu object (1)&gt; 생성된 인스턴스를 반환해준다. get()SQL문에서 SELECT를 이용해 Table의 데이터를 조회하는 것과 동일하다. 12In : Menu.objects.get(id=1)Out : &lt;Menu: Menu object (1)&gt; 지정된 조회 매개 변수와 일치하는 인스턴스를 반환 해주는데 단 하나의 값 반환해주기 때문에 해당 조건에 대해 중복되는 row들이 있으면 에러를 일으킨다. filter()SQL문에서 SELECT와 WHERE절을 이용해 Table의 데이터를 조회하는 것과 동일하다. 12In : Menu.objects.filter(id=1)Out : &lt;QuerySet [&lt;Menu: Menu object (1)&gt;]&gt; 조건에 맞는 데이터들을 QuerySet 안에 넣어서 반환해준다. update()SQL문에서 UPDATE를 이용해 Table의 데이터를 수정하는 것과 동일하다. 12In : Menu.objects.filter(id=1).update(name=&quot;푸드&quot;)Out : 1 수정된 row 개수를 반환한다. delete()SQL문에서 DELETE를 이용해 Table의 데이터를 삭제하는 것과 동일하다. 12In : Menu.objects.filter(id=1).delete()Out : (1, {'products.Menu': 1}) 삭제 쿼리를 수행 후 삭제된 개체의 수와 개체 유형별 삭제 횟수가 있는 dictionary를 반환한다. save()SQL문에서 INSERT 또는 UPDATE를 수행하는 것과 동일하다.단일 객체에 대해서 업데이트를 수행할 때 많이 사용된다. 1234567891011In : menu = Menu.objects.get(id=1)Out : &lt;Menu: Menu object (1)&gt;In : menu.nameOut : &quot;푸드&quot;In : menu.name = &quot;new name&quot;In : menu.save()In : menu.nameOut : &quot;new name exists()filter()와 함께 사용해서 filter 조건에 맞는 데이터가 있는지 확인하여 존재하면 True 존재하지 않으면 False를 반환한다. 12In : menu = Menu.objects.filter(id=1).exists()Out : True all()한 테이블의 모든 레코드를 가져올 때 쓰인다. 12In : menu = Menu.objects.all()Out : &lt;QuerySet [&lt;Menu: Menu object (1)&gt;, &lt;Menu: Menu object (2)&gt;, &lt;Menu: Menu object (3)&gt;, &lt;Menu: Menu object (4)&gt;]&gt; values()모델 인스턴스가 아닌 dictionary을 포함하는 QuerySet을 반환한다. 12In : Menu.objects.filter(id=1).values()Out : &lt;QuerySet [{'id': 1, 'name': '음료'}]&gt; values_list()values()와 달리 튜플을 반환한다. 12In : Menu.objects.filter(id=1).values_list()Out : &lt;QuerySet [(1, '음료')]&gt;","link":"/2020/10/15/django-orm-002/"},{"title":"[DataBase] SQL 기본 쿼리문 사용하기 2","text":"현재 products 테이블에 들어있는 데이터는 아래와 같다. WHERE + BETWEENBETWEEN 연산자는 특정 범위를 정해서 해당하는 값만 선택한다. 1SELECT name, price FROM products WHERE price BETWEEN 1000 and 4000; COUNTCOUNT 연산자는 테이블에서 해당 컬럼의 row의 개수를 센다. 1SELECT COUNT(price) FROM products WHERE price BETWEEN 1000 and 4000; SUMSUM 연산자는 테이블에서 해당 컬럼의 합을 계산한다.여기서 AS는 alias를 의미하며 테이블의 이름을 total로 바꾸겠다는 의미로 쓰였다. 1SELECT SUM(price) AS total FROM products WHERE price; AVGAVG 연산자는 테이블에서 해당 컬럼의 평균을 계산한다. 1SELECT AVG(price) AS total FROM products WHERE price;","link":"/2020/10/24/database-004/"},{"title":"Django의 구조","text":"django의 구조를 크게 보면 3개로 나뉘어 진다.Model, View, Template이다. 참고 : django 란? django의 구조를 도식화하면 아래와 같이 된다. URLs : 요청받은 URL을 기준으로 HTTP 요청을 적절한 View로 보내주기 위해 사용된다. View : HTTP 요청을 수신하고 HTTP 응답을 반환하는 요청 처리 함수이다. View는 Model을 통해 필요한 데이터에 접근하여 요청한 사항을 처리하고 Template에 응답의 서식을 맡긴다. Model : 데이터 구조를 정의하고 데이터베이스의 기록을 관리하고 쿼리하는 방법을 제공하는 파이썬 객체이다. ORM : 객체(Object)와 관계형 데이터베이스(Relational Database)의 데이터를 매핑(Mapping)해주는 것을 의미, django에서는 ORM을 통해 sql 쿼리문을 쓰지 않고도 데이터베이스의 데이터를 다룰 수 있다. Template : 파일의 구조나 레이아웃을 정의하고 View에서 보내진 데이터를 바탕으로 렌더링을 해주는 역할을 한다. django는 일련의 단계를 수행해서 웹 브라우저에 응답을 반환한다. HTTP request를 보냄 URLs에서 요청받은 URL패턴에 맞게 알맞은 View로 보냄 View는 받은 요청에 따라 Model에서 ORM을 이용해 DB 데이터에 접근하여 요청을 처리 HTTP response를 반환 Template에서 View에서 받은 데이터를 기반으로 렌더링 출처 : https://developer.mozilla.org/ko/docs/Learn/Server-side/Django/Introduction","link":"/2020/10/15/django-001/"},{"title":"Django ORM 활용 2","text":"이 글은 아래의 글과 이어지는 글입니다. Django ORM 기본 WHERE 문 ORM상품 중에 특정 가격에 대해 조건을 걸고 필터링하고 싶을 때 12345Product.objects.filter(price__gt=5000) # WHERE price &gt; 5000;Product.objects.filter(price__gte=5000) # WHERE price &gt;= 5000;Product.objects.filter(price__lt=5000) # WHERE price &lt; 5000;Product.objects.filter(price__lte=5000) # WHERE price &lt;= 5000;Product.objects.exclude(price=5000) # WHERE price != 5000; BETWEEN상품 중에 특정 가격에 대해 범위를 정해서 필터링하고 싶을 때 1Product.objects.filter(price__range=[1000, 2000]) # WHERE price BETWEEN 1000 and 2000; LIKE특정 상품 이름을 찾고 싶을 때 123456Product.objects.filter(name__icontains='감자') # WHERE name LIKE '%감자%';Product.objects.filter(name__contains='감자') # WHERE name LIKE binary '%감자%';Product.objects.filter(name__istartswith='감자') # WHERE name LIKE '감자%';Product.objects.filter(name__startswith='감자') # WHERE name LIKE binary'감자%';Product.objects.filter(name__iendswith='감자') # WHERE name LIKE '%감자';Product.objects.filter(name__endswith='감자') # WHERE name LIKE binary '%감자'; IN여러 개의 정확한 row를 가져오고 싶을 때ex) 상품 id가 1, 2인 것을 찾고 싶을 때 1Product.objects.filter(id__in=[1, 2]) # WHERE id in (1, 2); AND, OR, NOT판매하고 있는 상품이면서 동시에 가격이 5000원 이상인 경우 AND 12Products.objects.filter(is_sold_out='false', price__gte=5000)# WHERE is_sold_out=false and price &gt;= 5000; 판매하고 있는 상품 또는 가격이 5000원 이상인 경우 OR 123import QProducts.objects.filter(Q(is_sold_out='false') | Q(price__gte=5000))# WHERE is_sold_out=false or price &gt;= 5000; 판매하지 않는 상품을 제외하고 보고 싶을 경우 NOT 12Products.objects.exclude(is_sold_out='false')# WHERE NOT is_sold_out=false; NULL상품의 알레르기 정보의 기본 값을 NULL로 주었을 때,알레르기 정보가 있는 것만 보고 싶을 경우 123Products.objects.filter(allergy__isnull=False)Products.objects.exclude(allergy=None)# WHERE allergy is NOT NULL 알레르기 정보가 없는 것만 보고 싶을 경우 123Products.objects.filter(allergy__isnull=True)Products.objects.filter(allergy=None)# WHERE allergy is NULL","link":"/2020/10/26/django-orm-003/"},{"title":"Django Query String","text":"Query String이란 ? Query의 사전적 의미는 질문이라는 뜻을 가지고 있고 String은 문자열이라는 뜻을 가진다.즉, 서버에게 혹은 클라이언트에게 무엇이 필요한 것인지 묻는 문자열이라고 볼 수 있다. 보통 GET으로 요청하는데, RESTful한 형태로 서버에 요청한다. RESTful API란? 예를 들어 GET http://localhost:8000/products?name=&quot;딸기&quot; 라고 서버에 요청하면, 서버는 상품 중에서 이름이 딸기인 것을 보여줄 것이다. Django에서의 Query String 활용법그렇다면 Django에서는 어떻게 해야 Query String을 받아서 응답해줄 수 있을까 아래의 예시를 보자 12345678# urls.pyfrom django.urls import pathfrom product.views import ProductDetailViewurlpatterns = [ path('/products', ProductListView.as_view())] 123456789101112131415161718# view.pyimport jsonfrom django.http import JsonResponsefrom django.views import Viewfrom product.models import Productclass ProductDetailView(View): def get(self, request): try: name = request.GET.get('name') products = Product.objects.filter(name=name).values() products = list(products) return JsonResponse({'message':'SUCCESS', 'products':products}, status=200) except ValueError: return JsonResponse({'message':'VALUE_ERROR'}, status=400) GET http://localhost:8000/products?name=&quot;딸기&quot;라는 GET 요청이 오면 name안에 담긴 값을 request.GET.get으로 가져와서 Product 안의 이름이 딸기인 것을 모두 찾아 해당 상품의 id, name, price 등을 json형식에 담아 보내주는 예시이다. 이처럼 간편하게 가져와서 사용할 수 있는 것을 알 수 있는데, 이를 통해 필터링이나 검색을 할 때 유용하게 사용할 수 있다.","link":"/2020/11/01/django-querystring/"},{"title":"Docker의 기본","text":"Docker란 ? 컨테이너 기반의 오픈소스 가상화 플랫폼. 프로세스를 격리시켜서 사용하는 방식이기 때문에 가볍고 빠르며 하나의 서버에 여러 개의 컨테이너를 실행해도 서로 영향을 미치지 않고 독립적으로 실행되어 가벼운 VM을 사용하는 느낌을 준다. Container VS VM 기존의 VM(Virtual Machine)에서의 가상화 방식은 호스트 OS 위에 게스트 OS 전체를 가상화하여 사용하는 방식이었다. 여러가지 OS들을 가상화하여 사용할 수 있었지만 무겁고 느려서 운영환경에서는 사용할 수 없었다. 이를 개선하기 위해 프로세스를 격리하는 방식이 등장하게 되었는데 이 방식이 바로 컨테이너 방식이다. 마치 가벼운 VM을 실행하는 느낌을 주며 컨테이너에 터미널로 접속하여 명령어도 입력이 가능하며 패키지도 물론 설치가 가능하고 여러 개의 프로세스를 백그라운드로 실행할 수 도 있다. 컨테이너를 새로 만드는 데 걸리는 시간은 겨우 1 ~ 2초 밖에 걸리지 않아 기존의 가상머신들과 비교해서 월등히 빠른 성능을 보여준다. Image도커에서 이미지는 컨테이너 실행에 필요한 파일과 설정 값 등을 포함하고 있는 것으로 상태 값을 가지지 않고 변하지 않는다. 컨테이너는 이미지를 실행한 상태라고 볼 수 있으며 추가되거나 변하는 값은 컨테이너에 저장된다. 즉, 컨테이너 실행을 위한 모든 정보를 가지고 있기 때문에 그 이상의 파일을 설치하거나 할 필요가 전혀 없다. 이미지 하나만 있으면 ubuntu든 mysql이든 컨테이너를 손쉽게 생성할 수 있게 된다. Image layer 보통 Image 하나 당 수 백 메가(MB)에 이르는데, 기존 Image에 파일 하나 추가했다고 새로 생성한다면 매우 비효율 적일 것이다. 도커에서는 이러한 문제를 해결하기 위해 레이어(layer)라는 개념을 사용하고 있다.예를 들어 기존의 ubuntu 이미지가 A + B + C 로 이루어져 있다면 이를 베이스로 만든 nginx의 이미지는 A + B + C + nginx가 된다. 즉, 기존 레이어를 제외한 새로운 레이어만 받으면 되기 때문에 효율적인 이미지 관리가 가능하다. 컨테이너를 생성할 때도 마찬가지로 레이어 방식을 사용하는데 기존의 이미지 레이어를 올린 후 그 위에 읽기/쓰기 레이어를 추가함으로써 컨테이너가 실행 중에 생성하는 파일이나 변경한 내용 등은 읽기/쓰기 레이어에 저장되므로 여러 개의 컨테이너를 생성해도 최소한의 용량만 사용하게 된다. Dockerfile이미지를 만들어 관리하면서 불편한 점이 생기게 되는데 해당 이미지가 어떤 목적으로 만든 이미지였는지 기억하기 어렵게 되어버린다. 그래서 도커에서는 이미지를 만들기 위해 Dockerfile이라는 파일에 자체 DSL언어를 이용하여 이미지 생성 과정을 적어 관리함으로써 누구나 쉽게 이미지 생성 과정을 보며 수정할 수 있게 된다. Docker Hub도커 이미지들은 보통 수 백 메가(MB)에서 많게는 수 기가(GB)가 넘는 경우도 흔하다. 이러한 이미지들을 서버에 저장하고 관리하는 것은 쉽지 않은데 도커에서는 Docker Hub를 통해 공개 이미지를 무료로 관리해준다. 쉬운 Command와 API도커 클라이언트의 커맨드 명령어는 잘 만들어져 있어서 직관적이고 사용하기 쉽다. 또한 http 기반의 RestAPI도 지원하여 확장성이 좋다.","link":"/2021/03/23/docker-001/"},{"title":"ORM 개념","text":"ORM이란? ORM이란 객체(Object)와 관계형 데이터베이스(Relational Database)의 데이터를 매핑(Mapping)해주는 것을 의미django에서는 ORM을 통해 sql 쿼리문을 쓰지 않고도 데이터베이스의 데이터를 다룰 수 있다. ORM의 장점 불필요하게 SQL문을 길게 적지 않아도 되어 빠르게 개발이 가능하다. 자동으로 처리해주기 때문에 개발자가 신경 쓸 부분이 줄어든다. 유지보수가 편하고 코드의 재사용이 가능해진다. ORM의 단점 SQL을 쓰면 어떤 곳이든 통용되지만 ORM은 해당 프로그래밍 언어마다 ORM 라이브러리를 따로 배워야한다. 규모가 크거나 복잡한 프로젝트의 경우 SQL로 작성하는 것이 좋을 수도 있다.","link":"/2020/10/15/django-orm-001/"},{"title":"Django","text":"Django란? 파이썬(Python)으로 만들어진 웹 애플리케이션 프레임워크(Framework) Framework VS Library Framework : 소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합 특정 프로그램을 개발하기 위해 여러 요소들과 메뉴얼 등을 제공해준다. 미리 틀이 짜여있기 때문에 라이브러리에 비교하면 수동적, 제한적이고 각각의 목적에 맞는 프레임워크를 사용해야된다. Library : 단순 활용이 가능한 도구들의 집합 필요할 기능이 있을 때마다 프레임워크에 비해 능동적으로 가져와서 사용할 수 있다. 원하는 용도에 맞게 필요할 때 사용할 수 있는 도구와 같은 개념이다. MVT란? MVT란 Django에서 기본적으로 사용되는 디자인 패턴이다.일반적인 Framework에서는 보통 M(model), V(view), C(controller)로 유명하다.Django에서는 V가 Template, C가 View로 치환되어 사용된다. 왜 굳이 이렇게 나뉘었을까?예전에 PHP, ASP, JSP로 웹을 개발하던 시절에는 모델, 디자인, SQL 처리 로직 등을 모두 한 곳에 모아서 개발을 했었다.하지만 이러한 방식은 프로젝트가 커지면 커질수록 여러 문제가 발생하였고 이를 해결하고자 만들어졌다.웹 어플리케이션을 개발하는 데에 있어서 영역을 크게 위와 같은 3가지로 나눈 것이다.이를 통해 독립적으로 개발할 수 있게 되었고 협업에 유리해졌다.","link":"/2020/09/22/django/"},{"title":"[JavaScript] filter 메소드","text":"Filter 메소드란? filter() 메소드는 배열의 각 요소에 대해 주어진 조건이 True인 경우의 요소만 모아 새로운 배열로 반환한다. 만약 어떤 요소도 조건에 부합하지 않는다면 빈 배열을 반환한다.아래 예시를 보자. 12345var number = [1, 2, 3, 4, 5]const result = number.filter(num =&gt; num % 2 === 0);console.log(result) [출력결과] number 배열에서 해당 배열의 모든 요소에 대해 2로 나누었을때 나머지가 0인 경우, 즉 짝수인 경우만 반환하게한 예제이다. 참고 : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter","link":"/2020/10/06/filter-js/"},{"title":"Docker 설치와 명령어","text":"Docker 설치하기 도커 홈페이지에 접속하여 Get Docker를 클릭하면 쉽게 다운받아 설치할 수 있다. 제대로 설치가 되었는지 확인하려면 터미널을 키고 docker --version을 입력해보자. Docker 편하게 사용하기Docker를 편하게 사용하기 위해 추가적인 설치를 해보자.mac에서 zsh를 사용하고 있기 때문에 여기에 맞게 설치할 것이다. 도커 command-line completion을 참고했다. 아래 명령어 입력 12mkdir -p ~/.zsh/completion$ curl -L https://raw.githubusercontent.com/docker/compose/1.16.1/contrib/completion/zsh/_docker-compose &gt; ~/.zsh/completion/_docker-compose zsh 설정 파일을 편집기로 열기 1vim ~/.zshrc 아래 명령어 추가 12345678plugins=( ... docker docker-compose)fpath=(~/.zsh/completion $fpath)autoload -Uz compinit &amp;&amp; compinit -i zsh 다시 시작 1exec zsh 제대로 설치되었다면 아래와 같이 탭을 누르면 사용할 수 있는 옵션들에 대해 설명이 표시되게 된다. Docker 명령어Docker 정보 조회 docker info 설치된 Docker에 대해 자세히 알고 싶을 때 사용하는 명령어이다. 컨테이너 목록을 확인하기 docker ps [OPTIONS] 실행 중인 컨테이너 중지하기 docker stop [OPTIONS] CONTAINER [CONTAINER ID] 컨테이너의 ID를 알면 해당 컨테이너를 중지시킬 수 있다. 컨테이너 제거하기 docker rm [OPTIONS] CONTAINER [CONTAINER ID] 마찬가지로 컨테이너의 ID를 알면 해당 컨테이너를 제거할 수 있다. 이미지 목록 확인하기 docker images [OPTIONS] 이미지 다운로드 하기 docker pull [OPTIONS] NAME[:TAG] 이미지 삭제하기 docker rmi [OPTIONS] IMAGE [IMAGE ID] 컨테이너 로그 보기 docker logs [OPTIONS] CONTAINER 컨테이너에 접근하기 docker exec [OPTIONS] CONTAINER [ARG...] 현재 실행중인 ubuntu에 접근한다고 가정하면 아래와 같이 입력하면 된다.터미널을 사용하는 것과 같이 접근이 가능해서 자유롭게 명령어를 실행하고 심지어 패키지도 설치할 수 있다. 1docker exec -it ubuntu /bin/bash","link":"/2021/03/23/docker-002/"},{"title":"Docker Compose","text":"Docker Compose앞서 도커(Docker)가 무엇인지 도커 내에 어떤 기능들이 있는지 보았다. Docker의 기본Docker 설치와 명령어Docker 컨테이너 수명 &amp; 지속적인 데이터 이제 도커 CLI 명령어를 통해 이미지를 만들고 컨테이너를 띄우고 불륨에 영구적으로 데이터를 저장시킬 수 있게 되었으며 DockerFile을 통해 파일 하나로 내 입맛대로 설정할 수 있게 되었다. 도커를 통해 내가 원하는 환경들을 쉽게 구성할 수 있게 된 것이다. 이제 이렇게 올린 컨테이너 안에 내가 만든 애플리케이션을 올린다고 생각해보자. 보통 하나의 애플리케이션에는 여러 개의 서비스로 이루어져 있는데, 이를 하나의 YAML파일에 정의하여 실행할 수 있도록 하는게 Docker Compose다. compose는 보통 3가지의 단계로 이루어진 프로세스를 가진다. DockerFile은 어디서나 환경을 구성할 수 있도록 앱의 환경을 정의한다. Docker Compose는 DockerFile로 만들어진 환경에서 함께 실행할 수 있도록 앱을 구성하는 서비스를 정의한다. docker compose up 명령을 하면 앞의 과정들이 실행되게 된다. Docker Compose 파일 구성하기1234567891011121314version: &quot;3&quot; # 버전 지정services: # 서비스 정의 servicename: # 서비스 이름 지정 image: # 사용할 이미지 command: # 컨테이너 안에서 작동하는 명령어 지정 environment: # docker run 명령어에서 -e 옵션과 같다. volumes: # docker run 명령어에서 -v 옵션과 같다. ports: sevicename2: # ....volumes: # docker volume create 명령어와 같다. 불륨을 정의한다.networks: # docker network create 명령어와 같다. 네트워크를 정의한다. 도커 파일자체를 지정해서 빌드할 수 도 있다. 12345services: servicename: bulid: context: dockerfile: Docker Compose 장점 및 사용사례위와 같이 Docker Compose를 이용하면 개발 환경을 컨테이너화 하여 언제 어디에서든 Docker만 설치하면 해당 파일을 통해 어플리케이션을 띄우고 개발을 시작할 수 있게 되어 매우 편리해진다. 환경을 설정하는데 들이는 리소스들을 도커 하나로 해결할 수 있게 되며 이는 개발에 좀 더 집중할 수 있게 해준다. 또한 모두가 동일한 환경으로 세팅되는 것을 보장받기 때문에 개발 환경 차이로 인해 생기는 알 수 없는 미묘한 문제들을 사전에 방지할 수 있다. 또한 테스트를 할 때도 용이한데 compose 파일을 정의하여 자동화된 테스트 환경을 구성할 수 있다.","link":"/2021/04/07/docker-004/"},{"title":"Flask 시작하기","text":"Flask란? 파이썬(Python)으로 작성된 마이크로 웹 프레임워크BSD 라이선스이기 때문에 자유롭게 사용할 수 있다. Django에 비해 심플하고 가볍다.심플하지만 핵심적인 기능을 갖추고 있기 때문에 많은 사람들에게 Django와 더불어 많이 사용되는 프레임워크이다. 출처 : Flask란? Flask 실행하기Hello World!를 출력하는 단순한 웹 애플리케이션을 만들어 보자. Flask의 설치나 가상환경 세팅 등은 Flask의 공식 문서에 잘 설명되어 있다. 해당 부분은 생략하도록 하겠다. 참고 : Flask 공식 문서 app.py를 생성하여 아래의 코드를 입력해보자. 1234567891011from flask import Flaskapp = Flask(__name__)@app.route('/')def hello(): return 'Hello World!'if __name__=='__main__': app.run() 위의 파일이 있는 곳에서 아래 명령어를 실행한다. 1flask run 다음 그림과 같이 실행되는 것을 확인할 수 있다. 해당 주소로 들어가면 Hello World!를 출력하고 있는 화면을 볼 수 있다. Django와 Flask이처럼 단 몇줄의 코드만으로 웹 애플리케이션을 실행할 수 있는 것을 알 수 있다. 주로 Django와 많이 비교되는데, Django는 웹 애플리케이션을 만들기 위해 하나의 뼈대를 모두 제공해준다고 하면 Flask는 뼈대 하나하나 내가 직접 쌓아가는 느낌이 강하다. Django는 그런 면에서 개발을 할 때 신경 써야 될 부분을 줄일 수 있다는 장점이 있지만 사용되지 않는 부분이 있을 수 있다. 때문에 전체를 이해하지 못해도 개발을 할 수 있다는 것이므로 그런 부분에서는 위험할 수 있다고 생각한다. 반면에 Flask는 내가 직접 하나하나 필요한 것들을 찾아서 쌓아가기 떄문에 코드 하나하나를 확실히 내가 직접 컨트롤 한다는 느낌을 갖게 한다.군더더기가 없는 깔끔한 코딩이 가능할 것이다. 하지만 뼈대가 없기 때문에 중구난방으로 코드가 짜여질 수 있고 제공되어 지는 것이 없기 때문에 필요한 기능이 생길 때마다 일일이 찾아야 하는 불편함이 있을 수 있다고 생각한다.","link":"/2020/11/29/flask-001/"},{"title":"Github 개인 계정 &amp; 회사 계정 따로 관리하기","text":"Git config 수정의 번거로움이전에 개인 깃헙 계정으로만 깃을 쓸 때는 몰랐는데 회사 깃헙 계정도 같이 쓰게 되니 매번 push 할 때마다 git config를 수정해야 하는 것이 너무 귀찮고 번거로웠다. 어떻게 방법이 없을까 하고 생각만 하다가 이번에 방법을 찾아내서 적용해보았다. 잊지 않기 위해 기록해둔다. 1. SSH 키 분리터미널을 켜고, 홈 디렉토리로 이동 1$ cd ~ .ssh 디렉토리 생성 후 chmod로 권한 설정 123$ mkdir ~/.ssh$ chmod 700 ~/.ssh$ cd .ssh your email에 깃헙 메일 주소를 입력한다. 1$ ssh-keygen -t rsa -b 4096 -C &quot;your email&quot; 개인용과 회사용 두 개의 key를 만들어야 하는데Enter file in which to save the key (/Users/daphne/.ssh/id_rsa): 뒤에 개인용으로 id_rsa 회사용으로 id_rsa_work를 입력하여 비밀번호를 입력 후 각각 생성해준다. 1234Generating public/private rsa key pair.Enter file in which to save the key (/Users/daphne/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again: 키 생성이 정상적으로 되었다면 ls -l을 사용하면 확인이 가능하다.아래 명령어를 입력해 생성한 공개 키를 복사해서 깃헙에 등록하자.ssh-rsa 부터 your email 부분까지 모두 복사한다. 1234$ cat ~/.ssh/`id_rsa.pub`ssh-rsa~~~your email 이제 github로 가서 Settings 클릭 SSH and GPG keys 클릭 New SSH key 클릭 개인용 SSH 키와 회사용 SSH 키를 각각의 깃헙 계정에 등록한다. 2. .gitconfig &amp; .ssh/config 설정하기vi 에디터를 이용해 ~/.ssh/config 파일을 연다. 1$ vim ~/.ssh/config HostName은 깃헙에서 repo를 클론할때 SSH 주소 부분의 git@github.com에서 github.com을 의미한다.IdentityFile 뒤에 생성했던 key를 연결한다. 1234567891011# companyHost github.com-work HostName github.com User git IdentityFile ~/.ssh/id_rsa_work# daphneHost github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa vi 에디터를 이용해 .gitconfig을 수정한다. 1vim ~/.gitconfig [user] 부분에는 전역적으로 사용할 계정을 입력한다. 나는 전역적으로 사용할 계정으로 개인 계정을 입력했다.회사용 작업 폴더를 만들어서 관리하고 싶었기에 work라는 폴더를 만들었다.[includeIf &quot;gitdir:~/work/&quot;]에 아까 만든 폴더의 경로인 work/를 설정해 놓으면 해당 폴더 아래에서는 설정했던 SSH가 적용된다. 반드시 폴더명 뒤에 /를 붙여야한다.마지막으로 path 부분에 아까 설정한 SSH의 Host를 입력하면 된다. 12345[user] name = your github name email = your email[includeIf &quot;gitdir:~/work/&quot;] path = .gitconfig-work 이제 설정이 모두 끝났다. 3. git clone 하기이제 git clone을 통해 받을 때 .ssh/config에서 설정한 Host를 이용한다. 개인 계정으로 받을 때 git clone git@github.com/repository_name.git으로 받는다. 회사 계정으로 받을 때 git clone git@github-luna.com/repository_name.git으로 받는다. 이제 work 폴더 아래의 폴더에서 git config user.name이나 git config user.email을 입력해보면 설정했던 회사용 깃헙 계정의 정보가 나올 것이고 work 폴더 밖에서 받은 것은 개인용 깃헙 계정 정보가 나올 것이다.","link":"/2021/04/15/git-config-file/"},{"title":"[WEB] GET과 POST의 차이","text":"GET 방식 URL에 데이터를 포함시켜 요청한다. 전송하는 길이에 제한이 있다.(주소 + 파라미터 포함 최대 255자 HTTP/1.1의 경우 2048자) 데이터를 Header에 포함하여 전송한다. URL에 데이터가 포함되어 보안에 취약하다. 캐싱할 수 있다. POST 방식보다 빠르다. POST 방식 URL에 데이터를 노출시키지 않고 요청한다. 데이터를 Body에 포함시킨다. Body에 데이터를 넣기 때문에 데이터가 노출되지 않아서 보안상 안전하다. 많은 양의 데이터를 전송하기에 적합하다.(용량 제한 존재) 캐싱할 수 없다. GET vs POSTGET은 가져오는 것이고 POST는 수행하는 것이다.GET 방식은 주로 조회(Select)하는 용도로 이용(서버의 데이터나 상태를 변경시키지 않는다.) POST는 저장, 삭제, 수정 등을 서버에 요청할 때 사용한다.","link":"/2020/07/28/get-vs-post/"},{"title":"Git flow, GitHub flow, GitLab flow","text":"Git을 더 잘쓰기 위한 방법Git flow, GitHub flow, GitLab flow 모두 Git을 더 잘 써먹기 위한 방법들을 이야기한다. 어떻게 하면 대규모 프로젝트들을 더 깔끔하게 관리할 수 있을지를 고민하다 탄생한 것들이다. 특별한 기술이라기 보다도 Git을 관리하기 위한 전략이라고 표현하는게 맞는 표현이다. Git flowGit flow 방식은 Vincent Driessen(A successful Git branching model)가 제안한 방식으로 아래 그림과 같이 이루어지는 방식이다. 그림만 이해해도 Git flow에 대한 이해가 다 됐다고 봐도 된다. 그림의 각 브랜치 마다의 역할을 살펴보자 master : 배포되었거나 지금 당장 배포를 해도 문제없는 소스가 저장된 브랜치 develop : 다음 배포를 위해 개발을 진행하는 브랜치 master 브랜치와 develop 브랜치는 항상 remote repository에 유지되는 브랜치이다. master 브랜치는 보통 배포할 때마다 태그를 달아줘서 관리를 한다.develop 브랜치는 개발자들이 각각 자신의 로컬에 브랜치를 따로 생성해서 개발을 진행한 후 해당 개발이 완료가 되면 develop 브랜치에 push 혹은 PullRequest 요청을 해서 merge 하는 루틴으로 개발이 진행된다. feature branch : 기능 단위 개발이 진행되는 브랜치 hotfixs branch : 배포했던 버전에 문제가 생겨서 긴급한 수정이 필요할 떄 그런 개발이 진행되는 브랜치 release branch : 내부적으로 어느정도 개발이 되었다고 판단되어 배포할 준비가 된 소스가 저장되는 브랜치 Git flow가 대규모 프로젝트에서는 적합할지 모르지만 대다수의 프로젝트에서는 굳이 필요없는 절차까지 준수하도록 해서 생산성을 떨어뜨린다는 의견이 나오게 되었고 그렇게 탄생한 것이 GitHub flow와 GitLab flow다 GitHub flow master 브랜치는 항상 최신의 상태를 유지하며 stable하다. 이는 항상 배포가 가능하다는 의미이다.GitHub flow에서는 feature나 develop 브랜치 같은 것이 존재하지 않는다. 만약 작업을 위해 브랜치를 따야한다면 작업하는게 무엇인지 명확히 알 수 있도록 브랜치 명을 작성한다.CI가 필수적이며, 배포를 자동으로 진행할 수 있다.GitHub flow에서는 PullRequest 기능을 권장한다. 이를 통해 코드 리뷰를 하기 위해서 이다.Git flow에 비해 간단한 구조로 되어있어서 비교적 신속하게 배포를 수행할 수 있다. GitLab flow production 브랜치는 Git flow에서의 master 브랜치와 같은 역할을 한다. GitLab flow에서의 master 브랜치는 production 브랜치로 병합한다.이를 통해 production 브랜치에서 릴리즈된 코드가 항상 프로젝트의 최신 버전 상태를 유지해야할 필요가 없게 한다. Git flow와 GitHub flow의 각각의 장점을 절충한 것 같은 느낌이 든다.","link":"/2021/01/18/git-flow-github-flow-gitlab-flow/"},{"title":"Docker Container lifetime &amp; Persistent Data","text":"Docker에서 컨테이너를 생성하고 컨테이너에 쓰여진 데이터들은 컨테이너를 삭제하면 기본적으로 같이 사라지게 된다. 기껏 생긴 데이터들이 없어진다는 것이다. 데이터를 영구히 보존시키기 위해 Docker에서는 두 가지의 방법을 제시하고 있다. Docker Volume과 bind mount이다. Docker Volume 불륨(volume)은 Docker 컨테이너에서 생성하고 사용하는 데이터를 유지하기 위한 방법 중 하나이다. 또다른 방법인 바인딩 마운트와 비교되는데 바인딩 마운트는호스트 시스템의 디렉토리 구조와 OS에 따라 달라지지만 불륨은 이와 별개로 Docker에 의해 완전히 관리된다. Docker CLI 명령어를 통해 쉽게 생성이 가능하다. Volume의 장점 불륨은 바인드 마운트에 비해 백업 또는 마이그레이션이 쉽다. Docker CLI나 Docker API를 사용해 불륨을 관리할 수 있다. 불륨은 Linux 및 Windows 컨테이너에서 모두 작동한다. 여러 컨테이너 간에 불륨을 사용할 떄 보다 안전하게 공유가 가능하다. CLI를 통해 불륨 드라이버를 사용하면 불륨의 세부적인 설정이 가능해지는데 원격 호스트 또는 클라우드 공급자에 불륨을 저장하고 불륨의 내용을 암호화하거나 다른 기능을 추가할 수 있다. 새 불륨은 컨테이너로 컨텐츠를 미리 채울 수 있다. Docker Desktop의 불륨은 Mac 및 Windows 호스트의 바인드 마운트보다 훨씬 높은 성능을 제공한다. Bind Mount 바인드 마운트를 사용하면 호스트의 파일 또는 디렉토리가 컨테이너에 마운트된다. 파일 또는 디렉토리는 호스트의 절대 경로로 참조된다. 이게 무슨 소리냐면 호스트 시스템, 예를 들어 Mac OS 환경의 시스템에서 /test 라는 파일 경로가 있다고 할 때 여기 안에 test_file.txt 라는 파일을 생성하고 해당 경로로 마운트를 했다고 하면 해당 컨테이너 터미널을 열어서 똑같은 경로로 들어가서 확인해보면 test_file.txt가 존재하는 것을 확인할 수 있다. 물론 그 반대도 가능하다. Volume VS Bind MountVolume과 Bind Mount의 가장 큰 차이점은 Docker가 관리를 해주는가 안해주는가의 차이이다. 불륨을 사용하면 컨테이너나 이미지와 같이 Docker를 통해 관리를 할 수 있다는 장점이 있다. 때문에 대부분의 경우 불륨으로 생성해서 사용하지만 로컬에서 개발을 할 때 간혹 이런 특징을 이용해야할 때가 있는데 예를 들어 보통 개발을 하면 로컬에서 작업을 하게 되는데 만약 컨테이너로 올려서 확인해야한다면 코드를 수정할 때마다 매번 컨테이너로 올리는 불편함이 생길 것이다. 개발하는 작업 디렉토리를 바인드 마운트해주면 코드를 변경할 때마다 실시간으로 컨테이너에서도 확인이 가능해진다. 번외 tmpfs Mount 앞서 말한 두 가지 옵션 외에 Linux에서만 사용 가능한 옵션이 하나 있는데, tmpfs Mount이다.tmpfs Mount는 영구히 저장되는 것이 아니라 임시적으로 호스트 메모리에서만 지속되고, 컨테이너를 내리면 tmpfs Mount가 제거되고 메모리에서 있었기 때문에 사라지게 된다. 일반적으로 거의 쓰이지않는 옵션이지만 호스트나 컨테이너에서 파일을 임시로 저장할 필요가 있을 때 유용할 수 있다. tmpfs 마운트의 한계 불륨이나 바인드 마운트와 달리 컨테이너 간에 tmpfs Mount를 공유할 수 없다. Linux에서 도커를 실행하는 경우에만 사용할 수 있다.","link":"/2021/04/06/docker-003/"},{"title":"Git 기본 1","text":"Git이란?git 공식 홈페이지에서 git에 대해 설명한 내용이다. Git 공식 홈페이지 Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. 쉽게 말하면 프로젝트 파일의 변경 사항을 추적하는 시스템인데 이러한 Git을 통해 개발자들은 프로젝트의 변경 사항을 기록하고, 특정 시점의 버전으로 언제든 돌아갈 수 있게 되었다. 이러한 Git은 협업할 때 더욱 효과가 극대화 되는데 각각의 개발자가 각기 다른 프로젝트 버전을 본인 컴퓨터에 갖게 하여 개발을 진행한 후 이러한 개별 버전의 프로젝트들을 Git을 통해 병합하여 기준이 되는 버전의 프로젝트에 적용하는 것이 쉽게 가능해졌다. 즉, Git을 사용함으로써 체계적인 개발이 가능해지게 되었다. Git 설치하기Git 다운로드 링크 자신이 사용하는 OS에 맞는 것을 선택해 설치하면 된다.설치를 마쳤다면 터미널 혹은 CMD에서 아래의 커맨드를 입력해보자. 1git --version Git이 정상적으로 설치되었다면, 설치되어 있는 Git 버전이 표시된다. Repositories(저장소)Git에서는 repository라는 용어가 있다.Git repository는 Git으로 관리하는 프로젝트 저장소이다.프로젝트를 저장하는 하나의 폴더라고 보면 된다. Git repository는 크게 두 가지 종류가 있다. Local repository : 본인의 컴퓨터에 저장된 로컬 버전의 프로젝트 저장소 Remote repository : 외부(원격 서버)에 있는 외부 버전의 프로젝트 저장소 보통 Local repository에 Remote repository의 프로젝트를 가져와서 수정 및 개발을 하고 Remote repository에 로컬에서 작업한 사항들을 병합하고 변경 사항을 적용한다. 기본적인 Git 명령어1. 이름 및 이메일 설정12git config --global user.name &quot;이름&quot;git config --global user.email &quot;이메일&quot; 2. Initilizing a repositoryGit으로 프로젝트 관리를 시작하려면 프로젝트 폴더로 와서 다음 명령어를 입력하면 된다. 1git init 이 명령어는 프로젝트 내에 숨겨진 .git 디렉토리를 생성하는데 이제 Git은 현재 저장소에 대해 모든 변경사항을 추적/관리할 수 있게 된다. 3. Staging 및 상태 확인하기Git에서는 모든 파일이 크게 Git이 추적중인 파일과 아닌 파일로 나뉜다.Git에서는 다른 버전 관리 도구와 다른 Staging Area라는 공간이 있다. 모든 파일은 항상 Staging Area라는 중간 단계를 거쳐서 변경사항이 저장소에 커밋이 된다. 이를 통해 얻는 유용한 점이 있는데 일부분만 커밋할 떄 충돌을 해결할 때 커밋을 다시할 때 프로젝트를 하다보면 일부분만 커밋을 하고 싶을 때도 있을 수 있다.만약 커밋을 했는데 충돌이 났을 경우 Staging Area를 확인하면 어떤 파일이 충돌했는지 바로 알 수 있다.커밋을 했는데 커밋한 것이 마음에 안들어서 다시 수정하고 커밋할 떄도 유용하다. repository의 현재 상태를 확인하려면 다음 명령어를 입력하면 된다. 1git status 해당 명령어를 통해 어떤 파일이 변경되었는지, 어떤 파일이 추가되었는지를 모두 알 수 있다.또한 Git으로 관리되고 있는 파일인지 아닌지도 알 수 있다. 4. Staging files(Staging area에 파일 추가하기)특정 파일 하나만 추가하기 1git add test.js 여러 개의 파일 한 번에 추가하기 1git add test.js test1.js test2.js 모든 파일을 한 번에 추가하기 1git add . 해당 명령어는 프로젝트 폴더 내의 모든 파일과 폴더를 Staging area에 추가하고 커밋을 남길 수 있게 해준다. 5. 커밋 남기기커밋은 특정 시간의 코드 스냅샷의 형태로 해당 repository의 커밋 기록에 남게 된다.git add 명령어를 통해 Staging area에 추가된 파일들만 커밋 대상이 된다. 1git commit -m &quot;Commit message&quot; 큰 따옴표 안에 남기고 싶은 커밋 메시지를 작성하면 된다. git에서는 git add와 git commit을 하는 프로세스를 반복한다. 6. Commit history프로젝트의 모든 커밋 내용을 보려면 다음 명령어를 입력하면 된다. 1git log 각 커밋에 대한 자세한 정보를 담고 있다. (작성자, hash 값, 날짜와 시간, 커밋메시지) 특정 커밋 시점의 코드로 되돌리려면 다음 명령어를 입력하면 된다. 1git checkout &lt;commit-hash&gt; git log에서 돌아가고 싶은 커밋의 hash 값을 넣어주면 된다. 7. Ignoring filesgit에서 관리하지 않아도 되는 파일이 있다면 .gitignore파일을 프로젝트 폴더에 생성하면 된다..gitignore파일 안에 해당하는 파일명과 폴더 명을 나열하면 된다.(각각의 파일 및 폴더가 새로운 줄에 입력되어야 한다.) 123456789// 예시.DS_**.loglogs**/*.backup.***/*.back.*node_modulesbower_components","link":"/2020/10/02/git/"},{"title":"[WEB] HTTP","text":"HTTP란? HTTP : HyperText Transfer Protocol의 약자컴퓨터들끼리 HTML파일을 주고 받을 수 있도록 하는 약속 HyperTextHTTP에서 HyperText라는 단어는 어디서 많이 들어본 친숙한 단어일 것이다.HTML(HyperText Markup Language)의 HyperText와 동일한 의미를 가진다.HTML은 웹페이지를 만들기 위해서 웹브라우저 위에서 동작하는 언어를 뜻한다.HTML로 만든 페이지를 어떻게 주고받을 수 있을까? Transfer사전적 의미로 전송하다라는 의미를 가진다.우리가 만든 웹사이트를 다른 사람들과 공유하기 위해 다른 컴퓨터에 전송할 수 있어야한다.전송은 보내는 주체와 받는 주체가 있다. Protocol프로토콜이란 협약, 통신규약이라는 의미를 가진다.어떻게 물리적으로 떨어진 컴퓨터끼리 HTML파일(HyperText)을 주고 받을지에 대한 약속이다. HTTP의 특징HTTP는 크게 두 가지의 특징을 가지고 있다. 1. Request/Response(요청/응답) HTTP의 통신의 핵심은 요청과 응답이다. 보내는 주체가 받는 주체에게 요청을 보냄 받는 주체는 보낸 주체에게 잘받았다는 응답을 보냄 2. Stateless State(상태) + less(없음) 각각의 HTTP 통신은 독립적이기 때문에 과거의 통신에 대한 내용을 전혀 알지 못한다. 항상 통신할 때마다 필요한 모든 정보를 담아서 요청을 보내야 한다.비유를 하자면 이미 자기소개를 했는데, 같은 사람에게 계속해서 똑같은 내용으로 자기소개를 해야하는 것과 같다. 이러한 Stateless를 항상 인지하고 있어야 한다. 쇼핑몰 사이트를 예로 들면 로그인을 했을 때 로그인 정보가 로그아웃 전까지 필요하다. 매 번 가져올 수는 없으니 로그인 토큰 또는 브라우저의 쿠키, 세션, 로컬스토리지 같은 기술이 이러한 이유로 인해 만들어졌다. Request/ResponseHTTP에서의 Request와 Response 메시지의 구조는 크게 세 부분으로 구성되어 있다. 1. Request 메세지 구조 Start Line : 요청의 첫 번째 줄에 해당한다. HTTP Method : 해당 요청이 의도한 액션을 정의하는 부분, 주로 GET, POST, DELETE가 많이 쓰임 Request target : 해당 requset가 전송되는 목표 url HTTP Version : HTTP 버전, 주로 1.1 버전이 널리 쓰임 GET /login HTTP/1.1해석 : GET 메소드로 login이라는 요청 타겟에 HTTP 1.1 버전으로 요청을 보낸다는 의미 Headers : 해당 요청에 대한 추가 정보(메타 데이터)를 담고있는 부분Key:Value 값으로 되어있다. Headers : {Host : 요청을 보내는 목표(타겟)의 주소. 즉, 요청을 보내는 웹사이트의 기본 주소가 된다 (ex. www.apple.co.kr)User-Agent : 요청을 보내는 클라이언트의 대한 정보 (ex. chrome, firefox, safari, explorer)Content-Type : 해당 요청이 보내는 메세지 body의 타입 (ex. application/json)Content-Length : body 내용의 길이Authorization : 회원의 인증/인가를 처리하기 위해 로그인 토큰을 Authroization에 담는다} Body : 해당 요청의 실제 내용. 주로 Body를 사용하는 메소드는 POST이다. ex) 로그인 시에 서버에 보낼 요청의 내용Body : {“user_email”: “daphne01215@gmail.com““user_password”:”1234”} 2. Response 메세지 구조 Start Line : 응답의 상태 줄. 응답은 요청에 대한 처리상태를 클라이언트에게 알려주면서 내용을 시작한다. HTTP Version : 요청의 HTTP버전과 동일 Status Code : 응답 메세지의 상태 코드 Status Text : 응답 메세지의 상태를 간략하게 설명해주는 텍스트 HTTP/1.1 404 Not Found해석 : HTTP 1.1 버전으로 응답했고, 프론트엔드에서 보낸 요청에 대해서 해당하는 URL을 찾을 수 없기 때문에 404 상태 메시지를 보냄 HTTP/1.1 200 SUCCESS해석 : HTTP 1.1 버전으로 응답했고, 프론트엔드에서 보낸 요청에 대해서 성공했기 때문에 200 상태 메시지를 보냄 Headers : 요청의 헤더와 동일하다. 응답에 대한 추가 정보(메타 데이터)를 담고 있고, 차이가 있다면 응답에서만 사용하는 헤더의 정보들이 있다.(ex. server 헤더) Body : 요청의 Body와 일반적으로 동일하다. 응답의 형태에 따라 데이터 전송이 필요없을 때에는 Body가 없을 수도 있다. 가장 많이 사용되는 Body의 데이터 타입은 JSON(JavaScript Object Notation)이다. ex) 로그인 요청에 대해 성공했을 때 응답 내용Body : {“message”: “SUCCESS”“token”:”1asvasbk21124@an2bjas” (암호화된 유저 정보)} HTTP Request MethodsHTTP 통신에서 주로 사용되는 메소드인 GET, POST, DELETE에 대해 소개한다. 1. GET 어떤 데이터를 서버로 부터 받아올 때 사용하는 메소드 데이터를 받아오기만 할 떄 사용됨 2. POST 데이터를 생성/수정할 때 주로 사용되는 메소드 데이터를 생성/수정할 떄 사용되기 때문에 대부분의 경우 body가 포함되서 보내짐 3. DELETE 특정 데이터를 삭제할 때 사용되는 메소드 참고 : GET vs POST Response Status Codes200 : OK 가장 자주 보게되는 Status Code 문제없이 요청에 대한 처리가 백엔드 서버에서 이루어지고 나서 오는 응답코드 201 : Created 무언가가 잘 생성되었을 때 오는 Status Code 대게 POST메소드의 요청에 따라 백엔드 서버에 데이터가 잘 생성 또는 수정되었을 때에 보내는 코드 400 : Bad Request 해당 요청이 잘못되었을 때 보내는 Status Code 주로 요청의 Body에 보내는 내용이 잘못되었을 때 사용되는 코드 401 : Unauthorized 유저가 해당 요청을 진행하려면 먼저 로그인을 하거나 회원가입이 필요하다는 의미 403 : Forbidden 유저가 해당 요청에 대한 권한이 없다는 뜻 접근 불가능한 정보에 접근했을 경우 표시되는 코드 404 : Not Found 요청된 URL이 존재하지 않는다는 의미 500 : Internal Server Error 서버가 에러 났을 떄 Status Code 보통 서버에 문제가 있을 때 표시되는 코드","link":"/2020/09/21/http/"},{"title":"Github Actions","text":"Github Actions란?Github Actions는 Github 저장소를 기반으로 소프트웨어 개발 Workflows를 자동화 할 수 있는 도구입니다. CI/CD를 포함해 여러 작업들을 수행할 수 있습니다. 여기서 말하는 CI는 테스트와 빌드를 자동으로 할 수 있다는 의미이며 CD는 서버에 배포를 자동으로 할 수 있다는 의미입니다. Github Actions 공식 문서 Github Actions 장점 Github 저장소에 함께 포함되어 있기 때문에 CI를 위한 서버가 따로 필요없다. YAML 파일만으로도 설정이 가능하기 때문에 간편하고 쉽다. 다른 사람들이 만든 여러 Workflow들을 사용할 수 있다. 다른 CI/CD 도구와의 차이점주로 많이 쓰이는 CI/CD 도구로는 Jenkins가 있는데 이와 비교해보면 Jenkins는 별도의 서버를 구축해야하기 때문에 상대적으로 초기 구축 과정이 힘들지만 구축만 해놓으면 서버 운영 비용을 제외하면 비용이 무료입니다. Github Actions는 별도의 서버가 필요하지 않지만 private 저장소를 이용할 경우 과금이 발생할 수 있습니다. 사용 한도 Workflow는 저장소 하나당 최대 20개까지 등록 가능 Workflow 안에 존재하는 Job 단위 당 최대 6시간 동안 실행가능, 초과 시 자동으로 중지 public 저장소는 무료이며 private 저장소는 과금 발생 Github Free는 한 달에 500MB 스토리지와 실행 시간 2,000분까지 제공 Github Pro는 한 달에 1G 스토리지와 실행 시간 3,000분까지 제공자세한 사용료는 다음 참고: Github Actions 사용료 Workflow 시작Workflow를 만들고자 하는 저장소의 Actions로 가서 만들 수 있다.Github가 해당 저장소를 분석해서 적절히 제공하는 Workflow 템플릿를 이용하거나 다른 사용자들이 만들어서 Github 마켓플레이스에 공유한 것을 가져와서 쓰는 방법이 있다. 직접 Workflow를 만들 수 도 있다. YAML 파일 구성다음은 yml 파일 예시이다. 12345678910111213141516171819202122name: CI on: push: branches: [ master ] pull_request: branches: [ master ] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Run a one-line script run: echo Hello, world! - name: Run a multi-line script run: | echo Add other actions to build, echo test, and deploy your project. name: Workflow 이름 지정 1name: CI on: 해당 Workflow가 어떤 이벤트에 대해서 실행할 건지 지정할 수 있다. push나 pull_request 같은 이벤트와 crontab 같은 반복 스케줄도 사용할 수 있다. 12345on: push: branches: [master] pull_request: branches: [master] jobs 1234567891011121314jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Run a one-line script run: echo Hello, world! - name: Run a multi-line script run: | echo Add other actions to build, echo test, and deploy your project. 하나의 Workflow는 다양한 Job으로 구성됩니다. 여러 Job이 있을 경우, 병렬로 실행됩니다. build 밑으로 작업 OS를 설정하고 여러 steps을 차례로 진행시키는 구조입니다. 이미 만들어진 액션을 uses에 등록해서 사용할 수 있습니다.자세한 설정 방법은 여기를 참고하면 좋습니다. 간단한 테스트 자동화 예시Github Action을 이용하여 간단하게 NestJS 테스트를 자동화하는 예시입니다. NestJS로 프로젝트 생성 후 Github 저장소에 올리기 Actions로 들어가서 워크플로우를 직접 생성하기 YAML 파일 작성하기 Workflow 이름 및 트리거 지정123456name: PR일 때만 테스트on: pull_request: branches: - test # test라는 브랜치에 PR 올릴 시 동작 name으로 Workflow 이름을 정하고 Workflow를 실행할 트리거를 지정한다.위의 경우 test라는 브랜치에 PR을 올릴 경우에만 동작하게 된다. Job 이름 &amp; OS 환경 지정하기123jobs: build-test: runs-on: ubuntu-latest job이름을 build-test로 지정해준다. 나중에 해당 이름이 쓰이므로 기억해두자.runs-on을 통해 OS환경을 지정한다.ubuntu-latest OS환경에서 job이 동작하게 된다. Node 설치하기123456steps: - uses: actions/checkout@v2 - name: Setup Node uses: actions/setup-node@v1 with: node-version: '14.x' actions/checkout@v2를 사용해 Github 저장소에 있는 코드들을 가져옵니다.actions/setup-node@v1을 사용해 node를 설치합니다. 버전은 14.x입니다. npm 설치 및 테스트 실행하기12345- name: npm install run: npm install- name: test start run: npm run test:cov npm 설치 후 NestJS 프로젝트 package.json에 설정되어 있는 npm run test:cov 명령어를 통해 테스트를 실행합니다. If 테스트 실패 시12345678910111213141516171819- name: if fail uses: actions/github-script@v4.0.2 with: github-token: ${{ secrets.GITHUB_TOKEN }} script: | const ref = &quot;${{github.ref}}&quot; const pull_number = Number(ref.split(&quot;/&quot;)[2]) await github.pulls.createReview({ ...context.repo, pull_number, body:&quot;테스트코드를 다시 확인해주세요.&quot;, event: &quot;REQUEST_CHANGES&quot; }) await github.pulls.update({ ...context.repo, pull_number, state: &quot;closed&quot; }) if: failure() # 해당 명령어를 추가하면 이전 step에서 실패 했을 경우에만 이 step이 동작하게 됨 만약 위의 테스트가 실패하였을 경우 해당 step이 실행되게 됩니다.actions/github-script는 Github actions를 javascript 코드를 통해 제어할 수 있는 액션 툴 입니다.필요한 파라미터 값인 github-token은 위와 같이 고정하면 기본적으로 현재 저장소에 지정되어 있는 저장소 bot용 github-token이 지정되게 됩니다. 12const ref = &quot;${{github.ref}}&quot;;const pull_number = Number(ref.split(&quot;/&quot;)[2]); pull request number 가져오기 123456await github.pulls.createReview({...context.repo,pull_number,body: &quot;테스트코드를 다시 확인해주세요.&quot;,event: &quot;REQUEST_CHANGES&quot;,}); 리뷰 생성하기테스트코드를 다시 확인해주세요. 라는 메시지가 자동으로 생성됩니다. 12345await github.pulls.update({ ...context.repo, pull_number, state: &quot;closed&quot;,}); merge 못하도록 Closed 하기 전체 코드아래는 전체 실행 코드입니다. 123456789101112131415161718192021222324252627282930313233343536373839404142name: PR일 때만 테스트on: pull_request: branches: - test # test라는 브랜치에만 PR 올릴 시 동작jobs: build-test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Setup Node uses: actions/setup-node@v1 with: node-version: '14.x' - name: npm install run: npm install - name: test start run: npm run test:cov - name: if fail uses: actions/github-script@v4.0.2 with: github-token: ${{ secrets.GITHUB_TOKEN }} script: | const ref = &quot;${{github.ref}}&quot; const pull_number = Number(ref.split(&quot;/&quot;)[2]) await github.pulls.createReview({ ...context.repo, pull_number, body:&quot;테스트코드를 다시 확인해주세요.&quot;, event: &quot;REQUEST_CHANGES&quot; }) await github.pulls.update({ ...context.repo, pull_number, state: &quot;closed&quot; }) if: failure() # 해당 명령어를 추가하면 이전 step에서 실패 했을 경우에만 이 step이 동작하게 됨 merge closed를 하기 위해 branch rule 설정하기 Settings에 Branches에서 방금 설정했던 job이름인 build-test를 설정한다. 여기까지 했다면 test 브랜치에 PR을 할 때마다 Github actions가 동작하고 만약 테스트 코드가 실패할 경우 테스트코드를 다시 확인해주세요.라는 메시지가 표시되며 merge를 못하도록 PR이 closed 될 것이다.","link":"/2021/06/16/github-action-001/"},{"title":"Git 기본 2","text":"해당 글은 아래의 글과 이어지는 글입니다.Git 기본 1 Branch란? 독립적으로 어떤 작업을 진행하기 위한 개념 각각의 브랜치는 다른 브랜치의 영향을 받지 않기 때문에 여러 작업을 동시에 진행할 수 있다. 보통 프로젝트를 진행할 때 다음과 같이 진행한다. 메인 브랜치에서 자신의 작업 전용 브랜치 생성 작업 전용 브랜치에서 작업을 진행 작업이 끝나면 메인 브랜치에 자신의 브랜치의 변경 사항을 적용 이렇게 함으로써 작업 단위. 즉, 브랜치로 그 작업의 기록을 남기게 되므로 문제가 발생했을 경우 원인이 되는 작업을 찾거나 대책을 세우기 쉬워진다. 저장소를 처음 만들면 Git은 master라는 이름의 브랜치를 만들어 둔다. Branch 생성하기새로운 브랜치를 생성하려면 아래의 명령어를 입력하면 된다. 1git branch &lt;new-branch-name&gt; Branch 전환하기다른 브랜치로 이동하려면 아래의 명령어를 입력하면 된다. 1git checkout &lt;branch-name&gt; 브랜치를 생성함과 동시에 바로 해당 브랜치로 이동하고 싶을 떄는 아래의 명령어를 입력하면 된다. 1git checkout -b &lt;branch-name&gt; Branch 확인하기프로젝트에 존재하는 모든 브랜치를 확인하고 싶다면 아래의 명령어를 입력하면 된다. 1git branch Branch 병합하기A라는 브랜치에서 작업한 내용을 B라는 브랜치에 적용하고 싶을 때, 브랜치 A와 브랜치 B를 병합(merge) 할 수 있다. 현재 브랜치를 병합하고자 하는 다른 브랜치와 병합할 수 있다. 1git merge &lt;branch-name&gt; Branch 삭제하기브랜치를 삭제하는 명령어이다.작업이 끝난 후 master 브랜치에 병합까지 마친 뒤에 현재 브랜치가 필요하지 않을 때 사용한다. 1git branch -d &lt;branch-name&gt;","link":"/2020/10/03/git2/"},{"title":"[JavaScript] template literal","text":"간단 요약 Literal : 정보를 표현하는 방법, 기호 template literal: ` ` 을 사용해서 하나의 문자열처럼 사용가능하고 그 안에서 줄바꿈 가능 따로 줄바꿈 \\n 을 사용하지 않아도 된다는 장점 변수: ${ } 로 표현 참고 : JavaScript template literals","link":"/2020/08/10/javascript-001/"},{"title":"[JavaScript] Hoisting","text":"Hoisting이란?함수 안에 있는 선언들을 모두 끌어올려서 해당 함수 유효 범위의 최상단에 선언하는 것 자바스크립트 함수는 실행되기 전에 함수 안에 필요한 변수값들을 미리 다 모아서 선언한다.함수를 실행하기 전에 전체적으로 한 번 훑고 난 다음 실행한다고 생각하면 이해하기 쉽다. 1234567891011121314151617181920var myName = &quot;daphne&quot;;function printName() { console.log(myName); // undefined var myName = &quot;daphne&quot;; console.log(myName); // daphne function inner() { console.log(myName); // undefined myName = &quot;inner_daphne1&quot;; console.log(myName); // inner_daphne1 var myName = &quot;inner_daphne2&quot;; console.log(myName); // inner_daphne2 } inner();}console.log(printName()); 결과undefineddaphneundefinedinner_daphne1inner_daphne2undefined ← printName() 함수의 return 값이 없기 때문 첫 번째 출력문에서는 처음에 myName을 var변수로 선언했지만 printName() 함수 안에 myName이 선언되어 있기 때문에 무시당하고 함수 안의 myName이 적용된다. 하지만 printName() 안에서 myName이 선언되기 전에 myName을 출력했으므로 undefined가 나온다. 두 번째 출력문에서는 printName()함수 안에서 var myName =&quot;daphne&quot;로 선언하였고 그 뒤 출력하였으므로 daphne가 나온다. 세 번째 출력문에서는 첫 번째 출력문과 마찬가지로 inner() 함수 안의 myName이 선언되기 전이므로 undefined가 나온다. 네 번째 출력문에서는 myName = &quot;inner_daphne1&quot;으로 선언한 뒤 출력이므로 inner_daphne1가 나온다. 다섯 번째 출력문에서는 myName이 var myName = &quot;inner_daphne2&quot;로 재선언 하였으므로 inner_daphne2가 나온다. 마지막의 undefined는 printName()함수의 return을 지정하지 않아서 값이 없기 때문에 undefined가 출력된다. 참고 : Hoisting","link":"/2020/08/17/javascript-002/"},{"title":"[JavaScript] 함수 선언문과 함수 표현식","text":"함수 선언문과 함수 표현식의 특징함수 선언문과 함수 표현식은 둘 다 함수를 정의할 때 쓰이는 방식이다. 함수 선언문은 function 정의부만 존재하고 별도의 할당 명령이 없다. 12function a() {} // 함수 선언문 방식a(); // 정상 실행 반면 함수 표현식은 정의한 function을 별도의 변수에 할당하는 것을 말한다. 이 때, 정의한 함수의 이름이 없다면 익명 함수 표현식이라고 하고 이름이 있다면 기명 함수 표현식이라고 한다. 123456var b = function () {}; // 익명 함수 표현식b(); // 정상 실행var c = function d() {}; // 기명 함수 표현식c(); //정상 실행d(); // 에러 발생 기명 함수 표현식은 주의할 점이 있다. 함수명으로 함수를 호출할 수 없다는 점이다. 그렇다면 호출도 할 수 없는데 왜 함수명을 쓰는 걸까? 함수명을 사용함으로써 디버깅에 유리해진다. 함수 선언문 vs 함수 표현식함수 선언문을 사용할 경우 생길 수 있는 위험성에 대해 알아보자. 123456789101112131415function sum(x, y) { return x + y;}var c = sum(1, 2);console.log(c); // 103function sum(x, y) { return x + y + 100;}var d = sum(1, 2);console.log(d); // 103 위의 코드의 경우 어떤 결과가 출력으로 나올까?c가 3으로 나오고, d가 103으로 나오도록 의도했을 지 모른다. 하지만 결과는 c가 103, d도 103이 나오게 된다. 왜 이러한 현상이 발생되는 이유는 호이스팅 때문인데, 전역 컨텍스트가 활성화될 때 전역공간에 선언된 함수들이 모두 가장 위로 끌어올려 지게 된다. 이 때 나중에 할당한 값이 먼저 할당한 값을 덮어씌우기 때문에 마지막에 선언된 함수로 호출이 되게 된다. 함수 표현식으로 정의하면 이러한 문제를 해결할 수 있다. 123456789101112131415var sum = function (x, y) { return x + y;};var c = sum(1, 2);console.log(c); // 3var sum = function (x, y) { return x + y + 100;};var d = sum(1, 2);console.log(d); // 103","link":"/2021/01/11/javascript-003/"},{"title":"[LeetCode] Longest Palindromic Substring","text":"풀이 1234567891011121314151617181920212223242526272829303132var longestPalindrome = function (s) { let answer = &quot;&quot;; let answerLen = 0; let l = 0; let r = 0; for (let i = 0; i &lt; s.length; i++) { l = i; r = i; // odd while (l &gt;= 0 &amp;&amp; r &lt; s.length &amp;&amp; s[l] == s[r]) { if (r - l + 1 &gt; answerLen) { answer = s.slice(l, r + 1); answerLen = r - l + 1; } l -= 1; r += 1; } l = i; r = i + 1; // even while (l &gt;= 0 &amp;&amp; r &lt; s.length &amp;&amp; s[l] == s[r]) { if (r - l + 1 &gt; answerLen) { answer = s.slice(l, r + 1); answerLen = r - l + 1; } l -= 1; r += 1; } } return answer;}; 출처 : leetcode 알고리즘 연습https://leetcode.com/problems/longest-palindromic-substring/","link":"/2021/01/07/leetcode-001/"},{"title":"[LeetCode] Add Two Numbers","text":"풀이 12345678910111213141516171819202122232425var addTwoNumbers = function (l1, l2) { let result = new ListNode(0); let node = result; let prev = 0; while (l1 || l2) { const val1 = l1 ? l1.val : 0; const val2 = l2 ? l2.val : 0; const sum = prev + val1 + val2; const value = sum % 10; prev = parseInt(sum / 10); node.next = new ListNode(value); node = node.next; l1 = l1 ? l1.next : null; l2 = l2 ? l2.next : null; } if (prev) { node.next = new ListNode(prev); } return result.next;}; 출처 : leetcode 알고리즘 연습https://leetcode.com/problems/add-two-numbers/","link":"/2021/01/08/leetcode-002/"},{"title":"[LeetCode] Two Sum","text":"풀이 12345678910var twoSum = function (nums, target) { const dic = {}; for (let i = 0; i &lt; nums.length; i++) { if (target - nums[i] in dic) { return [dic[target - nums[i]], i]; } dic[nums[i]] = i; }}; 출처 : leetcode 알고리즘 연습https://leetcode.com/problems/longest-palindromic-substring/","link":"/2021/01/09/leetcode-003/"},{"title":"[JavaScript] 클로저(Closure)","text":"클로저(Closure)란 ? 어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우, 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지 않는 현상이다. 렉시컬 환경(Lexical Environment)클로저에 대한 개념을 이해하기 위해서는 렉시컬 환경(Lexical Environment)에 대한 이해가 필요하다.자바스크립트에서는 실행 중인 함수, 코드 블록 {...}, 스크립트 전체는 렉시컬 환경이라 불리는 내부 숨김 연관 객체를 갖는다. if 문, for 문 등에서 사용되는 코드 블록도 이에 해당된다. 렉시컬 환경 객체는 두 부분으로 구성된다. 환경 레코드(Environment Record) : 모든 지역 변수를 프로퍼티로 저장하고 있는 객체, this값과 같은 기타 정보도 여기에 저장된다. 외부 렉시컬 환경(Outer Lexical Environment)에 대한 참조 : 외부 코드와 연관됨 코드를 통해 알아보자. 변수 phrase는 특수 내부 객체인 환경 레코드의 프로퍼티라고 할 수 있다.변수를 가져오거나 변경하는 것은 환경 레코드의 프로퍼티를 가져오거나 변경함을 의미한다. 위의 코드에는 렉시컬 환경이 하나만 존재하는데, 이렇게 스크립트 전체와 관련된 렉시컬 환경은 전역 렉시컬 환경(Global Lexical Environment)라고 한다. 전역 렉시컬 환경은 외부 참조를 갖지 않기 때문에 null을 가리키는 것을 알 수 있다. 이번엔 좀 더 긴 코드를 살펴보자. 우측의 네모 상자들은 코드가 한 줄, 한 줄 실행될 때마다 전역 렉시컬 환경이 어떻게 변화하는지 보여준다. 처음 스크립트가 시작되면 스크립트 내에서 선언한 변수 전체가 렉시컬 환경에 올라간다. 이때 변수의 상태는 uninitialized가 되는데 자바 스크립트 엔진은 해당 상태의 변수를 인지는 하지만 바로 밑의 let을 만나기 전까지는 이 변수를 사용할 수 없다. let phrase 선언은 했지만 값을 할당하지는 않았기 떄문에 undefined 상태이다. Hello가 할당된 상태 Bye로 값이 변경된 상태 여기서 짚고 넘어가야할 점이 하나 있는데 렉시컬 환경은 이론적으로 존재하는 공간이기 때문에 실제 자바스크립트 코드를 통해 직접 접근하거나 조작하는 행위는 불가능하다. 함수 선언문에서의 렉시컬 환경함수 선언문으로 선언한 함수는 일반 변수와는 달리 바로 초기화된다.이 말은 함수 선언문으로 선언한 함수는 렉시컬 환경이 만들어지는 즉시 사용할 수 있다는 말이다. 변수의 경우 let을 만나 선언이 될 때까지 사용할 수 없는 것과 달리 말이다. 위 그림을 보면 선언되기 전에도 say가 함수임을 인지하고 있음을 확인할 수 있다.단, 이런 방식은 함수 선언문의 경우만 적용이 된다.아래와 같이 함수 표현식과 같은 경우 해당되지 않는다. let say = function(name)... 내부와 외부에서의 렉시컬 환경함수를 호출하여 실행하면 새로운 렉시컬 환경이 자동으로 만들어진다.해당 렉시컬 환경에서는 함수 호출 시 넘겨받은 매개변수와 함수 안의 지역 변수가 저장된다. 아래의 코드를 살펴보자 say(&quot;John&quot;)을 호출하게 되면 두 개의 렉시컬 환경을 갖게 되는데, 내부 렉시컬 환경과 외부 렉시컬 환경이다. 내부 렉시컬 환경은 호출 중인 함수인 say를 위해 만들어져서 매개변수로 받은 name 값을 갖게 된다. 이 내부 렉시컬 환경은 외부 렉시컬 환경을 가리키는데 여기에서는 전역 렉시컬 환경을 가리키고 있다. say 함수에서 alert가 실행될 때 name은 이미 내부 렉시컬 환경 내에 있기 때문에 넘어가게 되고 phrase 값을 찾을 수 없어서 내부 렉시컬이 가리키고 있는 외부 렉시컬 환경으로 접근해서 phrase 값을 찾게 된다. 이렇게 내부 렉시컬 환경에서 찾을 수 없는 값을 외부 렉시컬 환경에 접근하여 찾는데, 이러한 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 때까지 반복된다. 반환 함수에서의 렉시컬 환경 makeCounter()을 호출하면 호출할 때마다 새로운 렉시컬 환경 객체가 만들어진다. 그리고 이 객체엔 makeCounter를 실행하는데 필요한 변수들이 저장된다. 위 그림을 보면 내부 렉시컬 환경과 전역 렉시컬 환경이 만들어지는 것읕 볼 수 있다. 실행 흐름이 makeCounter 함수 내부의 함수까지 오게되면 내부 렉시컬 환경을 하나 더 만들게 되고 그 안에서 count 변수를 찾는다. 하지만 없기 때문에 참조 중인 makeCounter 함수의 렉시컬 환경으로 가서 찾는다.count 변수를 찾게 되고 0을 반환해주게 된다. 그 후 실행이 종료되면 아래 그림과 같이 count 값을 1 증가 시킨 상태가 된다. counter()를 여러 번 호출하면 count 변수가 2, 3으로 증가하는 이유가 이 떄문이다. 가비지 컬렉션함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거되게 된다.단, 해당 렉시컬 환경이 다른 렉시컬 환경으로부터 참조되고 있는 상태라면 여전히 메모리에 유지되게 된다. 결론클로저라는 개념은 말로 설명하기도 이해하기도 두루뭉술한 느낌의 개념이다. 하지만 클로저는 자바스크립트에서 중요한 개념으로 클로저의 특성을 이용해 코드를 작성한 것을 이해하고 자유자재로 다룰려면 꼭 알아두어야 한다. 앞서 말한대로 클로저란 어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우, 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지 않는 현상이다. 그 이유는 내부 렉시컬 환경에서 찾을 수 없는 변수를 외부 렉시컬 환경에서 찾아서 참조하고 있기 때문이다. 내부함수를 외부로 전달하는 방법에는 함수를 return하는 경우뿐만 아니라 콜백으로 전달하는 경우도 포함된다. 클로저는 그 특성상 메모리를 계속 차지하는 개념이므로 사용이 끝난 클로저에 대해서 메모리를 관리에 주의해줄 필요가 있다. 이 글은 모던 자바스크립트 - 클로저를 참고해서 쓴 글입니다.","link":"/2021/01/13/javascript-004/"},{"title":"NestJS 소개","text":"Nest(NestJS) 란 ? Nest는 Node.js 서버 측 애플리케이션을 구축하기 위한 프레임 워크로 TypeScript로 빌드되고 OOP(Object Oriented Programming), FP(Functional Programming) 및 FRP(Functional Reactive Programming)을 지원합니다. Nest의 장점JavaScript 생태계에서 프론트엔드 측에서는 Angular, React, Vue와 같은 프레임 워크들이 생겨나면서 생산성이 증가하고 빠르게 구축이 가능하게 되었다. 하지만 백엔드 측에서는 Node.js를 비롯해 훌륭한 라이브러리나 도구 등이 많이 있지만 아키텍처에 대한 문제를 해결해주는 것이 없었다. Node.js 특성상 자유로운 개발로 인해 초기 시작할 때는 쉽고 빠르게 개발할 수 있지만 규모가 커지면 커질수록 테스트, 확장성 부분에서 문제가 발생하게 된다. 이를 해결하기 위해 Nest가 탄생하게 되었다. Nest는 아키텍처에 대해 Angular에서 크게 영감을 받아 만들어졌으며 테스트가 용이하고 확장성이 좋은 프레임 워크이다. 또한 TypeScript를 적극 도입하여 안정적이다. 내부적으로 Nest는 Express를 사용하지만 Fastify와 같은 다양한 라이브러리와의 호환성을 제공해 수많은 외부 플러그인을 쉽게 사용할 수 있다. Nest 사용 후기NestJS는 단순히 CLI 명령어 만으로 프로젝트를 생성하고 컨트롤러, 서비스, 모듈 등을 쉽게 생성할 수 있다. Jest도 지원해주기 때문에 테스트도 용이하다. 웹개발에 필요한 요소들은 미리 다 준비되어있는 느낌이었고 비록 영어로 되어있지만 공식 문서를 찾아보면 어떻게 사용하는지 쉽게 알 수 있다. NestJS를 알기 전에는 Node.js로 바닥부터 시작해 구조를 잡고 필요한 것이 생길 때마다 추가하는 그런 방식으로 했었다. 매번 기능을 추가할 때마다 일일이 폴더 생성을 하는 불편함은 물론, 개발을 하면 할수록 코드가 복잡해지고 덕지덕지 붙여진 코드가 되어갔던 기억이 있는데, NestJS 없이는 이제 안될 것 같다. 만약 Node.js로 개발을 해본 경험이 있다면 빨리 써보는 것을 추천해본다. 국내 기업에서도 NestJS를 많이 사용하게 되었으면 좋겠다.","link":"/2021/04/09/nest-001/"},{"title":"[JavaScript] map 메소드","text":"Map 메소드란? map() 메소드는 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환한다. map() 메소드는 자바스크립트에서 배열의 메소드 중 하나인데 이를 이용해 새로운 배열을 반환한다는게 중요한 포인트이다. 아래 예시를 보자. 12345const number = [1, 2, 3, 4, 5];const multiplyTwoNums = number.map((num) =&gt; num * 2);console.log(multiplyTwoNums); [출력결과] number 배열을 가져와서 map() 메소드를 사용하여 배열 내의 모든 요소에 대해 num * 2한 결과를 모아 새로운 multiplyTwoNums라는 배열로 반환하는 것을 볼 수 있다.결과를 보면 배열 형태로 저장되는 것을 알 수 있다. 참고 : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map","link":"/2020/10/05/map-js/"},{"title":"[Node.js] URL을 통해 입력된 값 사용하기","text":"*이 글은 생활코딩 WEB2 Node.js를 기반으로 쓰여진 글입니다.생활코딩 Node.js 쿼리스트링(query string)쿼리스트링은 사용자가 웹 프로그램으로 입력 데이터를 전달하는 가장 단순하고 널리 사용되는 방법이다. 예를 들어http://A.com/blog 이라는 웹사이트가 있다면 http://A.com/blog?id=1id=1 부분이 쿼리스트링이다. 소스코드main.js 123456789101112131415161718var http = require(&quot;http&quot;);var fs = require(&quot;fs&quot;);var url = require(&quot;url&quot;);var app = http.createServer(function (request, response) { var _url = request.url; var queryData = url.parse(_url, true).query; console.log(queryData.id); if (_url == &quot;/&quot;) { _url = &quot;/index.html&quot;; } if (_url == &quot;/favicon.ico&quot;) { return response.writeHead(404); } response.writeHead(200); response.end(queryData.id);});app.listen(3000); main.js를 실행시키면 주소에 입력된 쿼리스트링에 따라 웹페이지에 결과가 나오는 것을 볼 수 있다.","link":"/2020/07/30/nodejs-001/"},{"title":"[Node.js] 파일 읽기","text":"*이 글은 생활코딩 WEB2 Node.js를 기반으로 쓰여진 글입니다.생활코딩 Node.js 소스코드fileread.js 1234var fs = require(&quot;fs&quot;);fs.readFile(&quot;sample.txt&quot;, &quot;utf8&quot;, function (err, data) { console.log(data);}); sample.txt Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. fileread.js 를 실행시키면sample.txt의 내용이 출력되게 된다.","link":"/2020/07/30/nodejs-002/"},{"title":"[Node.js] 파일목록 알아내기","text":"*이 글은 생활코딩 WEB2 Node.js를 기반으로 쓰여진 글입니다.생활코딩 Node.js 소스코드readdir.js 123456var testFolder = &quot;./data&quot;;var fs = require(&quot;fs&quot;);fs.readdir(testFolder, function (error, filelist) { console.log(filelist);}); readdir.js 를 실행시키면data 폴더안에 있는 파일들의 이름들이 배열에 담겨서 출력되게 된다.","link":"/2020/07/30/nodejs-003/"},{"title":"[Node.js] 기본적인 Jest 사용법 1","text":"이전 글 : Jest란?출처 : Jest 공식 문서 Using MatchersJest의 Matchers를 활용하여 다양한 방식으로 값들을 테스트해보자 Common Matchers값을 테스트 하기 위한 가장 기본적인 방법은 값이 정확히 일치하는지 확인하는 것이다. 값이 일치하는지 확인하는 기본적인 방법 중 하나인 toBe()이다. toBe() 123test(&quot;1 더하기 1은 2이다.&quot;, () =&gt; { expect(1 + 1).toBe(2);}); toBe()와 비슷한 것 같지만 정확한 동등성을 테스트하려면 toEqual을 쓰는 것이 더 좋다.toBe() 보다는 toEqual을 사용하도록 하자. toEqual() 12345test(&quot;객체 안에 값이 추가되는 것에 대한 테스트&quot;, () =&gt; { const data = { one: 1 }; data[&quot;two&quot;] = 2; expect(data).toEqual({ one: 1, two: 2 });}); 일치하지 않음을 확인하는 not.toBe()이다. 보통은 값이 정확히 일치하는 가의 여부를 판단하는 경우가 더 많기 때문에 마찬가지로 toEqual을 사용하도록 하자. not.toBe() 123test(&quot;1 더하기 1은 3이 아니다&quot;, () =&gt; { expect(1 + 1).not.toBe(3);}); Truthiness값이 Truthy한지 Falsy 한지 판단하기 위해 쓰이는 Matcher들이다.상황에 맞게 정확히 일치하는 Matcher을 사용하자. 1234567891011121314151617test(&quot;null&quot;, () =&gt; { const n = null; expect(n).toBeNull(); expect(n).toBeDefined(); expect(n).not.toBeUndefined(); expect(n).not.toBeTruthy(); expect(n).toBeFalsy();});test(&quot;zero&quot;, () =&gt; { const z = 0; expect(z).not.toBeNull(); expect(z).toBeDefined(); expect(z).not.toBeUndefined(); expect(z).not.toBeTruthy(); expect(z).toBeFalsy();}); Number숫자를 비교할 때 쓰이는 Matcher들이다. 1234567891011test(&quot;two plus two&quot;, () =&gt; { const value = 2 + 2; expect(value).toBeGreaterThan(3); expect(value).toBeGreaterThanOrEqual(3.5); expect(value).toBeLessThan(5); expect(value).toBeLessThanOrEqual(4.5); // toBe와 toEqual로도 숫자를 비교할 수 있다. expect(value).toBe(4); expect(value).toEqual(4);}); 주의 부동 소수점의 경우 toBe()를 사용하지 말고 toEqual을 사용해야 한다. String문자열을 비교하는 Matcher이다. 타겟인 문자열이 포함되어 있지 않음을 확인할 때 사용하는 not.toMatch이다. not.toMatch() 123test(&quot;Javascript 단어 안에는 B가 없다.&quot;, () =&gt; { expect(&quot;Javascript&quot;).not.toMatch(/B/);}); 타겟인 문자열이 포함되어 있음을 확인할 때 사용하는 toMatch이다. toMatch() 123test(&quot;Javascript 단어 안에는 a가 있다.&quot;, () =&gt; { expect(&quot;Javascript&quot;).toMatch(/a/);}); Array &amp; iterables배열 또는 이터러블한 값에 특정 값이 포함되어 있는지 확인할때 toContain이다. 1234test(&quot;배열 안에 apple이 있는지 확인하는 테스트&quot;, () =&gt; { const array = [&quot;test&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;kiwi&quot;, &quot;beer&quot;, &quot;paper&quot;]; expect(array).toContain(&quot;apple&quot;);});","link":"/2020/11/22/nodejs-006/"},{"title":"[Node.js] 동기와 비동기","text":"*이 글은 생활코딩 WEB2 Node.js를 기반으로 쓰여진 글입니다.생활코딩 Node.js 간단 요약동기(Sync) : 순차적으로 일을 끝내는 방식비동기(Async) : 해야할 일을 위임하고 기다리는 방식 Synchronous vs Asynchronous동기적으로 일을 처리한다는 것은 어떤 일을 처리하고 그 일이 끝난 뒤에 다음 일을 처리하는 것이다. 즉, 순차적으로 처리하는 방식. 만약 특정 일을 처리하는데 굉장히 오래 걸리는 일이 있다면 해당 작업이 끝날 때까지 다음 작업이 기다리게 된다. 비동기적으로 일을 처리한다는 것은 수행되고 있는 어떤 일이 끝날 때까지 기다리는 것이 아닌 컴퓨터에 일을 부여하고 다음 일을 수행하는 것이다. 예시sample.txt 파일 내용 동기적 방식 1234567var fs = require(&quot;fs&quot;);// readFileSyncconsole.log(&quot;A&quot;);var result = fs.readFileSync(&quot;./sample.txt&quot;, &quot;utf8&quot;);console.log(result);console.log(&quot;C&quot;); 결과AB C fs.readFileSync 함수는 동기적 방식으로 파일을 읽는다.때문에 해당 작업이 끝나고 나서 다음 작업이 진행되는 순차적인 방식으로 진행된다. 비동기적 방식 1234567var fs = require(&quot;fs&quot;);console.log(&quot;A&quot;);fs.readFile(&quot;./sample.txt&quot;, &quot;utf8&quot;, function (err, result) { console.log(result);});console.log(&quot;C&quot;); 결과AC B fs.readFile 함수는 비동기적 방식으로 파일을 읽는다.때문에 해당 작업이 끝나는 것과 관계없이 바로 다음 작업이 가능하다.","link":"/2020/08/03/nodejs-004/"},{"title":"[Node.js] 기본적인 Jest 사용법 3","text":"이전 글 : 기본적인 Jest 사용법 2출처 : Jest 공식 문서 Jest에서 테스트 환경 설정하기Jest에서는 테스트를 수행하기 전이나 테스트를 수행하고 난 뒤의 동작을 설정해둘 수 있다. beforEach &amp; afterEachbeforEach와 afterEach는 테스트를 실행할 때마다 동작한다.beforEach는 테스트 전에 동작하고,afterEach는 테스트 후에 동작한다. 예를 들어 데이터베이스에 접근하여 특정 이름이 있는지 확인하는 함수를 테스트한다고 가정해보자.테스트를 할 때마다 데이터베이스를 연결하고 테스트가 끝나면 연결을 닫아야 할 것이다. 123456789101112131415beforEach(() =&gt; { connectUserDatabase();});afterEach(() =&gt; { closeUserDatabase();});test(&quot;user database에서 홍길동 찾기&quot;, () =&gt; { expect(User(&quot;홍길동&quot;)).toEqual(&quot;홍길동&quot;);});test(&quot;user database에서 김철수 찾기&quot;, () =&gt; { expect(User(&quot;김철수&quot;)).toEqual(&quot;김철수&quot;);}); beforeAll &amp; afterAllbeforeAll은 테스트가 시작하기 전 단 한 번 실행된다.afterAll은 모든 테스트가 끝난 후 실행된다. 만약 테스트하는 동안 데이터베이스를 항상 열어두어야 한다고 한다면 아래 코드처럼 될 것이다. 123456789101112131415beforAll(() =&gt; { return connectUserDatabase();});afterAll(() =&gt; { return closeUserDatabase();});test(&quot;user database에서 홍길동 찾기&quot;, () =&gt; { expect(User(&quot;홍길동&quot;)).toEqual(&quot;홍길동&quot;);});test(&quot;user database에서 김철수 찾기&quot;, () =&gt; { expect(User(&quot;김철수&quot;)).toEqual(&quot;김철수&quot;);}); describe 블록으로 범위 지정하기before과 after블록 들은 파일의 모든 테스트에 적용되지만 describe 블록을 사용하면 해당 블록 안에서만 적용이 되도록 그룹화 할 수 있다. 123456789101112131415161718192021222324beforEach(() =&gt; { connectUserDatabase();})afterEach(() =&gt; { closeUserDatabase();})test('user database에서 홍길동 찾기', () =&gt; { expect(User('홍길동')).toEqual('홍길동')})describe('test find user', () =&gt; { beforEach(() =&gt; { connectUserDatabase(); }) afterEach(() =&gt; { closeUserDatabase(); }) test('user database에서 김철수 찾기', () =&gt; { expect(User('김철수')).toEqual('김철수')}) jest에서의 실행순서jest에서는 정해진 우선 순위에 따라 먼저 실행되는 블록들이 있다.아래의 순서대로 실행된다. 12345678910111213141516171819202122232425beforeAll(() =&gt; console.log(&quot;1 - beforeAll&quot;));afterAll(() =&gt; console.log(&quot;1 - afterAll&quot;));beforeEach(() =&gt; console.log(&quot;1 - beforeEach&quot;));afterEach(() =&gt; console.log(&quot;1 - afterEach&quot;));test(&quot;&quot;, () =&gt; console.log(&quot;1 - test&quot;));describe(&quot;Scoped / Nested block&quot;, () =&gt; { beforeAll(() =&gt; console.log(&quot;2 - beforeAll&quot;)); afterAll(() =&gt; console.log(&quot;2 - afterAll&quot;)); beforeEach(() =&gt; console.log(&quot;2 - beforeEach&quot;)); afterEach(() =&gt; console.log(&quot;2 - afterEach&quot;)); test(&quot;&quot;, () =&gt; console.log(&quot;2 - test&quot;));});// 1 - beforeAll// 1 - beforeEach// 1 - test// 1 - afterEach// 2 - beforeAll// 1 - beforeEach// 2 - beforeEach// 2 - test// 2 - afterEach// 1 - afterEach// 2 - afterAll// 1 - afterAll","link":"/2020/11/29/nodejs-008/"},{"title":"[Node.js] Jest","text":"Jest란 ? Facebook에서 만든 Javascript 테스트 프레임 워크이다. 간단한 설치만으로 테스트 코드를 작성할 수 있다. 출처 : Jest 공식 문서 Jest의 편리함 기존의 Javascript 테스트 라이브러리들은 Test Runner, Test Mathcher, Test Mock과 같이 여러가지 테스팅용 라이브러리들을 혼합해서 사용하는 불편함이 있었다. Jest에서는 이 모든 것을 한 번에 제공해 주기 때문에 사용하기 편리하다. Jest 설치하기Jest 설치프로젝트를 폴더를 생성하고 아래 명령어를 통해 jest를 설치한다. 12npm init -ynpm i -D jest package.json 파일 수정package.json 파일을 열고 test의 값을 jest로 수정한다. 123&quot;scripts&quot;: { &quot;test&quot;: &quot;jest&quot;} 기본적인 테스트 코드 작성하기간단한 sum 함수를 테스트 해보자. 먼저 sum.js 파일을 만들어 아래와 같이 입력한다. 12345function sum(a, b) { return a + b;}module.exports = sum; 테스트를 하기위해 sum.test.js 파일을 만들어 아래와 같이 입력한다. 123456const { TestScheduler } = require(&quot;jest&quot;);const sum = require(&quot;./sum&quot;);test(&quot;sum function test : adds 1 + 2 to equal 3&quot;, () =&gt; { expect(sum(1, 2)).toEqual(3);}); 다음 명령어를 입력하면 테스트가 실행된다. 1npm test 성공적으로 테스트가 통과되었음을 알 수 있을 것이다.","link":"/2020/11/22/nodejs-005/"},{"title":"[Node.js] Prisma CRUD","text":"이전 글 : Prisma 기본 세팅 Prisma에 대한 내용은 공식 홈페이지에 자세하게 기술이 되어있습니다.해당 블로그 글은 Prisma 공식 홈페이지를 기반으로 쓰여졌습니다.참고 : Prisma 공식 홈페이지 Prisma 가져오기아래와 같이 사용하는데, main 함수를 호출하는 것은 여기에서 생략하도록 하겠다. 123456789101112131415161718192021222324252627// node module PrismaClient에서 `@prisma/client` 가져오기const { PrismaClient } = require(&quot;@prisma/client&quot;)// PrismaClient 인스턴스 화const prisma = new PrismaClient()// prisma 조작async function main() { // 용도에 맞는 쿼리 사용 const test = await prisma.user.create({ data: { name: } }) console.log(test)}main() .catch(err =&gt; { throw err }) .finally(async () =&gt; { await prisma.$disconnect() }) 이제 prisma를 통해 DB를 조작해보자. Createcreate는 데이터베이스의 데이터를 생성하고 생성된 데이터를 객체 형태로 반환한다.user 테이블에 데이터를 추가하는 예시이다. 1234567891011async function main() { const createUser = await prisma.user.create({ where: { name: &quot;daphne&quot;, email: &quot;daphne@test.com&quot;, }, }); console.log(createUser); // 결과 : { id: 1, name: 'daphne', email: 'daphne@test.com' }} Read데이터를 조회하는 방법으로 findOne과 findMany가 있다.findOne은 조건에 맞는 객체 하나를 반환하고, findMany는 조건에 맞는 객체들을 배열에 담아서 반환한다.단, findOne은 id나 unique 같은 고유한 속성을 가진 컬럼만 조건에 사용할 수 있고, findMany는 모든 테이블의 속성들을 사용할 수 있다. 12345678910111213141516171819async function main() { const findUser = await prisma.user.findOne({ where: { email: &quot;daphne@test.com&quot;, }, }); const findUsers = await prisma.user.findMany({ where: { name: &quot;daphne&quot;, }, }); console.log(findUser); // 결과 : { id: 1, name: 'daphne', email: 'daphne@test.com' } console.log(findUsers); // 결과 : [ { id: 1, name: 'daphne', email: 'daphne@test.com' } ]} Update데이터를 변경하는 방법으로 Update가 있다.findOne과 마찬가지로 where 조건에 고유한 컬럼 값만 사용할 수 있다. 12345678910111213async function main() { const updateUser = await prisma.user.update({ where: { email: &quot;daphne@test.com&quot;, }, data: { email: &quot;test@test.com&quot;, }, }); console.log(updateUser); // 결과 : { id: 1, name: 'daphne', email: 'test@test.com' }} Delete데이터를 삭제하는 방법으로 Delete가 있다.역시 where 조건에 고유한 컬럼 값만 사용할 수 있다. 12345678910async function main() { const deleteUser = await prisma.user.delete({ where: { id: 1, }, }); console.log(deleteUser); // 결과 : { id: 1, name: 'daphne', email: 'test@test.com' }}","link":"/2020/11/15/prisma-002/"},{"title":"[JavaScript] Promise","text":"Promise란? 자바스크립트 비동기 처리에 사용되는 객체 비동기란 간단히 말하면 특정 코드의 실행이 완료될 때까지 기다리지 않고 다음 코드를 먼저 수행하는 것이다. 참고 : 동기와 비동기 Promise의 상태promise는 3가지의 상태가 있다. 이는 프로미스의 처리 과정을 의미한다. Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태 Fulfilled(이행) : 비동기 처리가 완료되어 프로미스 결과 값을 반환해준 상태 Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태 Pending기본적으로 new Promise()를 호출하면 Pending(대기) 상태가 된다. new Promise()를 호출할 때 콜백 함수를 선언할 수 있고, 콜백 함수의 인자는 resolve, reject이다. 아래의 코드와 같이 사용한다. 123const fetchNumber = new Promise((resolve, reject) =&gt; { console.log(&quot;Hi&quot;);}); 여기서 중요한 포인트가 있다. promise를 만드는 순간 해당 함수가 바로 자동적으로 실행되어 위의 예제 코드에서 console log에 Hi가 출력되게 된다. 때문에 이점을 유의하여 promise를 사용해야 한다. Fulfilledresolve()를 실행하면 Fulfilled(이행) 상태가 된다. 123456789const fetchNumber = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(1); }, 1000);});fetchNumber.then((value) =&gt; { console.log(value);}); 위의 코드는 promise가 잘 실행되어 1초 뒤에 resolve()를 통해 1이 then()으로 전달되어 1을 출력하게 된다. Rejectedreject()를 실행하면 Rejected(실패) 상태가 된다. 12345678910111213const fetchNumber = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(new Error(&quot;no network&quot;)); }, 1000);});fetchNumber .then((value) =&gt; { console.log(value); }) .catch((error) =&gt; { console.log(error); }); 위의 코드는 promise가 실패했을 시 error를 reject()를 통해 전달하여 then()에서 성공적으로 값을 받지 못했을 경우 catch()를 통해 error를 받아서 지정한 에러 메시지인 no network를 출력하게 된다. 만약 에러없이 resolve를 잘 받았다면 catch를 통한 에러는 출력되지 않는다. Finallyfinally()는 성공하든 실패하든 마지막에 실행되는 함수이다. 12345678910111213141516const fetchNumber = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(new Error(&quot;no network&quot;)); }, 1000);});fetchNumber .then((value) =&gt; { console.log(value); }) .catch((error) =&gt; { console.log(error); }) .finally(() =&gt; { console.log(&quot;finally&quot;); }); 때문에 위의 코드에서 어떤 상황이든 finally가 마지막에 출력되는 것을 볼 수 있다. 기존의 Callback 함수를 이용한 코드 예제참고 : Callback 함수란? 예를 들어 id, password를 받아서 해당 유저의 역할에 대해 출력하는 코드를 비동기적으로 callback 함수를 통해 만든다고 가정한다.아래와 같은 코드가 될 것이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243class UserStorage { loginUser(id, password, onSuccess, onError) { setTimeout(() =&gt; { if (id === &quot;daphne&quot; &amp;&amp; password === &quot;1234&quot;) { onSuccess(id); } else { onError(new Error(&quot;not found&quot;)); } }, 2000); } getRoles(user, onSuccess, onError) { setTimeout(() =&gt; { if ((user === onSuccess, onError)) { onSuccess({ name: &quot;daphne&quot;, role: &quot;admin&quot; }); } else { onError(new Error(&quot;no access&quot;)); } }, 1000); }}const UserStorage = new UserStorage();const id = prompt(&quot;enter your id&quot;);const password = prompt(&quot;enter your password&quot;);userStorage.loginUser( id, password, (user) =&gt; { userStorage.getRoles( user, (userWithRole) =&gt; { alert(`Hello ${userWithRole.name}, you have a ${userWithRole.role}`); }, (error) =&gt; { console.log(error); } ); }, (error) =&gt; { console.log(error); }); 이러한 코드는 callback 함수가 많이 쓰이기 때문에 코드의 가독성이 떨어지고 수정하기도 힘들 것이다. Promise를 이용한 Callback 지옥 리팩토링위의 코드를 Promise를 통해 간결하게 표현해보자. 1234567891011121314151617181920212223242526272829303132333435class UserStorage { loginUser(id, password) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { if (id === &quot;daphne&quot; &amp;&amp; password === &quot;1234&quot;) { resolve(id); } else { reject(new Error(&quot;not found&quot;)); } }, 2000); }); } getRoles(user) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { if (user === &quot;daphne&quot;) { resolve({ name: &quot;daphne&quot;, role: &quot;admin&quot; }); } else { reject(new Error(&quot;no access&quot;)); } }, 1000); }); }}const userStorage = new UserStorage();const id = prompt(&quot;enter your id&quot;);const password = prompt(&quot;enter your password&quot;);userStorage .loginUser(id, password) .then(userStorage.getRoles) .then((user) =&gt; alert(`Hello ${user.name}, you have a ${user.role}`)) .catch(console.log); 코드의 길이부터 달라진 것을 확인할 수 있고 무엇을 하려는지 직관적으로 알 수 있게 되었다. 위의 코드의 진행 과정이다. userStorage 클래스를 불러옴 loginUser 함수를 통해 id와 password를 받음 id와 password가 맞다면 resolve로 user이름을 전달함 then을 통해 resolve를 통해 받은 user이름을 받아 getRoles 함수에 넣어 해당 유저가 무슨 역할을 갖는지 확인 then을 통해 해당 유저의 역할에 대해 출력 만약 위의 과정 중 에러가 발생하였다면 reject를 통해 어느 과정이 에러가 발생하였는지 출력","link":"/2020/10/08/promise-js/"},{"title":"Python Coroutine","text":"Synchronous vs Asynchronous 동기적 방식(Synchronous) : 순차적으로 일을 처리하는 방식, 요청과 동시에 결과가 일어나는 방식비동기적 방식(Asynchronous) : 어떤 작업을 요청했을 때, 그 작업이 종료될 떄까지 기다리지 않고 다른 작업을 하고 있다가, 요청했던 작업이 종료되면 그에 대한 추가 작업을 수행하는 방식 파이썬에서는 비동기적 방식을 asyncio라는 모듈로 제공하고 있다. Python AsyncioAsyncio 모듈을 활용한 가장 기본적인 코드 작성법을 알아보자. 1234567891011121314import asyncioasync def main(): print('hello') await asyncio.sleep(1) print('world')asyncio.run(main())&quot;&quot;&quot;출력 결과helloworld&quot;&quot;&quot; 위의 코드는 코루틴 함수인 async def main()을 asyncio.run()으로 실행해보는 예제이다. 여러 개의 코루틴 함수를 동시에 실행하는 방법을 알아보자 12345678910111213141516171819202122232425262728293031import asyncioasync def factorial(name, number): f = 1 for i in range(2, number + 1): print(f&quot;Task {name}: Compute factorial({i})...&quot;) await asyncio.sleep(1) f *= i print(f&quot;Task {name}: factorial({number}) = {f}&quot;)async def main(): # Schedule three calls *concurrently*: await asyncio.gather( factorial(&quot;A&quot;, 2), factorial(&quot;B&quot;, 3), factorial(&quot;C&quot;, 4), )asyncio.run(main())&quot;&quot;&quot;출력 결과Task A: Compute factorial(2)...Task B: Compute factorial(2)...Task C: Compute factorial(2)...Task A: factorial(2) = 2Task B: Compute factorial(3)...Task C: Compute factorial(3)...Task B: factorial(3) = 6Task C: Compute factorial(4)...Task C: factorial(4) = 24&quot;&quot;&quot; asyncio.gather()을 활용하여 여러 개의 코루틴 함수를 동시에 실행하는 예제이다.팩토리얼의 계산이 먼저 끝난 것부터 결과를 출력하는 비동기적인 모습을 볼 수 있다. asyncio.gather()는 모든 코루틴 함수의 처리가 완료되면 각각의 반환 값이 리스트 형태로 저장되는 특성을 가지고 있다. 출처 : https://docs.python.org/ko/3/library/asyncio-task.html Python Asyncio 활용 예제이제 이를 활용하여 1억번 +1 하는 연산을 코드로 작성해보자. 1234567891011121314151617181920212223242526import timeimport asyncioasync def coroutine(id, num): return_value = 0 while return_value &lt; num: return_value += 1 return return_valueasync def process_async(): # 각각의 코루틴 함수들의 연산이 끝나면 반환되는 값들이 모여 리스트 형태로 저장됨 tmp = await asyncio.gather( coroutine(1, 50000000), coroutine(2, 50000000) ) return sum(tmp)if __name__ == &quot;__main__&quot;: start_time = time.time() result = asyncio.run(process_async()) print(&quot;--- %s seconds ---&quot; % (time.time() - start_time)) print(&quot;ret_value = &quot;,end=&quot;&quot;), print(result) print(&quot;end of main&quot;)","link":"/2020/09/20/python-coroutine/"},{"title":"Python Function","text":"python function parameterPython에서는 함수에서 인수의 기본 값을 설정할 수 있다.하지만 특정한 규칙에 따라 인수의 값을 설정해야한다. 1234def student(class_number = 5, name): return namestudent(&quot;John&quot;) 위의 코드를 실행시켜보면 다음과 같은 에러가 뜬다 SyntaxError: non-default argument follows default argument 이는 non-default value parameter앞에 default value parameter를 정의해서 일어난 에러이다.해당 코드는 Python이 해당 함수에서 John이라는 값이 name 인수와 class_number 인수 둘 중 어디에 할당되었는지 알 수 없기 때문에 에러를 준 것이다. 쉽게 이해해보자. 123student(class_number = 5, name=&quot;John&quot;) # Okaystudent(name=&quot;John&quot;, class_number = 5) # Okaystudent(&quot;John&quot;) # student(class_number = &quot;john&quot;) or student(class_number = 5, name = &quot;john&quot;) ????? 즉, python 인터프리터가 해당 인수가 확실하게 어떤 값을 가지는 지 알 수 없게 되어 오류를 반환하는 것이다 ! python 함수에서의 인수의 순서 Positional arguments (non-default) Variable length arguments (default) Keyword-only arguments (*args) Variable length keyword arguments (**kwargs) 위의 순서를 따르지 않으면 python에서는 오류 메시지를 반환한다. 참고 : https://stackoverflow.com/questions/16932825/why-cant-non-default-arguments-follow-default-arguments python 함수에서의 인수의 위치 예시1. Non-Default Keyword-Only Argument 에러나는 경우1234567def func_param_with_var_args(name, *args, age): print(&quot;name=&quot;,end=&quot;&quot;), print(name) print(&quot;args=&quot;,end=&quot;&quot;), print(args) print(&quot;age=&quot;,end=&quot;&quot;), print(age)func_param_with_var_args(&quot;정우성&quot;, &quot;01012341234&quot;, &quot;seoul&quot;, 20) 위의 코드를 실행하면 아래와 같은 오류 메시지가 출력된다. TypeError: func_param_with_var_args() missing 1 required keyword-only argument: ‘age’ 가변 인수인 *args 뒤에 위치 인수인 age를 선언해서 생긴 문제이다. 함수에 인자를 넣을 때 age=20으로 명시해줌으로써 해결할 수 있다. 위의 함수를 잘 출력되게 수정한 코드이다. 1234567def func_param_with_var_args(name, *args, age): print(&quot;name=&quot;,end=&quot;&quot;), print(name) print(&quot;args=&quot;,end=&quot;&quot;), print(args) print(&quot;age=&quot;,end=&quot;&quot;), print(age)func_param_with_var_args(&quot;정우성&quot;, &quot;01012341234&quot;, &quot;seoul&quot;, age=20) [출력결과] 2. 가변 키워드인수(Variable length keyword arguments) 위치 오류1234567def func_param_with_kwargs(name, age, **kwargs, address=0): print(&quot;name=&quot;,end=&quot;&quot;), print(name) print(&quot;age=&quot;,end=&quot;&quot;), print(age) print(&quot;kwargs=&quot;,end=&quot;&quot;), print(kwargs) print(&quot;address=&quot;,end=&quot;&quot;), print(address)func_param_with_kwargs(&quot;정우성&quot;, &quot;20&quot;, mobile=&quot;01012341234&quot;, address=&quot;seoul&quot;) 위의 코드를 출력하면 아래와 같은 오류 메시지가 출력된다. SyntaxError: invalid syntax 가변 키워드 인수 **kwargs 뒤에 가변 인수 address=0가 위치해서 뜨는 에러이다. 위의 함수를 잘 출력되게 수정한 코드이다. 12345678def func_param_with_kwargs(name, age, address=0, **kwargs): print(&quot;name=&quot;,end=&quot;&quot;), print(name) print(&quot;age=&quot;,end=&quot;&quot;), print(age) print(&quot;kwargs=&quot;,end=&quot;&quot;), print(kwargs) print(&quot;address=&quot;,end=&quot;&quot;), print(address)func_param_with_kwargs(&quot;정우성&quot;, &quot;20&quot;, mobile=&quot;01012341234&quot;, address=&quot;seoul&quot;) [출력결과] 3. 위치 인수와 가변 키워드 인수의 위치 오류123456789def mixed_params(name=&quot;아이유&quot;, *args, age, **kwargs, address): print(&quot;name=&quot;,end=&quot;&quot;), print(name) print(&quot;args=&quot;,end=&quot;&quot;), print(args) print(&quot;age=&quot;,end=&quot;&quot;), print(age) print(&quot;kwargs=&quot;,end=&quot;&quot;), print(kwargs) print(&quot;address=&quot;,end=&quot;&quot;), print(address)mixed_params(20, &quot;정우성&quot;, &quot;01012341234&quot;, &quot;male&quot; ,mobile=&quot;01012341234&quot;, address=&quot;seoul&quot;) 위의 코드를 출력하면 아래와 같은 오류 메시지가 출력된다. SyntaxError: invalid syntax 함수 인수의 각각의 위치가 확실하지 않고 인수가 함수에 지정된 것보다 많이 들어갔으며, 가변 인수 name=&quot;아이유&quot;뒤에 위치 인수 age와 가변 키워드 인수 **kwargs가 와서 뜨는 에러이다. 위의 함수를 잘 출력되게 수정한 코드이다. 123456789def mixed_params(age, name=&quot;아이유&quot;, *args, address, **kwargs): print(&quot;name=&quot;,end=&quot;&quot;), print(name) print(&quot;args=&quot;,end=&quot;&quot;), print(args) print(&quot;age=&quot;,end=&quot;&quot;), print(age) print(&quot;kwargs=&quot;,end=&quot;&quot;), print(kwargs) print(&quot;address=&quot;,end=&quot;&quot;), print(address)mixed_params(20, &quot;정우성&quot;, &quot;01012341234&quot;, &quot;male&quot;, mobile=&quot;01012341234&quot;, address=&quot;seoul&quot;) [출력결과]","link":"/2020/09/15/python-function/"},{"title":"[Node.js] 기본적인 Jest 사용법 2","text":"이전 글 : 기본적인 Jest 사용법 1출처 : Jest 공식 문서 Jest로 비동기 코드 테스트 하기Jest에서 비동기 코드를 테스트 해보자 Javascript에서는 비동기 처리를 3가지 방식으로 할 수 있다.callback, promise, async await이 비동기 처리 방법이다.각각의 비동기 처리를 테스트하는 예제를 살펴보자 Callbackdone을 사용하여 callback 함수를 확실하게 호출하여 테스트만약 done을 쓰지 않으면callback 함수가 호출되지 않고 test가 종료되고 잘못된 결과가 나와도 테스트가 통과된다. 12345678910111213141516171819const fetchData = (data) =&gt; { setTimeout(() =&gt; { console.log(&quot;1초 후 실행&quot;); data(&quot;test callback&quot;); }, 1000);};test(&quot;callback 테스트하기&quot;, (done) =&gt; { function callback(data) { try { expect(data).toEqual(&quot;test callback&quot;); done(); } catch (err) { done(err); } } fetchData(callback);}); Promisepromise를 테스트하기 위해서 resolves와 rejects를 사용할 수 있다. 123456789101112131415161718192021222324252627const fetchDataPromise = () =&gt; { return new Promise((resolve, reject) =&gt; { return setTimeout(() =&gt; { console.log(&quot;promise 테스트&quot;); resolve(&quot;test promise resolve&quot;); }, 1000); });};const fetchDataThrowError = () =&gt; { return new Promise((resolve, reject) =&gt; { return setTimeout(() =&gt; { console.log(&quot;error 테스트&quot;); reject(&quot;error&quot;); }, 1000); });};describe(&quot;promise resolve/reject 테스트하기&quot;, () =&gt; { test(&quot;resolve 테스트&quot;, () =&gt; { return expect(fetchDataPromise()).resolves.toBe(&quot;test promise resolve&quot;); }); test(&quot;reject 테스트&quot;, () =&gt; { return expect(fetchDataThrowError()).rejects.toBe(&quot;error&quot;); });}); Async/Await이전에 promise 테스트에서 사용했던 fetchDataPromise와 fetchDataThrowError를 사용하여 Async/Await로 테스트를 해보자. 간단하게 async와 await를 사용하면 간단하게 비동기 코드를 테스트 해볼 수 있다. 1234567891011121314describe(&quot;Async/Await로 테스트&quot;, () =&gt; { test(&quot;Async/Await 성공 테스트&quot;, async () =&gt; { const data = await fetchDataPromise(); expect(data).toBe(&quot;test promise resolve&quot;); }); test(&quot;Async/Await로 에러 처리 테스트&quot;, async () =&gt; { try { await fetchDataThrowError(); } catch (err) { expect(err).toEqual(&quot;error&quot;); } });});","link":"/2020/11/29/nodejs-007/"},{"title":"[Node.js] Prisma 기본 세팅","text":"Prisma란? Node.js 기반의 ORM(Object Relational Model)SQL 쿼리문을 직접 쓰지 않고도 Javascript로 DB를 조작할 수 있다. 참고 : ORM이란? Prisma 기본 세팅Prisma에 대한 기본적인 세팅 방법은 공식 홈페이지에 잘 설명되어 있다.본 페이지에서는 Prisma를 이용하여 MySQL을 조작해 볼 것이다. 참고 : Prisma 공식 홈페이지 Node.js와 MySQL이 이미 설치되었다는 가정 하에 진행한다. Prisma 설정package.json 파일이 포함된 프로젝트 디렉토리로 이동하여 다음 명령어를 입력한다. 12npm init -ynpm install @prisma/cli --save-dev 다음 명령어로 Prisma CLI을 호출한다. 1npx prisma Prisma 스키마 파일 템플릿을 생성하여 Prisma 프로젝트를 설정한다. 1npx prisma init Prisma 디렉토리에 아래와 같은 파일이 생성되었을 것이다. schema.prisma : 데이터베이스 연결 및 Prisma 클라이언트 생성기가 있는 Prisma schema.env : 환경 변수를 정의하기 위한 dotenv 파일 데이터베이스 연결이제 데이터베이스를 연결해보자 prisma / schema.prisma 파일을 보면 아래와 같은 코드가 있을 것이다. 1234datasource db { provider = &quot;mysql&quot; url = env(&quot;DATABASE_URL&quot;)} provider은 연결하고자 하는 DB의 종류이다.url은 DATABASE의 URL 정보를 .env파일에 지정해 놓은걸 가져온다. prisma / .env 12DATABASE_URL = &quot;mysql://사용자 이름:비밀번호@localhost:3306/DB이름&quot;DATABASE_URL = &quot;mysql://test:password@localhost:3306/mydb&quot; 적용할 SQL 스키마는 다음과 같다.아래의 스키마를 기준으로 DB를 미리 생성하자. 1234567891011121314151617181920CREATE TABLE user ( id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL, name VARCHAR(255), email VARCHAR(255) UNIQUE NOT NULL);CREATE TABLE post ( id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL, title VARCHAR(255) NOT NULL, createdAt TIMESTAMP NOT NULL DEFAULT now(), content TEXT, published BOOLEAN NOT NULL DEFAULT false, authorId INTEGER NOT NULL, FOREIGN KEY (authorId) REFERENCES user(id));CREATE TABLE profile ( id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL, bio TEXT, userId INTEGER UNIQUE NOT NULL, FOREIGN KEY (userId) REFERENCES user(id)); 아래 명령어를 입력하여 DB를 검사해서 DB 스키마를 SQL에서 Prisma 데이터 모델로 변환한다. 1npx prisma introspect 제대로 적용이 되었다면 prisma / schema.prisma 파일에 아래와 같이 표시될 것이다. 1234567891011121314151617181920212223242526model post { id Int @id @default(autoincrement()) title String createdAt DateTime @default(now()) content String? published Boolean @default(false) authorId Int user user @relation(fields: [authorId], references: [id]) @@index([authorId], name: &quot;authorId&quot;)}model profile { id Int @id @default(autoincrement()) bio String? userId Int @unique user user @relation(fields: [userId], references: [id])}model user { id Int @id @default(autoincrement()) name String? email String @unique post post[] profile profile?} 아래 명령어를 통해 npx prisma introspect로 생성된 schema.prisma 파일을 읽어서 우리가 사용할 prisma client 코드를 생성한다.쉽게 말해 우리가 DB를 조작할 수 있도록 Node가 알게 해주는 것이다. 1npx prisma generate 이제 기본적인 세팅은 끝이 났다.다음에는 Prisma를 이용하여 CRUD를 해보자.","link":"/2020/11/11/prisma-001/"},{"title":"Python Generator","text":"python generator제너레이터는 이터레이터를 생성해주는 함수라고 할 수 있다.이터레이터는 클래스에 __iter__, __next__, __getitem__ 같은 메서드를 구현해야 하지만 제너레이터는 yield라는 키워드만 사용하면 된다. 제너레이터는 return과 달리 함수가 실행 중일때도 함수 밖에 값을 전달할 수 있다. 아래 예시를 보자 12345678910111213141516171819202122232425262728293031323334def number_generator(): print(&quot;제너레이터 시작!&quot;) yield 0 print(&quot;실행 중에 잠깐 함수 바깥에 나갔다 왔어요&quot;) yield 1 print(&quot;실행 중에 잠깐 함수 바깥에 나갔다 왔어요&quot;) yield 2g = number_generator()a = next(g)print(a)b = next(g)print(b)c = next(g)print(c)'''출력결과제너레이터 시작!0실행 중에 잠깐 함수 바깥에 나갔다 왔어요1실행 중에 잠깐 함수 바깥에 나갔다 왔어요2''' lazy evaluation제너레이터 함수인 yield 외에도 제너레이터 표현식(generator expression)이 있다.제너레이터 표현식은 Lazy evaluation을 위해서 사용될 수 있는데, 말 그대로 실행을 지연시킨다는 의미이다. 아래 예시를 보자 12345678910111213141516171819L = [ 1,2,3]def generate_square_from_list(): result = ( x*x for x in L ) print(result) return resultdef print_iter(iter): for element in iter: print(element)print_iter(generate_square_from_list())'''출력결과149''' 출력결과를 보면 따로 result에 저장하지 않고 즉시 필요할 때마다 이터레이터 요소를 전달하는 것을 볼 수 있다. list comprehension vs lazy evaluationlist comprehension과 lazy evaluation을 비교해보자 123456789101112131415161718192021222324252627282930313233343536373839L = [1,2,3]import timedef print_iter(iter): for element in iter: print(element)def lazy_return(num): print(&quot;sleep 1s&quot;) time.sleep(1) return numprint(&quot;comprehension_list=&quot;)comprehension_list = [ lazy_return(i) for i in L ]print_iter(comprehension_list)print(&quot;generator_exp=&quot;)generator_exp = ( lazy_return(i) for i in L )print_iter(generator_exp)'''출력결과comprehension_list=sleep 1ssleep 1ssleep 1s123generator_exp=sleep 1s1sleep 1s2sleep 1s3''' list comprehension은 이터레이터 요소가 모두 생성될 때까지 기다리다가 전달해주는 반면lazy evaluation은 이터레이터 요소를 생성할 때마다 즉시 전달해주는 것을 볼 수 있다. 만약 리스트 L의 값 중 3이 쓰이지 않는다면 list comprehension을 사용했을 시 lazy evaluation에 비해 1초라는 시간이 더 지연될 것이다. 이러한 lazy evaluation의 특징은 어떠한 이터레이터 요소가 확실하게 모두 쓰인다는 보장이 없을 경우 list comprehension 보다 효율적으로 동작하게 만들 수 있다.","link":"/2020/09/18/python-generator/"},{"title":"Python module &amp; packages import","text":"python에서의 import search 순서파이썬은 아래의 순서대로 모듈/package를 찾는다. sys.modules built-in modules sys.path python에서는 import 하고자 하는 모듈과 package를 찾을 때에 위와 같은 순서로 찾게 되지만 만일 sys.path에서도 못찾을 경우 ModuleNotFoundError 에러를 리턴한다. 1. sys.modules dictionary 자료형 이미 import된 module과 package를 저장하고 있다. 단, 새로 import 하는 module은 sys.modules에서 찾을 수 없다. 2. built-in modules Python에서 제공하는 공식 Library 별도의 설치 없이 사용 가능 3. sys.path List 자료형 각각의 package에 대한 경로가 String 요소로 저장되어 있다. 아래와 같이 직접 확인해볼 수 있다. 123import sysprint(sys.path)print(sys.modules) sys.modules vs sys.pathsys.modules는 dictionary 자료형으로 module/package 및 각각의 경로를 저장하고 있고sys.path는 list 자료형으로 module/package가 설치된 dictionary 경로를 담고 있다. sys를 불러올 수 있는 이유sys.modules나 sys.path는 sys 모듈로부터 오는 것을 알 수 있다.그렇다면 sys 모듈은 어떻게 찾아서 불러올 수 있을까? sys.modules를 출력해보면 dictionary 형태로 sys가 저장된 것을 볼 수 있다. 1{'sys':&lt;module 'sys' (built-in)&gt;} 위에서 알 수 있듯이 built-in modules에서 불러오기 때문에 따로 경로를 설정하지 않아도 sys를 불러올 수 있는 것을 알 수 있다. Absolute path와 Relative path의 차이점python에서 미리 제공되는 module이나 package가 아닌 직접 만든 local package는 어떻게 불러올 수 있을까?이를 위해 절대 경로(Absolute path)와 상대 경로(Relative path)에 대해 알아야 한다.절대 경로는 말 그대로 어디에서 불러오든 해당 package의 위치에 대해 항상 동일한 경로를 가지고 있기 때문에 불러올 수 있다. 다음과 같은 프로젝트를 예로 들어보자. my_app이라는 프로젝트이며 package1, package2라는 2개의 package를 가지고 있다. 절대 경로(Absolute path)를 이용해 package1과 package2를 import하면 다음과 같다. 1234from package1 import module1from package1.module2 import function1from package2 import class1from package2.subpackage1.module5 import function2 my_app 프로젝트의 최상위 디렉토리에서 부터 시작하는 것을 알 수 있는데, 이처럼 my_app 프로젝트 내에서 어느 파일, 어느 위치에서 import 하던지 경로가 항상 위와 같이 동일하게 되는 것을 Absolute path라고 한다. 상대 경로(Relative path)는 현재 import를 하는 위치에 따라 경로가 달라지는 것을 말한다. 아래의 예시를 보자 123# package2/module3.py (현재 위치)from . import class1from .subpackage1.module5 import function2 위에서 dot(.)은 import가 선언되는 파일의 현재 위치를 말한다.dot 2개(..)는 현재 위치에서 한 단계 상위 디렉토리로 가는 것을 의미한다. 이와 같이 import 하는 위치를 기준으로 경로를 정의하는 것을 Relative path라고 한다. 그렇다면 직접 개발한 local package를 import 할 때를 알아보자. 일반적으로 Absolute path를 사용한다.다만 Absolute path를 사용하면 한 가지 단점이 있는데 경로가 너무 길어진다는 점이다.이를 보완하기위해 적절하게 Relative path를 사용해준다. calculator 패키지 만들어보기 1234567891011# main.py# absoulte path#from calculator.add_and_multiply import add_and_multiply# relative pathfrom .calculator.add_and_multiply import add_and_multiplyif __name__ == '__main__': print(add_and_multiply(1,2)) 1234567# add_and_multiply.pyfrom .multiplication import multiply# from calculator.multiplication import multiplydef add_and_multiply(a,b): return multiply(a,b) + (a+b) 12345# multiplication.pydef multiply(a,b): return(a*b) 위의 코드를 보면 main.py에서 add_and_multiply.py를 import 했을 때 에러가 발생한다.아래와 같은 에러 메시지가 뜬다. 파이썬에서는 각각의 파일마다 이름(&quot;__name__&quot;)을 미리 받아놓아 저장하는 곳이 있다. 이를 기준으로 파이썬 인터프리터는 각각의 파일에 대한 경로를 알 수 있게 되는데 그 중에서 &quot;__main__&quot;은 조금 특별하다. 항상 시작점이 &quot;__main__&quot;으로 되기 때문에 시작점에 따라 &quot;__main__&quot;이 바뀌는데 이런 이유로 파이썬의 시작점이 되는 파이썬 어플리케이션은 항상 절대 경로를 사용해야한다. 참고 https://docs.python.org/3/tutorial/modules.html#intra-package-references https://dojang.io/mod/page/view.php?id=2448 아래와 같이 절대 경로로 수정해주면 된다. 123# from .calculator.add_and_multiply import add_and_multiplyfrom calculator.add_and_multiply import add_and_multiply # 수정 add_and_multiply.py에서의 절대 경로와 상대 경로1234567# 절대 경로from calculator.multiplication import multiply# 상대 경로from .multiplication import multiplydef add_and_multiply(a,b): return multiply(a,b) + (a+b) main 모듈에서는 calculator package 밖에 있기 때문에 상대 경로를 사용할 수 없지만add_and_multiply.py파일은 calculator package내에 있기 때문에 절대 경로와 상대 경로 모두 사용할 수 있다. package에서의 init.py의 역할 __init__.py파일에는 아무 코드도 없지만 init 파일은 해당 디렉토리가 패키지임을 알려주는 역할을 한다.","link":"/2020/09/17/python-module-packages/"},{"title":"Python Multiprocessing","text":"Process &amp; Multiprocessing멀티 프로세싱(multiprocessing)에 대해 알아보기 전에 프로세스(process)가 무엇인지 알 필요가 있다. 프로세스(process)란 실행 중인 프로그램을 의미한다. 예를 들어 우리는 컴퓨터를 사용할 때 유튜브도 보고 검색도 하고 한글이나 엑셀로 문서 작성도 하고 카카오톡 같은 메신저로 채팅을 주고 받을 수 있을 것이다. 이때 실행 중인 프로그램들이 하나하나가 프로세스(process)라고 할 수 있고 이렇게 여러 개의 프로세스를 동시에 수행힐 수 있도록 하는 것이 멀티 프로세싱(multiprocessing)이라 할 수 있다. python multiprocessing파이썬에서의 멀티 프로세싱에 대해 알아보자. 이전에 쓰레드(thread)만 이용했을 때는 1억번의 +1을 수행할 때 시간이 줄어들지 않음을 알 수 있었는데, 멀티 프로세싱을 활용하면 어떻게 될까? 참고 : 파이썬 쓰레드 큐(Queue)를 활용한 멀티 프로세싱아래의 코드를 보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from multiprocessing import Process, Queueimport timedef worker(id, number, q): increased_number = 0 for _ in range(number): increased_number += 1 # 결과를 q에 저장 q.put(increased_number) returnif __name__ == &quot;__main__&quot;: start_time = time.time() # 큐 생성 q = Queue() # 프로세스 2개 생성 th1 = Process(target=worker, args=(1, 50000000, q)) th2 = Process(target=worker, args=(2, 50000000, q)) # 프로세스 시작 th1.start() th2.start() # 프로세스가 종료될 때까지 기다린다. th1.join() th2.join() print(&quot;--- %s seconds ---&quot; % (time.time() - start_time)) # q가 비었음을 확인하기 위해 q에 'exit' 저장 q.put('exit') total = 0 while True: # q에 저장된 값을 차례로 가져옴 tmp = q.get() # q가 비었을 시 종료 if tmp == 'exit': break else: # q에 저장된 값을 차례로 더함 total += tmp print(&quot;total_number=&quot;,end=&quot;&quot;), print(total) print(&quot;end of main&quot;) 연산하는 시간이 줄었음을 확인할 수 있다. 위의 예제는 각각의 프로세스에서 공통의 큐를 사용하여 증가시킨 값을 큐에 넣어 메인 쓰레드에서 다시 꺼내와서 모두 합해서 총 증가시킨 값을 구한 것이다. 공유 메모리(Shared Memory)를 활용한 멀티 프로세싱공유 메모리(Shared Memory)를 활용해 멀티 프로세싱을 하려면 세마포어(Semaphore)를 이용해야한다. 세마포어(Semaphore)는 공유된 자원을 한 번에 하나의 프로세스만 접근할 수 있도록 제한할 수 있게 해준다. 뮤텍스(Mutex)와 비슷하다고 생각할 수 있지만 엄연히 다른 개념이다.세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다. 뮤텍스(Mutex)동기화 대상이 하나소유할 수 있음한 번에 하나의 쓰레드만 들어올 수 있음 세마포어(Semaphore)동기화 대상이 여러 개소유할 수 없음여러 개의 쓰레드가 임계영역에 들어올 수 있음 이러한 세마포어를 이용해서 공유 메모리에 프로세스가 동시에 접근하는 것을 제한하게 한다. 아래 코드를 보자 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from multiprocessing import Process, shared_memory, Semaphoreimport numpy as npimport timedef worker(id, number, shm, arr, sem): increased_number = 0 for _ in range(number): increased_number += 1 # 세마포어 획득 sem.acquire() # 앞서 생성한 공유 메모리 블록을 가져와서 사용 new_shm = shared_memory.SharedMemory(name=shm) # 가져온 공유 메모리 블록을 numpy 배열로 사용하기 편하게 변환 tmp_arr = np.ndarray(arr.shape, dtype=arr.dtype, buffer=new_shm.buf) # 각각의 프로세스에서 연산한 값을 합해서 numpy 배열에 저장 tmp_arr[0] += increased_number # 세마포어 해제 sem.release()if __name__ == &quot;__main__&quot;: start_time = time.time() # 숫자를 저장할 numpy 배열(1차원) 생성 arr = np.array([0]) # 공유 메모리 생성 shm = shared_memory.SharedMemory(create=True, size=arr.nbytes) # 공유 메모리의 버퍼를 numpy 배열로 변환 np_shm = np.ndarray(arr.shape, dtype=arr.dtype, buffer=shm.buf) # 세마포어 생성 sem = Semaphore() # 프로세스 2개 생성 th1 = Process(target=worker, args=(1, 50000000, shm.name, np_shm, sem)) th2 = Process(target=worker, args=(2, 50000000, shm.name, np_shm, sem)) # 프로세스 시작 th1.start() th2.start() # 프로세스가 종료될 때까지 기다린다. th1.join() th2.join() print(&quot;--- %s seconds ---&quot; % (time.time() - start_time)) print(&quot;total_number=&quot;,end=&quot;&quot;), print(np_shm[0]) print(&quot;end of main&quot;) # 공유 메모리 사용 종료 shm.close() # 공유 메모리 블록 삭제 shm.unlink() 시간이 단축 됐음을 알 수 있다.공유 메모리를 생성해 각각의 프로세스마다 연산한 결과를 공유 메모리에 저장하는데, 공유 메모리에 접근하는 것을 세마포어를 이용해 제한을 두어 간섭이 일어나지 않게 한 것이다.","link":"/2020/09/19/python-multiproccessing/"},{"title":"[JavaScript] reduce 메소드","text":"Reduce 메소드란? reduce() 메소드는 배열의 각 요소에 대해 주어진 함수를 실행하고 하나의 결과 값을 반환한다. reduce() 메소드의 문법은 다음과 같다. 배열.reduce((누적값, 현재값, 인덱스, 요소) =&gt; { return 결과 }, 초깃값); 초깃값을 미리 정할 수 있고 배열을 돌면서 누적값을 계속해서 활용할 수 있다.아래 예시를 보자. 12345678var number = [1, 2, 3, 4, 5];const sumNumber = number.reduce((acc, cur, i) =&gt; { console.log(`누적값: ${acc}, 현재값: ${cur}, 배열 인덱스: ${i}`); return acc + cur;}, 0);console.log(sumNumber); [출력결과] number 배열을 이용해 해당 배열의 모든 요소를 더한 값을 구하는 예제이다.배열을 처음부터 끝까지 순회하면서 반환되는 누적값을 계속해서 사용하는 것을 볼 수 있다.이를 활용해서 단순한 합 계산뿐만이 아니라 다른 곳에도 유용하게 쓰일 수 있다. 다음 코드를 보자. 12345678const evenNumber = number.reduce((acc, cur) =&gt; { if (cur % 2 === 0) { acc.push(cur); } return acc;}, []);console.log(evenNumber); [출력결과] number 배열에서 짝수만 골라서 배열로 만드는 예제이다.초기값을 빈 배열로 주어서 현재 값이 짝수이면 빈 배열인 acc안에 넣어주고 다음에 활용할 수 있도록 acc 배열을 반환해준다.filter() 메소드와 거의 유사한 것을 알 수 있다. 참고 : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce","link":"/2020/10/05/reduce-js/"},{"title":"Semantic Web","text":"Semantic Web 의미론적인 웹의미가 잘 드러나는 웹문서의 의미에 맞게 HTML을 작성하는 것을 의미한다. Semantic TagHTML5에서는 Semantic Web을 위해 추가된 태그들이 있다. &lt;header&gt; &lt;nav&gt; &lt;main&gt; &lt;section&gt; &lt;article&gt; &lt;aside&gt; &lt;footer&gt; 각각의 태그들을 적재적소에 잘 쓴다면 컴퓨터는 정보를 이해하고 사람과 컴퓨터가 같이 이해할 수 있는 코드가 된다. Semantic Web의 장점 웹 접근성 향상 검색엔진이 이해하기 쉽게되어 검색이 수월해지고 검색 결과가 상위에 노출될 수 있게 된다.SEO(search Engine Optimization) 코드 가독성이 좋아진다. img vs background-imageimg 태그와 background-image 태그를 비교해보자. 두 태그는 이미지를 보여주는 동일한 기능을 가지고 있다.그럼 의미론적인 웹에서 해당 태그들은 어떻게 사용되어야 할까? 접근성 검색봇은 이미지를 직접 보지않고 img 태그의 alt 속성에 제공된 정보에 집중한다. 즉, 이미지가 검색 결과 상위에 쉽게 노출되게 하기 위해서는 img 태그를 쓰는 것이 좋을 것이다. &lt;img&gt; 태그의 성능 &lt;img&gt;를 사용하는 것이 빠르다.CSS에 background-image를 통해 크기가 큰 이미지가 많이 선언되어 있는 경우 브라우저는 CSS파일을 분석하고 이미지를 불러오는데 시간이 오래걸리게 되어 전체 페이지 로드가 지연이 된다. 상대적으로 느리게 동작한다. &lt;background-image&gt;의 사용처&lt;background-image&gt;는 이름 그대로 배경 이미지를 넣고 싶을때 사용하는 것이 좋다. 디자인적인 측면에서 사용할 때 좋을 것이다.","link":"/2020/09/15/semantic-web/"},{"title":"MySQL UTF8 적용하기(WSL)","text":"이 글은 MySQL 5.7 버전 및 WSL Ubuntu 18.04 LTS 버전에서 적용되었음을 알려드립니다.다른 버전에서 안될 가능성이 있을 수 있습니다. MySQL 버전 확인 및 우분투 버전 확인12mysql --versionmysql Ver 14.14 Distrib 5.7.31, for Linux (x86_64) using EditLine wrapper 12cat /etc/issueUbuntu 18.04.5 LTS \\n \\l MySQL 설정 파일 변경123sudo vi /etc/mysql/my.cnf!includedir /etc/mysql/mysql.conf.d/ 밑에 아래의 코드 추가 1234567891011121314[client]default-character-set = utf8[mysqld]init_connect = SET collation_connection = utf8_general_ciinit_connect = SET NAMES utf8character-set-server = utf8collation-server = utf8_general_ci[mysqldump]default-character-set = utf8[mysql]default-character-set = utf8 MySQL 계정 홈 디렉토리 설정WSL에서는 위의 설정까지 하고 MySQL 재실행을 할 시 아래와 같은 메시지가 뜬다. No directory, logging in with HOME=/ 이를 해결하기 위해 아래의 코드를 입력하여 MySQL의 홈 디렉토리를 변경해준다. 1sudo usermod -d /var/lib/mysql/ mysql 만약 위의 코드를 입력했을 시 아래와 같은 메시지가 뜰 경우 usermod: user mysql is currently used by process 378 윈도우 CMD 창을 열고 아래의 명령어를 입력하여 WSL을 종료한 후 다시 켜준다. 1wsl --shutdown MySQL 재실행1sudo service mysql restart 현재 MySQL Character-Set 확인하기12sudo mysql -u root -pmysql&gt; status 아래와 같이 uft8이 모두 모두 적용되었다면 성공이다. 설정이 모두 끝나면 데이터베이스를 생성할 때마다 항상 UTF8로 적용되어 생성된다.","link":"/2020/09/30/wsl-mysql-utf8-setting/"},{"title":"Python Thread","text":"python thread어떠한 일을 처리할 때 혼자 하는 것보다 나눠서 같이 하는게 당연히 시간 및 효율적인 측면에서 좋을 것이다. 아래의 코드를 보자 1234567891011121314import timeif __name__ == &quot;__main__&quot;: increased_num = 0 start_time = time.time() for i in range(100000000): increased_num += 1 print(&quot;--- %s seconds ---&quot; % (time.time() - start_time)) print(&quot;increased_num=&quot;,end=&quot;&quot;), print(increased_num) print(&quot;end of main&quot;) 위의 프로그램은 단일 프로세스의 단일 쓰레드로 1억번 +1 을 하는 프로그램이다. 증가된 숫자의 결과가 1억인것을 알 수 있다.제대로 동작했다는 의미이다. 그렇다면 쓰레드 두개를 만들어서 처리하도록 해보자 12345678910111213141516171819202122232425262728293031323334353637383940import threadingimport timeshared_number = 0def thread_1(number): global shared_number print(&quot;number = &quot;,end=&quot;&quot;), print(number) for i in range(number): shared_number += 1def thread_2(number): global shared_number print(&quot;number = &quot;,end=&quot;&quot;), print(number) for i in range(number): shared_number += 1if __name__ == &quot;__main__&quot;: threads = [ ] start_time = time.time() t1 = threading.Thread( target= thread_1, args=(50000000,) ) t1.start() threads.append(t1) t2 = threading.Thread( target= thread_2, args=(50000000,) ) t2.start() threads.append(t2) for t in threads: t.join() print(&quot;--- %s seconds ---&quot; % (time.time() - start_time)) print(&quot;shared_number=&quot;,end=&quot;&quot;), print(shared_number) print(&quot;end of main&quot;) 생각한 대로 나왔다면 shared_number가 1억이 나왔어야 할 것이다.하지만 1억에 한참 못 미치는 수치가 나왔다.왜 그런 것일까? 이유는 각각의 쓰레드가 서로 간섭이 일어나서 생긴 현상이다.global로 지정된 공유된 자원인 shared_number를 각각의 쓰레드에서 사이좋게 양보하며 가져간다면 그럴 일이 생기지 않겠지만 그러한 조건이나 제한이 없기 때문에 그렇다. 하나의 공유된 자원인 shared_number를 두 개의 쓰레드가 동시에 접근해서 해당하는 연산이 제대로 이루어지지 않았기 때문이다. 이러한 상황을 해결하기 위해 사용하는 객체가 뮤텍스(Mutex)라는 객체이다. 뮤텍스(Mutex)라는 객체를 쓰레드끼리 공유하여 해당 객체를 가질 때만 공유된 변수나 자원에 대한 권한을 가지게 한다. 즉, 뮤텍스(Mutex) 객체가 없는 쓰레드들은 공유된 변수나 자원에 접근할 수 없다. python 3.7버전 이상 부터는 기본적으로 thread 모듈이 지원이 되는데 이곳에서 뮤텍스(Mutex) 역할을 하는 객체를 생성할 수 있다. 가장 기본적으로 사용되는 것은 Lock 객체이다. 위의 코드를 Lock 객체를 활용하여 의도된대로 연산이 이루어지게 해보자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import threadingimport timeshared_number = 0def thread_1(number): global shared_number print(&quot;number = &quot;,end=&quot;&quot;), print(number) for i in range(number): lock.acquire() # lock 획득 shared_number += 1 lock.release() # lock 해제def thread_2(number): global shared_number print(&quot;number = &quot;,end=&quot;&quot;), print(number) for i in range(number): lock.acquire() # lock 획득 shared_number += 1 lock.release() # lock 해제if __name__ == &quot;__main__&quot;: threads = [ ] lock = threading.Lock() # lock 객체 생성 start_time = time.time() t1 = threading.Thread( target= thread_1, args=(50000000,) ) t1.start() threads.append(t1) t2 = threading.Thread( target= thread_2, args=(50000000,) ) t2.start() threads.append(t2) for t in threads: t.join() print(&quot;--- %s seconds ---&quot; % (time.time() - start_time)) print(&quot;shared_number=&quot;,end=&quot;&quot;), print(shared_number) print(&quot;end of main&quot;) 의도한대로 1억번의 +1이 연산되었음을 알 수 있다.하지만 단일 프로세스의 단일 쓰레드로 진행했을 때보다 훨씬 많은 시간이 소요되었음을 알 수 있는데 이는 연산을 할때마다 lock을 걸고 푸는 과정 때문에 더 오랜 시간이 걸린 것이다. 그렇다면 시간을 더 줄일 수는 없을까? 여기서 포인트는 이것이다. lock을 걸고 lock을 푸는 과정 이러한 과정은 특정 쓰레드가 lock이 걸렸음을 확인해야하고 언제 lock을 해제했는지도 확인해야하는데 그러한 일이 일어난 시점을 확인하는 것은 더욱 더 어렵다. 이를 조건에 따라 lock을 걸고 해제하는 것에 대한 것을 다른 쓰레드들에게 알릴 수 있다면 어떻게 될까 ? 이를 쓰레드 조건변수(thread condition)이라고 한다. python의 thread 모듈에선 이를 Condition 객체로 제공하고 있다. 이제 이를 활용해서 코드를 수정해보자. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import threadingimport timeshared_number = 0def thread_1(number): global shared_number print(&quot;number = &quot;,end=&quot;&quot;), print(number) cv.acquire() # lock 획득 for _ in range(number): shared_number += 1 cv.wait() # lock을 해제하고 알림을 받을 때까지 대기def thread_2(number): global shared_number print(&quot;number = &quot;,end=&quot;&quot;), print(number) cv.acquire() # lock 획득 for _ in range(number): shared_number += 1 cv.notify() # 대기 중인 thread1을 꺠움 cv.release() # lock을 해제if __name__ == &quot;__main__&quot;: threads = [ ] cv = threading.Condition() start_time = time.time() t1 = threading.Thread( target= thread_1, args=(50000000,) ) t1.start() threads.append(t1) t2 = threading.Thread( target= thread_2, args=(50000000,) ) t2.start() threads.append(t2) for t in threads: t.join() print(&quot;--- %s seconds ---&quot; % (time.time() - start_time)) print(&quot;shared_number=&quot;,end=&quot;&quot;), print(shared_number) print(&quot;end of main&quot;) lock을 사용하는 것보다 시간이 줄었음을 확인할 수 있다. 위의 코드의 동작에 대해 생각해보자 thread1과 thread2가 공유하는 뮤텍스(Mutex) 객체를 생성한다. thread1에서는 자신의 일을 끝낸 후 wait()을 통해 thread2에서 notify()를 통해 알림을 주는 것을 기다린다. thread2에서는 notify()를 통해 대기 중인 thread1의 lock을 가져와서 일을 시작한다. release()를 통해 lock을 해제한다. thread2에서 일을 끝내면 release()를 통해 lock을 해제한다. 하지만 2개의 쓰레드를 써도 실제로 시간이 단축되지 않았다.결국 하나의 프로세스 안에서만 돌아가기 때문이다.쓰레드 만으로는 여전히 혼자서 일을 하는 셈이다.","link":"/2020/09/18/python-thread/"},{"title":"REST API","text":"REST API란? REpresentational State Transfer API의 약자 REST 기반의 규칙을 지켜서 설계된 API를 의미하는데여기서 REST란 Resource Oriented Architecture이다.API 설계의 중심에 자원(Resource)이 있고, HTTP Method를 통해 자원을 처리하도록 설계하는 것을 의미한다. REST 구성요소크게 3가지의 구성으로 이루어져있다. 자원(resource) - URI 행위(verb) - HTTP Method 표현(representations) REST 특징 Uniform Interface(유니폼 인터페이스)URI로 지정한 자원에 대한 조작을 통일되고 한정적인 인터페이스로 수행한다. HTTP 표준에만 맞다면 어떤 플랫폼이든 사용이 가능하다. Stateless(무상태성)HTTP의 Stateless 성격과 동일하게 REST도 무상태성 성격을 갖는다. 이는 상태정보를 따로 저장하고 관리하지 않는다는 의미이다. 세션 정보나 쿠키 정보를 별도로 관리하지 않기 때문에 API서버는 들어오는 요청만 처리하면된다. 이를 통해 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해진다. Cacheable(캐시 가능)HTTP 프로토콜을 사용하므로 웹에서 사용하는 HTTP가 가진 캐싱 기능 적용이 가능하다. Self-descriptiveness(자체 표현 구조)REST API 메시지만 보고도 쉽게 이해할 수 있는 구조로 되어있다. Client-ServerREST 서버는 API를 제공하고 클라이언트는 사용자 인증, 컨텍스트 등을 관리하는 구조로 클라이언트와 서버에서 각각의 영역이 확실히 분리되기 때문에 개발해야할 내용이 명확해진다. Layerd System(계층형 구조)REST 서버는 다중 계층으로 구성될 수 있고 필요한 계층을 추가해 구조상의 유연성을 둘 수 있다. 또한 게이트웨이 같은 네트워크 기반의 중간 매체를 사용할 수 있게 한다. REST API 디자인 가이드이제 본격적으로 RESTful한 API를 설계하는 방법에 대해 알아보자.앞에서 설명했듯이 두 가지로 크게 요약할 수 있다. URI는 정보의 자원을 표현한다. 자원에 대한 행위는 HTTP Method로 표현한다. products라는 테이블을 RESTful API방식으로 처리한다고 생각해보자. REST API - GET products의 모든 정보를 가져오고 싶을 때GET http://10.58.4.1:8000/products 123456789101112131415161718192021response 200 OK{ &quot;results&quot;:[ { &quot;id&quot; :1, &quot;name&quot;: &quot;apple&quot;, &quot;price&quot;: &quot;3000&quot; }, { &quot;id&quot; :2, &quot;name&quot;: &quot;orange&quot;, &quot;price&quot;: &quot;5000&quot; }, { &quot;id&quot; :3, &quot;name&quot;: &quot;banana&quot;, &quot;price&quot;: &quot;3000&quot; } ]} products의 정보 중 id가 1인 것만 가져오고 싶을 때GET http://10.58.4.1:8000/products/1 1234567response 200 OK{ &quot;id&quot; :1, &quot;name&quot;: &quot;apple&quot;, &quot;price&quot;: &quot;3000&quot;} REST API - POST, PATCH products에 새로운 정보를 추가하고 싶을 때POST http://10.58.4.1:8000/products 이름이 apple이고 가격이 3000인 데이터를 추가한다는 요청을 보낸다. 123456request body{ &quot;name&quot;: &quot;apple&quot;, &quot;price&quot;: &quot;3000&quot;} 요청을 잘 받았다면 DB에 해당 데이터를 추가해준다. 1234567response body{ &quot;id&quot; :1, &quot;name&quot;: &quot;apple&quot;, &quot;price&quot;: &quot;3000&quot;} products에 새로운 정보를 일부분만 변경하고 싶을 때PATCH http://10.58.4.1:8000/products/1 id가 1인 데이터에 대해 가격을 1100으로 데이터를 수정한다는 요청을 보낸다. 12345request body{ &quot;price&quot;: &quot;1100&quot;} 요청을 잘 받았다면 DB에 해당 데이터를 수정해준다. 1234567response body{ &quot;id&quot; :1, &quot;name&quot;: &quot;apple&quot;, &quot;price&quot;: &quot;1100&quot;} REST API - DELETE products에 특정 정보를 삭제하고 싶을 때DELETE http://10.58.4.1:8000/products/1 request로 id가 1인 데이터를 삭제한다는 요청을 보내고 성공하였다면서버에서 response로 204 No Content` 라는 메시지를 보내준다 HTTP 응답 상태 코드REST API는 URI만 잘 설계된 것이 아닌 리소스에 대한 응답을 잘 보내주는 것까지 포함되어야 한다. 다음 그림은 주로 쓰이는 상태 코드들이다.","link":"/2020/10/06/rest-api/"}],"tags":[{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"Counter","slug":"Counter","link":"/tags/Counter/"},{"name":"Kruskal Algorithm","slug":"Kruskal-Algorithm","link":"/tags/Kruskal-Algorithm/"},{"name":"프로그래머스","slug":"프로그래머스","link":"/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"이분 탐색","slug":"이분-탐색","link":"/tags/%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89/"},{"name":"해시","slug":"해시","link":"/tags/%ED%95%B4%EC%8B%9C/"},{"name":"2020 카카오 코딩테스트","slug":"2020-카카오-코딩테스트","link":"/tags/2020-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"2018 카카오 코딩테스트","slug":"2018-카카오-코딩테스트","link":"/tags/2018-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"Heap","slug":"Heap","link":"/tags/Heap/"},{"name":"탐욕법","slug":"탐욕법","link":"/tags/%ED%83%90%EC%9A%95%EB%B2%95/"},{"name":"구현","slug":"구현","link":"/tags/%EA%B5%AC%ED%98%84/"},{"name":"2020 KAKAO BLIND RECRUITMENT","slug":"2020-KAKAO-BLIND-RECRUITMENT","link":"/tags/2020-KAKAO-BLIND-RECRUITMENT/"},{"name":"다이나믹 프로그래밍","slug":"다이나믹-프로그래밍","link":"/tags/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"SELECT","slug":"SELECT","link":"/tags/SELECT/"},{"name":"2021 KAKAO BLIND RECRUITMENT","slug":"2021-KAKAO-BLIND-RECRUITMENT","link":"/tags/2021-KAKAO-BLIND-RECRUITMENT/"},{"name":"MAX","slug":"MAX","link":"/tags/MAX/"},{"name":"HAVING","slug":"HAVING","link":"/tags/HAVING/"},{"name":"MIN","slug":"MIN","link":"/tags/MIN/"},{"name":"HOUR","slug":"HOUR","link":"/tags/HOUR/"},{"name":"GROUP BY","slug":"GROUP-BY","link":"/tags/GROUP-BY/"},{"name":"DISTINCT","slug":"DISTINCT","link":"/tags/DISTINCT/"},{"name":"IS NULL","slug":"IS-NULL","link":"/tags/IS-NULL/"},{"name":"IS NOT NULL","slug":"IS-NOT-NULL","link":"/tags/IS-NOT-NULL/"},{"name":"IFNULL","slug":"IFNULL","link":"/tags/IFNULL/"},{"name":"JOIN","slug":"JOIN","link":"/tags/JOIN/"},{"name":"LIMIT","slug":"LIMIT","link":"/tags/LIMIT/"},{"name":"WHERE","slug":"WHERE","link":"/tags/WHERE/"},{"name":"CASE","slug":"CASE","link":"/tags/CASE/"},{"name":"DATE_FORMAT","slug":"DATE-FORMAT","link":"/tags/DATE-FORMAT/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"await","slug":"await","link":"/tags/await/"},{"name":"투 포인터","slug":"투-포인터","link":"/tags/%ED%88%AC-%ED%8F%AC%EC%9D%B8%ED%84%B0/"},{"name":"에라토스테네스의 체","slug":"에라토스테네스의-체","link":"/tags/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98-%EC%B2%B4/"},{"name":"탐욕 알고리즘","slug":"탐욕-알고리즘","link":"/tags/%ED%83%90%EC%9A%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"소수","slug":"소수","link":"/tags/%EC%86%8C%EC%88%98/"},{"name":"다익스트라 알고리즘","slug":"다익스트라-알고리즘","link":"/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"완전 탐색","slug":"완전-탐색","link":"/tags/%EC%99%84%EC%A0%84-%ED%83%90%EC%83%89/"},{"name":"시뮬레이션","slug":"시뮬레이션","link":"/tags/%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"계수 정렬","slug":"계수-정렬","link":"/tags/%EA%B3%84%EC%88%98-%EC%A0%95%EB%A0%AC/"},{"name":"그리디 알고리즘","slug":"그리디-알고리즘","link":"/tags/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"비트마스크","slug":"비트마스크","link":"/tags/%EB%B9%84%ED%8A%B8%EB%A7%88%EC%8A%A4%ED%81%AC/"},{"name":"재귀함수","slug":"재귀함수","link":"/tags/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/"},{"name":"수학적 사고와 공식 활용","slug":"수학적-사고와-공식-활용","link":"/tags/%EC%88%98%ED%95%99%EC%A0%81-%EC%82%AC%EA%B3%A0%EC%99%80-%EA%B3%B5%EC%8B%9D-%ED%99%9C%EC%9A%A9/"},{"name":"나머지 연산자의 성질","slug":"나머지-연산자의-성질","link":"/tags/%EB%82%98%EB%A8%B8%EC%A7%80-%EC%97%B0%EC%82%B0%EC%9E%90%EC%9D%98-%EC%84%B1%EC%A7%88/"},{"name":"페르마의 소정리","slug":"페르마의-소정리","link":"/tags/%ED%8E%98%EB%A5%B4%EB%A7%88%EC%9D%98-%EC%86%8C%EC%A0%95%EB%A6%AC/"},{"name":"최대 공약수","slug":"최대-공약수","link":"/tags/%EC%B5%9C%EB%8C%80-%EA%B3%B5%EC%95%BD%EC%88%98/"},{"name":"스택","slug":"스택","link":"/tags/%EC%8A%A4%ED%83%9D/"},{"name":"재귀 호출","slug":"재귀-호출","link":"/tags/%EC%9E%AC%EA%B7%80-%ED%98%B8%EC%B6%9C/"},{"name":"분할 정복","slug":"분할-정복","link":"/tags/%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5/"},{"name":"boostcourse","slug":"boostcourse","link":"/tags/boostcourse/"},{"name":"웹기초","slug":"웹기초","link":"/tags/%EC%9B%B9%EA%B8%B0%EC%B4%88/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"servlet","slug":"servlet","link":"/tags/servlet/"},{"name":"Request","slug":"Request","link":"/tags/Request/"},{"name":"Response","slug":"Response","link":"/tags/Response/"},{"name":"웹 서버","slug":"웹-서버","link":"/tags/%EC%9B%B9-%EC%84%9C%EB%B2%84/"},{"name":"FE","slug":"FE","link":"/tags/FE/"},{"name":"BE","slug":"BE","link":"/tags/BE/"},{"name":"WAS","slug":"WAS","link":"/tags/WAS/"},{"name":"browser","slug":"browser","link":"/tags/browser/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"Wecode","slug":"Wecode","link":"/tags/Wecode/"},{"name":"BackEnd","slug":"BackEnd","link":"/tags/BackEnd/"},{"name":"후기","slug":"후기","link":"/tags/%ED%9B%84%EA%B8%B0/"},{"name":"마켓컬리","slug":"마켓컬리","link":"/tags/%EB%A7%88%EC%BC%93%EC%BB%AC%EB%A6%AC/"},{"name":"callback","slug":"callback","link":"/tags/callback/"},{"name":"이것이 취업을 위한 코딩테스트다","slug":"이것이-취업을-위한-코딩테스트다","link":"/tags/%EC%9D%B4%EA%B2%83%EC%9D%B4-%EC%B7%A8%EC%97%85%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%8B%A4/"},{"name":"circleci","slug":"circleci","link":"/tags/circleci/"},{"name":"Clean Code","slug":"Clean-Code","link":"/tags/Clean-Code/"},{"name":"layout","slug":"layout","link":"/tags/layout/"},{"name":"float","slug":"float","link":"/tags/float/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"RDBMS","slug":"RDBMS","link":"/tags/RDBMS/"},{"name":"position","slug":"position","link":"/tags/position/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"NoSQL","slug":"NoSQL","link":"/tags/NoSQL/"},{"name":"Transaction","slug":"Transaction","link":"/tags/Transaction/"},{"name":"트랜잭션","slug":"트랜잭션","link":"/tags/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"name":"Lock","slug":"Lock","link":"/tags/Lock/"},{"name":"이력 관리","slug":"이력-관리","link":"/tags/%EC%9D%B4%EB%A0%A5-%EA%B4%80%EB%A6%AC/"},{"name":"점 이력","slug":"점-이력","link":"/tags/%EC%A0%90-%EC%9D%B4%EB%A0%A5/"},{"name":"선분 이력","slug":"선분-이력","link":"/tags/%EC%84%A0%EB%B6%84-%EC%9D%B4%EB%A0%A5/"},{"name":"Index","slug":"Index","link":"/tags/Index/"},{"name":"인덱스","slug":"인덱스","link":"/tags/%EC%9D%B8%EB%8D%B1%EC%8A%A4/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"ORM","slug":"ORM","link":"/tags/ORM/"},{"name":"Framework","slug":"Framework","link":"/tags/Framework/"},{"name":"query string","slug":"query-string","link":"/tags/query-string/"},{"name":"쿼리 스트링","slug":"쿼리-스트링","link":"/tags/%EC%BF%BC%EB%A6%AC-%EC%8A%A4%ED%8A%B8%EB%A7%81/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Container","slug":"Container","link":"/tags/Container/"},{"name":"Library","slug":"Library","link":"/tags/Library/"},{"name":"MVT","slug":"MVT","link":"/tags/MVT/"},{"name":"filter","slug":"filter","link":"/tags/filter/"},{"name":"Docker Compose","slug":"Docker-Compose","link":"/tags/Docker-Compose/"},{"name":"Flask","slug":"Flask","link":"/tags/Flask/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"get","slug":"get","link":"/tags/get/"},{"name":"post","slug":"post","link":"/tags/post/"},{"name":"Git flow","slug":"Git-flow","link":"/tags/Git-flow/"},{"name":"GitHub flow","slug":"GitHub-flow","link":"/tags/GitHub-flow/"},{"name":"GitLab flow","slug":"GitLab-flow","link":"/tags/GitLab-flow/"},{"name":"Docker Volume","slug":"Docker-Volume","link":"/tags/Docker-Volume/"},{"name":"Docker Bind Mount","slug":"Docker-Bind-Mount","link":"/tags/Docker-Bind-Mount/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"Github Actions","slug":"Github-Actions","link":"/tags/Github-Actions/"},{"name":"Branch","slug":"Branch","link":"/tags/Branch/"},{"name":"template literal","slug":"template-literal","link":"/tags/template-literal/"},{"name":"Hoisting","slug":"Hoisting","link":"/tags/Hoisting/"},{"name":"함수 선언문","slug":"함수-선언문","link":"/tags/%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8%EB%AC%B8/"},{"name":"함수 표현식","slug":"함수-표현식","link":"/tags/%ED%95%A8%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"closure","slug":"closure","link":"/tags/closure/"},{"name":"클로저","slug":"클로저","link":"/tags/%ED%81%B4%EB%A1%9C%EC%A0%80/"},{"name":"NestJS","slug":"NestJS","link":"/tags/NestJS/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"fileread","slug":"fileread","link":"/tags/fileread/"},{"name":"Jest","slug":"Jest","link":"/tags/Jest/"},{"name":"Synchronous","slug":"Synchronous","link":"/tags/Synchronous/"},{"name":"Asynchronous","slug":"Asynchronous","link":"/tags/Asynchronous/"},{"name":"Prisma","slug":"Prisma","link":"/tags/Prisma/"},{"name":"promise","slug":"promise","link":"/tags/promise/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"coroutine","slug":"coroutine","link":"/tags/coroutine/"},{"name":"비동기","slug":"비동기","link":"/tags/%EB%B9%84%EB%8F%99%EA%B8%B0/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"default value parameter","slug":"default-value-parameter","link":"/tags/default-value-parameter/"},{"name":"non-default value parameter","slug":"non-default-value-parameter","link":"/tags/non-default-value-parameter/"},{"name":"generator","slug":"generator","link":"/tags/generator/"},{"name":"lazy evaluation","slug":"lazy-evaluation","link":"/tags/lazy-evaluation/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"module","slug":"module","link":"/tags/module/"},{"name":"packages","slug":"packages","link":"/tags/packages/"},{"name":"sys.mdules","slug":"sys-mdules","link":"/tags/sys-mdules/"},{"name":"sys.path","slug":"sys-path","link":"/tags/sys-path/"},{"name":"process","slug":"process","link":"/tags/process/"},{"name":"multiprocessing","slug":"multiprocessing","link":"/tags/multiprocessing/"},{"name":"reduce","slug":"reduce","link":"/tags/reduce/"},{"name":"Semantic Web","slug":"Semantic-Web","link":"/tags/Semantic-Web/"},{"name":"UTF8","slug":"UTF8","link":"/tags/UTF8/"},{"name":"WSL","slug":"WSL","link":"/tags/WSL/"},{"name":"thread","slug":"thread","link":"/tags/thread/"},{"name":"REST API","slug":"REST-API","link":"/tags/REST-API/"},{"name":"REST","slug":"REST","link":"/tags/REST/"}],"categories":[{"name":"알고리즘 &amp; SQL","slug":"알고리즘-SQL","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-SQL/"},{"name":"프로그래머스","slug":"알고리즘-SQL/프로그래머스","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-SQL/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"SQL","slug":"알고리즘-SQL/SQL","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-SQL/SQL/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"백준","slug":"알고리즘-SQL/백준","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-SQL/%EB%B0%B1%EC%A4%80/"},{"name":"AWS","slug":"AWS","link":"/categories/AWS/"},{"name":"비타알고","slug":"알고리즘-SQL/비타알고","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-SQL/%EB%B9%84%ED%83%80%EC%95%8C%EA%B3%A0/"},{"name":"부스트코스","slug":"부스트코스","link":"/categories/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BD%94%EC%8A%A4/"},{"name":"1. 웹 프로그래밍 기초","slug":"부스트코스/1-웹-프로그래밍-기초","link":"/categories/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BD%94%EC%8A%A4/1-%EC%9B%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B8%B0%EC%B4%88/"},{"name":"2. DB 연결 웹 앱","slug":"부스트코스/2-DB-연결-웹-앱","link":"/categories/%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BD%94%EC%8A%A4/2-DB-%EC%97%B0%EA%B2%B0-%EC%9B%B9-%EC%95%B1/"},{"name":"회고록","slug":"회고록","link":"/categories/%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"name":"코딩 테스트 준비","slug":"알고리즘-SQL/코딩-테스트-준비","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-SQL/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A4%80%EB%B9%84/"},{"name":"DevOps","slug":"DevOps","link":"/categories/DevOps/"},{"name":"개발 서적","slug":"개발-서적","link":"/categories/%EA%B0%9C%EB%B0%9C-%EC%84%9C%EC%A0%81/"},{"name":"프로젝트 후기","slug":"회고록/프로젝트-후기","link":"/categories/%ED%9A%8C%EA%B3%A0%EB%A1%9D/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9B%84%EA%B8%B0/"},{"name":"HTML&#x2F;CSS","slug":"HTML-CSS","link":"/categories/HTML-CSS/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Framework","slug":"Framework","link":"/categories/Framework/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"DB","slug":"Database/DB","link":"/categories/Database/DB/"},{"name":"MySQL","slug":"Database/MySQL","link":"/categories/Database/MySQL/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"WEB","slug":"WEB","link":"/categories/WEB/"},{"name":"Django","slug":"Framework/Django","link":"/categories/Framework/Django/"},{"name":"LeetCode","slug":"알고리즘-SQL/LeetCode","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-SQL/LeetCode/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Flask","slug":"Framework/Flask","link":"/categories/Framework/Flask/"},{"name":"Prisma","slug":"Node-js/Prisma","link":"/categories/Node-js/Prisma/"}]}